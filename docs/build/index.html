<!DOCTYPE html>
<html>
  <head>
    <title>INDX 0.01 documentation</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="lib/bootstrap/css/bootstrap.min.css" rel="stylesheet" media="screen">
    <style>
    body {
      max-width: 900px;
    }
    .sidebar {
      position: fixed;
      z-index: 10;
      top: 0;
      left: 0;
      bottom: 0;
      width: 230px;
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      padding: 15px 0 30px 30px;
      border-right: 1px solid #bbb;
      box-shadow: 0 0 20px #ccc;
      -webkit-box-shadow: 0 0 20px #ccc;
      -moz-box-shadow: 0 0 20px #ccc;
    }
    .mainbody {
      margin-left: 300px;
    }
    h3 {
      color: #c17878;
      display: inline-block;
      padding-right: 15px;
    }
    .extends {
      display: inline-block;
      font-size: 14px;
    }
    h4 {
      display: inline-block;
      padding-right: 15px;
      color: #78ba91;
    }
    code.header-example {
      background: transparent;
      border: 0;
    }
    .class {
      padding: 5px 0 20px;
      border-bottom: 1px solid #eee;
    }
    .file {
      border-top: 1px solid #ccc;
      margin-top: 50px;
      padding-top: 20px;
    }
    </style>
    <script>
    data = {"files":[{"promise":{"promise":{}},"app":"~","file":"../html/../docs/abstracts/backbone-abstract.js","classes":[{"data":"///\n/// @title Backbone.js\n/// @supplementary\n/// Provides the structure and documention for Backbone\n(function () {\n\t\"use strict\";\n\n\tvar Backbone = {};\n\n\tBackbone.Model = function () {\n\t};\n\n\t/// @arg properties\n\t/// @opt classProperties\n\t///\n\t/// To create a Model class of your own, you extend Backbone.Model and\n\t/// provide instance properties, as well as optional classProperties to be\n\t/// attached directly to the constructor function.\n\tBackbone.Model.prototype.extend = function () {};\n\n\t/// @opt attributes\n\t/// @opt options\n\t/// When creating an instance of a model, you can pass in the initial values of the attributes, which will be set on the model. If you define an initialize function, it will be invoked when the model is created.\n\tBackbone.Model.prototype.initialize = function () {};\n\n\t/// @arg attribute\n\t/// Get the current value of an attribute from the model. For example: note.get(\"title\")\n\tBackbone.Model.prototype.get = function () {};\n\n\tBackbone.Model.prototype.set = function () {};\n\n\tBackbone.Model.prototype.escape = function () {};\n\n\tBackbone.Model.prototype.has = function () {};\n\n\tBackbone.Model.prototype.unset = function () {};\n\n\tBackbone.Model.prototype.clear = function () {};\n\n\tBackbone.Model.prototype.toJSON = function () {};\n\n\tBackbone.Model.prototype.initialize = function () {};\n\n\tBackbone.Model.prototype.fetch = function () {};\n\n\tBackbone.Model.prototype.save = function () {};\n\n\tBackbone.Model.prototype.destroy = function () {};\n\n\tBackbone.Model.prototype.isValid = function () {};\n\n\tBackbone.Model.prototype.clone = function () {};\n\n\tBackbone.Model.prototype.isNew = function () {};\n\n\tBackbone.Model.prototype.hasChanged = function () {};\n\n\tBackbone.Model.prototype.previous = function () {};\n\n\tBackbone.Model.prototype.changedAttributes = function () {};\n\n\tBackbone.Model.prototype.previousAttributes = function () {};\n\n\tBackbone.Model.prototype.id = function () {};\n\n\tBackbone.Model.prototype.attributes = function () {};\n\n\tBackbone.Model.prototype.cid = function () {};\n\n\tBackbone.Model.prototype.changed = function () {};\n\n\tBackbone.Model.prototype.url = function () {};\n\n\t//Backbone.Model.prototype.urlRoot = \"\";\n\n\n\tBackbone.Collection = function () {};\n\n\tBackbone.Model.prototype.extend = function () {};\n\n\tBackbone.Model.prototype.initialize = function () {};\n\n\tBackbone.Model.prototype.add = function () {};\n\n\tBackbone.Model.prototype.remove = function () {};\n\n\tBackbone.Model.prototype.reset = function () {};\n\n\tBackbone.Model.prototype.get = function () {};\n\n\tBackbone.Model.prototype.set = function () {};\n\n\tBackbone.Model.prototype.at = function () {};\n\n\tBackbone.Model.prototype.push = function () {};\n\n\tBackbone.Model.prototype.pop = function () {};\n\n\tBackbone.Model.prototype.unshift = function () {};\n\n\tBackbone.Model.prototype.shift = function () {};\n\n\tBackbone.Model.prototype.slice = function () {};\n\n\tBackbone.Model.prototype.sort = function () {};\n\n\tBackbone.Model.prototype.pluck = function () {};\n\n\tBackbone.Model.prototype.where = function () {};\n\n\tBackbone.Model.prototype.findWhere = function () {};\n\n\tBackbone.Model.prototype.clone = function () {};\n\n\tBackbone.Model.prototype.fetch = function () {};\n\n\tBackbone.Model.prototype.create = function () {};\n\n\t//Backbone.Model.prototype.model = function () {};\n\n\t//Backbone.Model.prototype.models = function () {};\n\n\t//Backbone.Model.prototype.length\n\n}());\n","methods":[{"name":"extend","args":[{"mode":{"optional":true},"types":"","name":"classProperties","comment":"","moreInfo":false,"last":false},{"mode":{"mandatory":true},"types":"","name":"properties","comment":"","moreInfo":false,"last":true}],"start":468,"line":20,"description":"To create a Model class of your own, you extend Backbone.Model and\n/// provide instance properties, as well as optional classProperties to be\n/// attached directly to the constructor function.","result":"","hasArgs":true,"cls":"~classes~0"},{"name":"initialize","args":[{"mode":{"optional":true},"types":"","name":"options","comment":"","moreInfo":false,"last":false},{"mode":{"optional":true},"types":"","name":"attributes","comment":"","moreInfo":false,"last":true}],"start":772,"line":25,"description":"When creating an instance of a model, you can pass in the initial values of the attributes, which will be set on the model. If you define an initialize function, it will be invoked when the model is created.","result":"","hasArgs":true,"cls":"~classes~0"},{"name":"get","args":[{"mode":{"mandatory":true},"types":"","name":"attribute","comment":"","moreInfo":false,"last":true}],"start":938,"line":29,"description":"Get the current value of an attribute from the model. For example: note.get(\"title\")","result":"","hasArgs":true,"cls":"~classes~0"},{"name":"set","args":[],"start":987,"line":31,"description":"","result":"","cls":"~classes~0"},{"name":"escape","args":[],"start":1036,"line":33,"description":"","result":"","cls":"~classes~0"},{"name":"has","args":[],"start":1088,"line":35,"description":"","result":"","cls":"~classes~0"},{"name":"unset","args":[],"start":1137,"line":37,"description":"","result":"","cls":"~classes~0"},{"name":"clear","args":[],"start":1188,"line":39,"description":"","result":"","cls":"~classes~0"},{"name":"toJSON","args":[],"start":1239,"line":41,"description":"","result":"","cls":"~classes~0"},{"name":"initialize","args":[],"start":1291,"line":43,"description":"","result":"","cls":"~classes~0"},{"name":"fetch","args":[],"start":1347,"line":45,"description":"","result":"","cls":"~classes~0"},{"name":"save","args":[],"start":1398,"line":47,"description":"","result":"","cls":"~classes~0"},{"name":"destroy","args":[],"start":1448,"line":49,"description":"","result":"","cls":"~classes~0"},{"name":"isValid","args":[],"start":1501,"line":51,"description":"","result":"","cls":"~classes~0"},{"name":"clone","args":[],"start":1554,"line":53,"description":"","result":"","cls":"~classes~0"},{"name":"isNew","args":[],"start":1605,"line":55,"description":"","result":"","cls":"~classes~0"},{"name":"hasChanged","args":[],"start":1656,"line":57,"description":"","result":"","cls":"~classes~0"},{"name":"previous","args":[],"start":1712,"line":59,"description":"","result":"","cls":"~classes~0"},{"name":"changedAttributes","args":[],"start":1766,"line":61,"description":"","result":"","cls":"~classes~0"},{"name":"previousAttributes","args":[],"start":1829,"line":63,"description":"","result":"","cls":"~classes~0"},{"name":"id","args":[],"start":1893,"line":65,"description":"","result":"","cls":"~classes~0"},{"name":"attributes","args":[],"start":1941,"line":67,"description":"","result":"","cls":"~classes~0"},{"name":"cid","args":[],"start":1997,"line":69,"description":"","result":"","cls":"~classes~0"},{"name":"changed","args":[],"start":2046,"line":71,"description":"","result":"","cls":"~classes~0"},{"name":"url","args":[],"start":2099,"line":73,"description":"","result":"","cls":"~classes~0"}],"properties":[],"match":"Backbone.Model = function ()","name":"Model","fullName":"Backbone.Model","start":155,"end":2167},{"data":"///\n/// @title Backbone.js\n/// @supplementary\n/// Provides the structure and documention for Backbone\n(function () {\n\t\"use strict\";\n\n\tvar Backbone = {};\n\n\tBackbone.Model = function () {\n\t};\n\n\t/// @arg properties\n\t/// @opt classProperties\n\t///\n\t/// To create a Model class of your own, you extend Backbone.Model and\n\t/// provide instance properties, as well as optional classProperties to be\n\t/// attached directly to the constructor function.\n\tBackbone.Model.prototype.extend = function () {};\n\n\t/// @opt attributes\n\t/// @opt options\n\t/// When creating an instance of a model, you can pass in the initial values of the attributes, which will be set on the model. If you define an initialize function, it will be invoked when the model is created.\n\tBackbone.Model.prototype.initialize = function () {};\n\n\t/// @arg attribute\n\t/// Get the current value of an attribute from the model. For example: note.get(\"title\")\n\tBackbone.Model.prototype.get = function () {};\n\n\tBackbone.Model.prototype.set = function () {};\n\n\tBackbone.Model.prototype.escape = function () {};\n\n\tBackbone.Model.prototype.has = function () {};\n\n\tBackbone.Model.prototype.unset = function () {};\n\n\tBackbone.Model.prototype.clear = function () {};\n\n\tBackbone.Model.prototype.toJSON = function () {};\n\n\tBackbone.Model.prototype.initialize = function () {};\n\n\tBackbone.Model.prototype.fetch = function () {};\n\n\tBackbone.Model.prototype.save = function () {};\n\n\tBackbone.Model.prototype.destroy = function () {};\n\n\tBackbone.Model.prototype.isValid = function () {};\n\n\tBackbone.Model.prototype.clone = function () {};\n\n\tBackbone.Model.prototype.isNew = function () {};\n\n\tBackbone.Model.prototype.hasChanged = function () {};\n\n\tBackbone.Model.prototype.previous = function () {};\n\n\tBackbone.Model.prototype.changedAttributes = function () {};\n\n\tBackbone.Model.prototype.previousAttributes = function () {};\n\n\tBackbone.Model.prototype.id = function () {};\n\n\tBackbone.Model.prototype.attributes = function () {};\n\n\tBackbone.Model.prototype.cid = function () {};\n\n\tBackbone.Model.prototype.changed = function () {};\n\n\tBackbone.Model.prototype.url = function () {};\n\n\t//Backbone.Model.prototype.urlRoot = \"\";\n\n\n\tBackbone.Collection = function () {};\n\n\tBackbone.Model.prototype.extend = function () {};\n\n\tBackbone.Model.prototype.initialize = function () {};\n\n\tBackbone.Model.prototype.add = function () {};\n\n\tBackbone.Model.prototype.remove = function () {};\n\n\tBackbone.Model.prototype.reset = function () {};\n\n\tBackbone.Model.prototype.get = function () {};\n\n\tBackbone.Model.prototype.set = function () {};\n\n\tBackbone.Model.prototype.at = function () {};\n\n\tBackbone.Model.prototype.push = function () {};\n\n\tBackbone.Model.prototype.pop = function () {};\n\n\tBackbone.Model.prototype.unshift = function () {};\n\n\tBackbone.Model.prototype.shift = function () {};\n\n\tBackbone.Model.prototype.slice = function () {};\n\n\tBackbone.Model.prototype.sort = function () {};\n\n\tBackbone.Model.prototype.pluck = function () {};\n\n\tBackbone.Model.prototype.where = function () {};\n\n\tBackbone.Model.prototype.findWhere = function () {};\n\n\tBackbone.Model.prototype.clone = function () {};\n\n\tBackbone.Model.prototype.fetch = function () {};\n\n\tBackbone.Model.prototype.create = function () {};\n\n\t//Backbone.Model.prototype.model = function () {};\n\n\t//Backbone.Model.prototype.models = function () {};\n\n\t//Backbone.Model.prototype.length\n\n}());\n","methods":[{"name":"extend","args":[],"start":2232,"line":80,"description":"","result":"","cls":"~1"},{"name":"initialize","args":[],"start":2284,"line":82,"description":"","result":"","cls":"~1"},{"name":"add","args":[],"start":2340,"line":84,"description":"","result":"","cls":"~1"},{"name":"remove","args":[],"start":2389,"line":86,"description":"","result":"","cls":"~1"},{"name":"reset","args":[],"start":2441,"line":88,"description":"","result":"","cls":"~1"},{"name":"get","args":[],"start":2492,"line":90,"description":"","result":"","cls":"~1"},{"name":"set","args":[],"start":2541,"line":92,"description":"","result":"","cls":"~1"},{"name":"at","args":[],"start":2590,"line":94,"description":"","result":"","cls":"~1"},{"name":"push","args":[],"start":2638,"line":96,"description":"","result":"","cls":"~1"},{"name":"pop","args":[],"start":2688,"line":98,"description":"","result":"","cls":"~1"},{"name":"unshift","args":[],"start":2737,"line":100,"description":"","result":"","cls":"~1"},{"name":"shift","args":[],"start":2790,"line":102,"description":"","result":"","cls":"~1"},{"name":"slice","args":[],"start":2841,"line":104,"description":"","result":"","cls":"~1"},{"name":"sort","args":[],"start":2892,"line":106,"description":"","result":"","cls":"~1"},{"name":"pluck","args":[],"start":2942,"line":108,"description":"","result":"","cls":"~1"},{"name":"where","args":[],"start":2993,"line":110,"description":"","result":"","cls":"~1"},{"name":"findWhere","args":[],"start":3044,"line":112,"description":"","result":"","cls":"~1"},{"name":"clone","args":[],"start":3099,"line":114,"description":"","result":"","cls":"~1"},{"name":"fetch","args":[],"start":3150,"line":116,"description":"","result":"","cls":"~1"},{"name":"create","args":[],"start":3201,"line":118,"description":"","result":"","cls":"~1"},{"name":"model","args":[],"start":3255,"line":120,"description":"","result":"","cls":"~1"},{"name":"models","args":[],"start":3308,"line":122,"description":"","result":"","cls":"~1"}],"properties":[],"match":"Backbone.Collection = function ()","name":"Collection","fullName":"Backbone.Collection","start":2168,"end":3376}],"data":"///\n/// @title Backbone.js\n/// @supplementary\n/// Provides the structure and documention for Backbone\n(function () {\n\t\"use strict\";\n\n\tvar Backbone = {};\n\n\tBackbone.Model = function () {\n\t};\n\n\t/// @arg properties\n\t/// @opt classProperties\n\t///\n\t/// To create a Model class of your own, you extend Backbone.Model and\n\t/// provide instance properties, as well as optional classProperties to be\n\t/// attached directly to the constructor function.\n\tBackbone.Model.prototype.extend = function () {};\n\n\t/// @opt attributes\n\t/// @opt options\n\t/// When creating an instance of a model, you can pass in the initial values of the attributes, which will be set on the model. If you define an initialize function, it will be invoked when the model is created.\n\tBackbone.Model.prototype.initialize = function () {};\n\n\t/// @arg attribute\n\t/// Get the current value of an attribute from the model. For example: note.get(\"title\")\n\tBackbone.Model.prototype.get = function () {};\n\n\tBackbone.Model.prototype.set = function () {};\n\n\tBackbone.Model.prototype.escape = function () {};\n\n\tBackbone.Model.prototype.has = function () {};\n\n\tBackbone.Model.prototype.unset = function () {};\n\n\tBackbone.Model.prototype.clear = function () {};\n\n\tBackbone.Model.prototype.toJSON = function () {};\n\n\tBackbone.Model.prototype.initialize = function () {};\n\n\tBackbone.Model.prototype.fetch = function () {};\n\n\tBackbone.Model.prototype.save = function () {};\n\n\tBackbone.Model.prototype.destroy = function () {};\n\n\tBackbone.Model.prototype.isValid = function () {};\n\n\tBackbone.Model.prototype.clone = function () {};\n\n\tBackbone.Model.prototype.isNew = function () {};\n\n\tBackbone.Model.prototype.hasChanged = function () {};\n\n\tBackbone.Model.prototype.previous = function () {};\n\n\tBackbone.Model.prototype.changedAttributes = function () {};\n\n\tBackbone.Model.prototype.previousAttributes = function () {};\n\n\tBackbone.Model.prototype.id = function () {};\n\n\tBackbone.Model.prototype.attributes = function () {};\n\n\tBackbone.Model.prototype.cid = function () {};\n\n\tBackbone.Model.prototype.changed = function () {};\n\n\tBackbone.Model.prototype.url = function () {};\n\n\t//Backbone.Model.prototype.urlRoot = \"\";\n\n\n\tBackbone.Collection = function () {};\n\n\tBackbone.Model.prototype.extend = function () {};\n\n\tBackbone.Model.prototype.initialize = function () {};\n\n\tBackbone.Model.prototype.add = function () {};\n\n\tBackbone.Model.prototype.remove = function () {};\n\n\tBackbone.Model.prototype.reset = function () {};\n\n\tBackbone.Model.prototype.get = function () {};\n\n\tBackbone.Model.prototype.set = function () {};\n\n\tBackbone.Model.prototype.at = function () {};\n\n\tBackbone.Model.prototype.push = function () {};\n\n\tBackbone.Model.prototype.pop = function () {};\n\n\tBackbone.Model.prototype.unshift = function () {};\n\n\tBackbone.Model.prototype.shift = function () {};\n\n\tBackbone.Model.prototype.slice = function () {};\n\n\tBackbone.Model.prototype.sort = function () {};\n\n\tBackbone.Model.prototype.pluck = function () {};\n\n\tBackbone.Model.prototype.where = function () {};\n\n\tBackbone.Model.prototype.findWhere = function () {};\n\n\tBackbone.Model.prototype.clone = function () {};\n\n\tBackbone.Model.prototype.fetch = function () {};\n\n\tBackbone.Model.prototype.create = function () {};\n\n\t//Backbone.Model.prototype.model = function () {};\n\n\t//Backbone.Model.prototype.models = function () {};\n\n\t//Backbone.Model.prototype.length\n\n}());\n","title":"Backbone.js","description":"Provides the structure and documention for Backbone","parameters":{"supplementary":true}},{"promise":{"promise":{}},"app":"~","file":"../html/js/indx.js","classes":[{"data":"///\n/// @title INDX\n/// blah\n\n/*global $,_,document,window,console,escape,Backbone,exports,WebSocket */\n/*jslint vars:true, todo:true */\n/*\n\n  indx.js is the JS Client SDK for WebBox WebBox\n  which builds upon Backbone's Model architecture.\n\n  CURRENT TODOs:\n  \t- update only supports updating the entire box\n    - Box.fetch() retrieves _entire box contents_\n\t  ... which is a really bad idea.\n\n  @prerequisites:\n\tjquery 1.8.0 or higher\n\tbackbone.js 0.9.2 or higher\n\tunderscore.js 1.4.2 or higher\n\n  This file is part of INDX\n  Copyright 2012 Max Van Kleek, Daniel Alexander Smith\n  Copyright 2012 University of Southampton\n\n  WebBox is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  WebBox is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with Indx.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n\nangular\n\t.module('indx', ['ui'])\n\t.factory('client',function(utils) {\n\t\tvar u = utils; // to be filled in by dependency\n\t\t// set up our parameters for webbox -\n\t\t// default is that we're loading from an _app_ hosted within\n\t\t// indx.\n\t\tvar DEFAULT_HOST = document.location.host; // which may contain the port\n\t\tvar WS_MESSAGES_SEND = {\n\t\t\tauth: function(token) { return JSON.stringify({action:'auth', token:token}); },\n\t\t\tdiff: function(token) { return JSON.stringify({action:'diff', operation:\"start\"}); }\n\t\t};\n\t\tvar serialize_obj = function(obj) {\n\t\t\tvar uri = obj.id;\n\t\t\tvar out_obj = {};\n\t\t\t$.each(obj.attributes, function(pred, vals){\n\t\t\t\tif (pred[0] === \"_\" || pred[0] === \"@\"){\n\t\t\t\t\t// don't expand @id etc.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar obj_vals = [];\n\t\t\t\tif (!(vals instanceof Array)){\n\t\t\t\t\tvals = [vals];\n\t\t\t\t}\n\t\t\t\t$.each(vals, function(){\n\t\t\t\t\tvar val = this;\n\t\t\t\t\tif (val instanceof File) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.id, \"@type\":\"indx-file\", \"@language\":val.get('content-type')});\n\t\t\t\t\t} else if (val instanceof Obj) {\n\t\t\t\t\t\tobj_vals.push({\"@id\": val.id });\n\t\t\t\t\t} else if (typeof val === \"object\" && (val[\"@value\"] || val[\"@id\"])) {\n\t\t\t\t\t\tobj_vals.push(val); // fully expanded string, e.g. {\"@value\": \"foo\", \"@language\": \"en\" ... }\n\t\t\t\t\t} else if (typeof val === \"string\" || val instanceof String ){\n\t\t\t\t\t\tobj_vals.push({\"@value\": val});\n\t\t\t\t\t} else if (_.isDate(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toISOString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"});\n\t\t\t\t\t} else if (_.isNumber(val) && u.isInteger(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#integer\"});\n\t\t\t\t\t} else if (_.isNumber(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#float\"});\n\t\t\t\t\t} else if (_.isBoolean(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#boolean\"});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu.warn(\"Could not determine type of val \", pred, val);\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString()});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tout_obj[pred] = obj_vals;\n\t\t\t});\n\t\t\tout_obj['@id'] = uri;\n\t\t\treturn out_obj;\n\t\t};\n\n\t\tvar literal_deserializers = {\n\t\t\t'': function(o) { return o['@value']; },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#integer\": function(o) { return parseInt(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#float\": function(o) { return parseFloat(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#double\": function(o) { return parseFloat(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#boolean\": function(o) { return o['@value'].toLowerCase() === 'true'; },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#dateTime\": function(o) { return new Date(Date.parse(o['@value'])); },\n\t\t\t\"indx-file\": function(o,box) {\n\t\t\t\tvar f = box.get_or_create_file(o['@value']);\n\t\t\t\tf.set(\"content-type\", o['@language']);\n\t\t\t\treturn f;\n\t\t\t}\n\t\t};\n\t\tvar deserialize_literal = function(obj, box) {\n\t\t\treturn obj['@value'] !== undefined ? literal_deserializers[ obj['@type'] || '' ](obj, box) : obj;\n\t\t};\n\n\t\tvar deserialize_value = function(s_val, box) {\n\t\t\tvar vd = u.deferred();\n\t\t\t// it's an object, so return that\n\t\t\tif (s_val.hasOwnProperty(\"@id\")) {\n\t\t\t\t// object\n\t\t\t\tbox.get_obj(s_val[\"@id\"]).then(vd.resolve).fail(vd.reject);\n\t\t\t}\n\t\t\telse if (s_val.hasOwnProperty(\"@value\")) {\n\t\t\t\t// literal\n\t\t\t\tvd.resolve(deserialize_literal(s_val, box));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// don't know what it is!\n\t\t\t\tvd.reject('cannot unpack value ', s_val);\n\t\t\t}\n\t\t\treturn vd.promise();\n\t\t};\n\n\t\tvar File =  Backbone.Model.extend({\n\t\t\tidAttribute: \"@id\", // the URI attribute is '@id' in JSON-LD\n\t\t\tinitialize:function(attrs, options) {\n\t\t\t\tu.debug('options >> ', attrs, options );\n\t\t\t\tthis.box = options.box;\n\t\t\t},\n\t\t\tget_id:function() { return this.id;\t},\n\t\t\tget_url:function() {\n\t\t\t\tvar params = {\n\t\t\t\t\tid:this.get_id(),\n\t\t\t\t\tapp:this.box.store.get('app'),\n\t\t\t\t\ttoken:this.box.get('token'),\n\t\t\t\t\tbox:this.box.get_id()\n\t\t\t\t}, url = ['/', this.box.store.get('server_host'), this.box.id, 'files'].join('/') + '?' + $.param(params);\n\t\t\t\t// u.debug(\"IMAGE URL IS \", url, params);\n\t\t\t\treturn url;\n\t\t\t}\n\t\t});\n\n\n\t\t// MAP OF THIS MODUULE :::::::::::::: -----\n\t\t//\n\t\t// An Obj is a single instance, thing in Indx.\n\t\t//\n\t\t// A Box is a model that has an attribute called 'Objs'.\n\t\t// ...  which is a Backbone.Collection of Graph objects.\n\t\t//\n\t\t// A _Store_ represents a single Indx server, which has an\n\t\t//\t attribute called 'boxes' -\n\t\t// ... which is a collection of Box objects\n\t\tvar Obj =  Backbone.Model.extend({\n\t\t\tidAttribute: \"@id\", // the URI attribute is '@id' in JSON-LD\n\t\t\tinitialize:function(attrs, options) {\n\t\t\t\tthis.box = options.box;\n\t\t\t},\n\t\t\t_is_fetched: function() { return this._fetched || false; },\n\t\t\t_set_fetched : function() { this._fetched = true; },\n\t\t\tget_id:function() { return this.id;\t},\n\t\t\t_value_to_array:function(k,v) {\n\t\t\t\tif (k === '@id') { return v; }\n\t\t\t\tif (!_(v).isUndefined() && !_(v).isArray()) {\n\t\t\t\t\treturn [v];\n\t\t\t\t}\n\t\t\t\treturn v;\n\t\t\t},\n\t\t\t_all_values_to_arrays:function(o) {\n\t\t\t\tif (!_(o).isObject()) { utils.error(' not an object', o); return o; }\n\t\t\t\tvar this_ = this;\n\t\t\t\t// ?!?! this isn't doing anything (!!)\n\t\t\t\treturn u.dict(_(o).map(function(v,k) {\n\t\t\t\t\tvar val = this_._value_to_array(k,v);\n\t\t\t\t\tif (u.defined(val)) { return [k,val]; }\n\t\t\t\t\treturn undefined;\n\t\t\t\t}).filter(u.defined));\n\t\t\t},\n\t\t\tset:function(k,v,options) {\n\t\t\t\t// set is tricky because it can be called like\n\t\t\t\t// set('foo',123) or set({foo:123})\n\t\t\t\tif (typeof k === 'string') { v = this._value_to_array(k,v);\t}\n\t\t\t\telse {\tk = this._all_values_to_arrays(k);\t}\n\t\t\t\treturn Backbone.Model.prototype.set.apply(this,[k,v,options]);\n\t\t\t},\n\t\t\tdelete_properties:function(props, silent)  {\n\t\t\t\tvar this_ = this;\n\t\t\t\tprops.map(function(p) { this_.unset(p, silent ? {silent:true} : {}); });\n\t\t\t},\n\t\t\t_deserialise_and_set:function(s_obj, silent) {\n\t\t\t\t// returns a promise\n\t\t\t\tvar this_ = this;\n\t\t\t\tvar dfds = _(s_obj).map(function(vals, key) {\n\t\t\t\t\tvar kd = u.deferred();\n\t\t\t\t\tif (key.indexOf('@') === 0) { return; }\n\t\t\t\t\tvar val_dfds = vals.map(function(val) {\n\t\t\t\t\t\tvar vd = u.deferred();\n\t\t\t\t\t\t// it's an object, so return that\n\t\t\t\t\t\tif (val.hasOwnProperty(\"@id\")) {\n\t\t\t\t\t\t\t// object\n\t\t\t\t\t\t\tthis_.box.get_obj(val[\"@id\"]).then(vd.resolve).fail(vd.reject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (val.hasOwnProperty(\"@value\")) {\n\t\t\t\t\t\t\t// literal\n\t\t\t\t\t\t\tvd.resolve(deserialize_literal(val, this_.box));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// don't know what it is!\n\t\t\t\t\t\t\tvd.reject('cannot unpack value ', val);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn vd.promise();\n\t\t\t\t\t});\n\t\t\t\t\tu.when(val_dfds).then(function(obj_vals) {\n\t\t\t\t\t\t// only update keys that have changed\n\t\t\t\t\t\tvar prev_vals = this_.get(key);\n\t\t\t\t\t\tif ( prev_vals === undefined || obj_vals.length !== prev_vals.length ||\n\t\t\t\t\t\t\t _(obj_vals).difference(prev_vals).length > 0 ||\n\t\t\t\t\t\t\t _(prev_vals).difference(obj_vals).length > 0) {\n\t\t\t\t\t\t\tthis_.set(key, obj_vals, { silent : silent });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkd.resolve();\n\t\t\t\t\t}).fail(kd.reject);\n\t\t\t\t\treturn kd.promise();\n\t\t\t\t}).filter(u.defined);\n\t\t\t\treturn u.when(dfds);\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\tvar this_ = this, fd = u.deferred(), box = this.box.get_id();\n\t\t\t\tthis.box._ajax('GET', box, {'id':this.id}).then(function(response) {\n\t\t\t\t\tthis_._set_fetched(true);\n\t\t\t\t\tvar objdata = response.data;\n\t\t\t\t\tif (objdata['@version'] === undefined) {\n\t\t\t\t\t\t// then the server thinks we've been deleted, so let's just die.\n\t\t\t\t\t\treturn fd.reject(this_.id);\n\t\t\t\t\t\t// old code:\n\t\t\t\t\t\t// according to the server, we're dead.\n\t\t\t\t\t\t// console.log('zombie detected ', this_.id);\n\t\t\t\t\t\t// this_.cid = this_.id;\n\t\t\t\t\t\t// this_.unset({});\n\t\t\t\t\t\t// delete this_.id;\n\t\t\t\t\t\t// fd.resolve();\n\t\t\t\t\t\t// return;\n\t\t\t\t\t}\n\t\t\t\t\t// we are at current known version as far as we know\n\t\t\t\t\tvar obj_save_dfds = _(objdata).map(function(obj,uri) {\n\t\t\t\t\t\t// top level keys - corresponding to box level properties\n\t\t\t\t\t\tif (uri[0] === \"@\") { return; } // ignore \"@id\", \"@version\" etc\n\t\t\t\t\t\t// not one of those, so must be a\n\t\t\t\t\t\t// < uri > : { prop1 .. prop2 ... }\n\t\t\t\t\t\tu.assert(uri === this_.id, 'can only deserialise this object ');\n\t\t\t\t\t\treturn this_._deserialise_and_set(obj);\n\t\t\t\t\t});\n\t\t\t\t\tu.when(obj_save_dfds).then(function(){ fd.resolve(this_); }).fail(fd.reject);\n\t\t\t\t});\n\t\t\t\treturn fd.promise();\n\t\t\t},\n\t\t\tsync: function(method, model, options){\n\t\t\t\tswitch(method){\n\t\t\t\tcase \"create\": return u.assert(false, \"create is never used for Objs\");\n\t\t\t\tcase \"read\"  : return model._fetch();\n\t\t\t\tcase \"update\":\n\t\t\t\t\treturn  model.box.update([model.id])[0];\n\t\t\t\tcase \"delete\":\n\t\t\t\t\treturn this.box._delete_models([this.id])[0];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\n\t\t// Box =================================================\n\t\t// GraphCollection is the list of Objs in a Graph\n\t\tvar ObjCollection = Backbone.Collection.extend({ model: Obj }),\n\t\t\tFileCollection = Backbone.Collection.extend({ model: File });\n\n\t\t// new client: fetch is always lazy, only gets ids, and\n\t\t// lazily get objects as you go\n\t\tvar Box = Backbone.Model.extend({\n\t\t\tidAttribute:\"@id\",\n\t\t\tdefault_options: { use_websockets:true, ws_auto_reconnect:false\t},\n\t\t\tinitialize:function(attributes, options) {\n\t\t\t\tvar this_ = this;\n\t\t\t\tu.assert(options.store, \"no store provided\");\n\t\t\t\tthis.store = options.store;\n\t\t\t\tthis.set({objcache: new ObjCollection(), objlist: [], files : new FileCollection() });\n\t\t\t\tthis.options = _(this.default_options).chain().clone().extend(options || {}).value();\n\t\t\t\tthis.set_up_websocket();\n\t\t\t\tthis._update_queue = {};\n\t\t\t\tthis._delete_queue = {};\n\t\t\t\tthis._fetching_queue = {};\n\t\t\t\tthis.on('update-from-master', function() {\n\t\t\t\t\t// u.log(\"UPDATE FROM MASTER >> flushing \");\n\t\t\t\t\tthis_._flush_update_queue();\n\t\t\t\t\tthis_._flush_delete_queue();\n\t\t\t\t});\n\t\t\t},\n\t\t\t/// <string> fid file id\n\t\t\t/// Tries to get a file with given id. If it doesn't exist, a file with that name is created.\n\t\t\t/// @return <File> the file\n\t\t\tget_or_create_file:function(fid) {\n\t\t\t\tvar files = this.get('files');\n\t\t\t\tif (files.get(fid) === undefined) {\n\t\t\t\t\tfiles.add(new File({\"@id\": fid}, { box: this }));\n\t\t\t\t}\n\t\t\t\treturn files.get(fid);\n\t\t\t},\n\t\t\tset_up_websocket:function() {\n\t\t\t\tvar this_ = this, server_host = this.store.get('server_host');\n\t\t\t\tif (! this.get_use_websockets() ) { return; }\n\t\t\t\tthis.on('new-token', function(token) {\n\t\t\t\t\tvar ws = this_._ws;\n\t\t\t\t\tif (ws) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tws.close();\n\t\t\t\t\t\t\tdelete this_._ws;\n\t\t\t\t\t\t} catch(e) { u.error(); }\n\t\t\t\t\t}\n\t\t\t\t\tvar protocol = (document.location.protocol === 'https:') ? 'wss:/' : 'ws:/';\n\t\t\t\t\tvar ws_url = [protocol,server_host,'ws'].join('/');\n\t\t\t\t\tws = new WebSocket(ws_url);\n\t\t\t\t\tws.onmessage = function(evt) {\n\t\t\t\t\t\tu.debug('websocket :: incoming a message ', evt.data.toString().substring(0,190));\n\t\t\t\t\t\tvar pdata = JSON.parse(evt.data);\n\t\t\t\t\t\tif (pdata.action === 'diff') {\n\t\t\t\t\t\t\tthis_._diff_update(pdata.data)\n\t\t\t\t\t\t\t\t.then(function() {\n\t\t\t\t\t\t\t\t\tthis_.trigger('update-from-master', this_._get_version());\n\t\t\t\t\t\t\t\t}).fail(function(err) {\n\t\t\t\t\t\t\t\t\tu.error(err); /*  u.log('done diffing '); */\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tws.onopen = function() {\n\t\t\t\t\t\tvar data = WS_MESSAGES_SEND.auth(this_.get('token'));\n\t\t\t\t\t\tws.send(data);\n\t\t\t\t\t\tdata = WS_MESSAGES_SEND.diff();\n\t\t\t\t\t\tws.send(data);\n\t\t\t\t\t\tthis_._ws = ws;\n\t\t\t\t\t\tthis_.trigger('ws-connect');\n\t\t\t\t\t};\n\t\t\t\t\tws.onclose = function(evt) {\n\t\t\t\t\t\t// what do we do now?!\n\t\t\t\t\t\tu.error('websocket closed -- ');\n\t\t\t\t\t\t// TODO\n\t\t\t\t\t\tvar interval;\n\t\t\t\t\t\tinterval = setInterval(function() {\n\t\t\t\t\t\t\tthis_.store.reconnect().then(function() {\n\t\t\t\t\t\t\t\tthis_.get_token().then(function() {\n\t\t\t\t\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},1000);\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t},\n\t\t\tget_use_websockets:function() { return this.options.use_websockets; },\n\t\t\tget_cache_size:function(i) { return this._objcache().length; },\n\t\t\tget_obj_ids:function() { return this._objlist().slice(); },\n\t\t\t_objcache:function() { return this.attributes.objcache; },\n\t\t\t_objlist:function() { return this.attributes.objlist !== undefined ? this.attributes.objlist : []; },\n\t\t\t_set_objlist:function(ol) { return this.set({objlist:ol.slice()}); },\n\t\t\t_get_cached_token:function() { return this.get(\"token\"); },\n\t\t\t_set_token:function(token) { this.set(\"token\", token);\t},\n\t\t\t_set_version:function(v) { this.set(\"version\", v);\t},\n\t\t\t_get_version:function(v) { return this.get(\"version\"); },\n\t\t\tget_token:function() {\n\t\t\t\t// utils.debug('>> get_token ', ' id: ',this.id, ' cid: ',this.cid);\n\t\t\t\t// try { throw new Error(''); } catch(e) { console.error(e); }\n\t\t\t\tvar this_ = this, d = u.deferred();\n\t\t\t\tthis._ajax('POST', 'auth/get_token', { app: this.store.get('app') })\n\t\t\t\t\t.then(function(data) {\n\t\t\t\t\t\tconsole.log('setting token ', data.token);\n\t\t\t\t\t\tthis_._set_token( data.token );\n\t\t\t\t\t\tthis_.trigger('new-token', data.token);\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tget_id:function() { return this.id || this.cid;\t},\n\t\t\t_ajax:function(method, path, data) {\n\t\t\t\tdata = _(_(data||{}).clone()).extend({box: this.id || this.cid, token:this.get('token')});\n\t\t\t\treturn this.store._ajax(method, path, data);\n\t\t\t},\n\t\t\tput_file:function(id,filedata,contenttype) {\n\t\t\t\t// creates a File object and hands it back in the resolve\n\t\t\t\tcontenttype = contenttype || filedata.type;\n\t\t\t\tvar d = u.deferred(), this_ = this, newFile = this.get_or_create_file(id);\n\t\t\t\tnewFile.set({\"content-type\": contenttype});\n\t\t\t\tthis._do_put_file(id,filedata,contenttype).then(function(){\n\t\t\t\t\tu.debug('image put success ');\n\t\t\t\t\td.resolve(newFile);\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tif (err.status === 409) {\n\t\t\t\t\t\tvar cb = function() {\n\t\t\t\t\t\t\tthis_.off('update-from-master', cb, newFile);\n\t\t\t\t\t\t\tthis_._put_file(id, filedata, contenttype).then(d.resolve).fail(d.reject);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis_.on('update-from-master', cb, newFile);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu.error('error putting, dammit ', err);\n\t\t\t\t\t\td.reject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_do_put_file:function(id,file,contenttype) {\n\t\t\t\t// now uses relative url scheme '//blah:port/path';\n\t\t\t\t// all files must be PUT into boxname/files\n\t\t\t\t// here the parameters are get encoded\n\t\t\t\t// // 'http://' + this.store.get('server_host') + \"/\" +  boxid + \"/\" + 'files',\n\t\t\t\tvar boxid = this.id || this.cid,\n\t\t\t\tbase_url = ['/', this.store.get('server_host'), boxid, 'files'].join('/'),\n\t\t\t\toptions = { app: this.store.get('app'), id: id, token:this.get('token'),  box: boxid, version: this._get_version() },\n\t\t\t\toption_params = $.param(options),\n\t\t\t\turl = base_url+\"?\"+option_params,\n\t\t\t\td = u.deferred();\n\t\t\t\tconsole.log(\"PUTTING FILE \", url);\n\t\t\t\tvar ajax_args  = _(_(this.store.ajax_defaults).clone()).extend(\n\t\t\t\t\t{ url: url, method : 'PUT', crossDomain:false, data:file, contentType: contenttype, processData:false }\n\t\t\t\t);\n\t\t\t\treturn $.ajax( ajax_args );\n\t\t\t},\n\t\t\tquery: function(q){\n\t\t\t\t// @TODO ::::::::::::::::::::::::::\n\t\t\t\tu.NotImplementedYet();\n\t\t\t\t// var d = u.deferred();\n\t\t\t\t// this._ajax(this, \"/query\", \"GET\", {\"q\": JSON.stringify(q)})\n\t\t\t\t// \t.then(function(data){\n\t\t\t\t// \t\tconsole.debug(\"query results:\",data);\n\t\t\t\t// \t}).fail(function(data) {\n\t\t\t\t// \t\tconsole.debug(\"fail query\");\n\t\t\t\t// \t});\n\t\t\t\t// return d.promise();\n\t\t\t},\n\t\t\t_diff_update:function(response) {\n\t\t\t\tvar d = u.deferred(), this_ = this, latest_version = response['@to_version'],\n\t\t\t\tadded_ids  = _(response.data.added).keys(),\n\t\t\t\tchanged_ids = _(response.data.changed).keys(),\n\t\t\t\tdeleted_ids = _(response.data.deleted).keys(),\n\t\t\t\tchanged_objs = response.data.changed;\n\n\t\t\t\tu.assert(latest_version !== undefined, 'latest version not provided');\n\t\t\t\tu.assert(added_ids !== undefined, 'added_ids not provided');\n\t\t\t\tu.assert(changed_ids !== undefined, 'changed not provided');\n\t\t\t\tu.assert(deleted_ids !== undefined, 'deleted _ids not provided');\n\n\t\t\t\tif (latest_version <= this_._get_version()) {\n\t\t\t\t\tu.debug('asked to diff update, but already up to date, so just relax!', latest_version, this_._get_version());\n\t\t\t\t\treturn d.resolve();\n\t\t\t\t}\n\t\t\t\tu.debug('setting latest version >> ', latest_version, added_ids, changed_ids, deleted_ids);\n\t\t\t\tthis_._set_version(latest_version);\n\t\t\t\tthis_._update_object_list(undefined, added_ids, deleted_ids);\n\t\t\t\tvar change_dfds = _(changed_objs).map(function(obj, uri) {\n\t\t\t\t\tu.debug(' checking to see if in --- ', uri, this_._objcache().get(uri));\n\t\t\t\t\tu.debug('obj >> ', obj);\n\t\t\t\t\tvar cached_obj = this_._objcache().get(uri), cdfd = u.deferred();\n\t\t\t\t\tif (cached_obj) {\n\t\t\t\t\t\t// { prop : [ {sval1 - @type:\"\"}, {sval2 - @type} ... ]\n\t\t\t\t\t\tvar changed_properties = [];\n\t\t\t\t\t\t// console.log(\"obj deleted \", obj.deleted);\n\t\t\t\t\t\tvar deleted_propval_dfds = _(obj.deleted).map(function(vs, k) {\n\t\t\t\t\t\t\tchanged_properties = _(changed_properties).union([k]);\n\t\t\t\t\t\t\tvar dd = u.deferred();\n\t\t\t\t\t\t\tu.when(vs.map(function(v) {\treturn deserialize_value(v, this_);\t})).then(function(values) {\n\t\t\t\t\t\t\t\tvar new_vals = _(cached_obj.get(k) || []).difference(values);\n\t\t\t\t\t\t\t\t// console.log(\"DESERIALISED deleted values \", values, \" - \", \" new_vals \", new_vals);\n\t\t\t\t\t\t\t\t// window._values = values; window._newvals = new_vals;\n\t\t\t\t\t\t\t\tcached_obj.set(k,new_vals);\n\t\t\t\t\t\t\t\t// semantics - if a property has no value then we delete it\n\t\t\t\t\t\t\t\tif (new_vals.length === 0) { cached_obj.unset(k); }\n\t\t\t\t\t\t\t\tdd.resolve();\n\t\t\t\t\t\t\t}).fail(dd.reject);\n\t\t\t\t\t\t\treturn dd.promise();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tvar added_propval_dfds = _(obj.added).map(function(vs, k) {\n\t\t\t\t\t\t\tchanged_properties = _(changed_properties).union([k]);\n\t\t\t\t\t\t\tvar dd = u.deferred();\n\t\t\t\t\t\t\tu.when(vs.map(function(v) {\treturn deserialize_value(v, this_);\t})).then(function(values) {\n\t\t\t\t\t\t\t\tvar new_vals = (cached_obj.get(k) || []).concat(values);\n\t\t\t\t\t\t\t\tcached_obj.set(k,new_vals);\n\t\t\t\t\t\t\t\tdd.resolve();\n\t\t\t\t\t\t\t}).fail(dd.reject);\n\t\t\t\t\t\t\treturn dd.promise();\n\t\t\t\t\t\t});\n                        var replaced_propval_dfs = _(obj.replaced).map(function(vs, k) {\n                            console.debug(\"Processing replaced property\");\n                            changed_properties = _(changed_properties).union([k]);\n                            var dd = u.deferred();\n                            u.when(vs.map(function(v) { return deserialize_value(v, this_); })).then(function(values) {\n                                var new_vals = values; // this is the difference from added - just replace (by DS)\n                                cached_obj.set(k,new_vals);\n                                dd.resolve();\n                            }).fail(dd.reject);\n                            return dd.promise();\n                        });\n                        u.when(added_propval_dfds.concat(deleted_propval_dfds).concat(replaced_propval_dfs)).then(function() {\n\t\t\t\t\t\t\t// u.debug(\"triggering changed properties \", changed_properties);\n\t\t\t\t\t\t\tchanged_properties.map(function(k) {\n\t\t\t\t\t\t\t\tcached_obj.trigger('change:'+k, (cached_obj.get(k) || []).slice());\n\t\t\t\t\t\t\t\tu.debug(\"trigger! change:\"+k);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcdfd.resolve(cached_obj);\n\t\t\t\t\t\t}).fail(cdfd.reject);\n\t\t\t\t\t\treturn cdfd.promise();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tu.when(change_dfds).then(d.resolve).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_create_model_for_id: function(obj_id){\n\t\t\t\tvar model = new Obj({\"@id\":obj_id}, {box:this});\n\t\t\t\tthis._objcache().add(model);\n\t\t\t\treturn model;\n\t\t\t},\n\t\t\tget_obj:function(objid) {\n\t\t\t\t// get_obj always returns a promise\n\t\t\t\tu.assert(typeof objid === 'string' || typeof objid === 'number', \"objid has to be a number or string\");\n\t\t\t\tvar d = u.deferred(),\n\t\t\t\tcachemodel = this._objcache().get(objid),\n\t\t\t\tfetching_dfd = this._fetching_queue[objid],\n\t\t\t\thasmodel = cachemodel && fetching_dfd === undefined,\n\t\t\t\tthis_ = this;\n\n\t\t\t\tif (hasmodel) {\n\t\t\t\t\tconsole.log('returning cached ', objid);\n\t\t\t\t\td.resolve(cachemodel); return d.promise();\n\t\t\t\t}\n\n\t\t\t\t// check to see if already fetching, then we can tag along\n\t\t\t\tif (fetching_dfd) {\n\t\t\t\t\t// to fix a deadlock condition -\n\t\t\t\t\t// if we fetch someone who loops back to us\n\t\t\t\t\t// then we will never resolve with this code:\n\t\t\t\t\t//\n\t\t\t\t\t// fetching_dfd.then(d.resolve).fail(d.reject);\n\t\t\t\t\t// return d.promise();\n\t\t\t\t\t// --\n\t\t\t\t\t// therefore a fix:\n\t\t\t\t\td.resolve(cachemodel);\n\t\t\t\t\treturn d.promise();\n\t\t\t\t}\n\n\t\t\t\t// if not already fetching then we have to fetch\n\t\t\t\tthis._fetching_queue[objid] = d;\n\t\t\t\tvar model = this_._create_model_for_id(objid);\n\t\t\t\t// if the serve knows about it, then we fetch its definition\n\t\t\t\tconsole.log('objlist ', this._objlist());\n\n\t\t\t\t// old code ::\n\t\t\t\t// if (this._objlist().indexOf(objid) >= 0) {\n\t\t\t\t// \tconsole.log('object exists, going to fetch it ');\n\t\t\t\t// \tmodel.fetch().then(function() {\n\t\t\t\t// \t\td.resolve(model);\n\t\t\t\t// \t\tdelete this_._fetching_queue[objid];\n\t\t\t\t// \t}).fail(d.reject);\n\t\t\t\t// } else {\n\t\t\t\t// \tconsole.log('object doesnt exist, not going to fetch it ');\n\t\t\t\t// \t// otherwise it must be new!\n\t\t\t\t// \tmodel.is_new = true;\n\t\t\t\t// \td.resolve(model);\n\t\t\t\t// }\n\n\t\t\t\tconsole.log('trying to fetch ', objid);\n\t\t\t\tmodel.fetch().then(function() {\n\t\t\t\t\td.resolve(model);\n\t\t\t\t\tdelete this_._fetching_queue[objid];\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tconsole.log('failed.. declaring it new ', objid);\n\t\t\t\t\t// TODO check if 404'd\n\t\t\t\t\tconsole.log('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA err - didnt exist ? ', err);\n\t\t\t\t\tmodel.is_new = true;\n\t\t\t\t\td.resolve(model);\n\t\t\t\t\tdelete this_._fetching_queue[objid];\n\t\t\t\t});\n\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// ----------------------------------------------------\n\t\t\t_update_object_list:function(updated_obj_ids, added, deleted) {\n\t\t\t\tvar current, olds = this._objlist().slice(), this_ = this, news, died;\n\t\t\t\t// u.debug('_update_object_list +', added ? added.length : ' ', '-', deleted ? deleted.length : ' ');\n\t\t\t\t// u.debug('_update_object_list +', added || ' ', deleted || ' ');\n\t\t\t\tif (updated_obj_ids === undefined ) {\n\t\t\t\t\tcurrent = _(olds).chain().union(added).difference(deleted).value();\n\t\t\t\t\tnews = (added || []).slice(); died = (deleted || []).slice();\n\t\t\t\t} else {\n\t\t\t\t\tcurrent = updated_obj_ids.slice();\n\t\t\t\t\tnews = _(current).difference(olds);\n\t\t\t\t\tdied = _(olds).difference(current);\n\t\t\t\t}\n\t\t\t\t// u.debug('old objlist had ', olds.length, ' new has ', current.length, 'news > ', news);\n\t\t\t\tthis._set_objlist(current);\n\t\t\t\tnews.map(function(aid) {\tthis_.trigger('obj-add', aid);\t});\n\t\t\t\tdied.map(function(rid) {\n\t\t\t\t\tthis_.trigger('obj-remove', rid);\n\t\t\t\t\tthis_._objcache().remove(rid);\n\t\t\t\t});\n\t\t\t},\n\t\t\t_is_fetched: function() {\n\t\t\t\treturn this.id !== undefined;\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\t// all fetch really does is retrieve ids!\n\t\t\t\t// new client :: this now _only_ fetches object ids\n\t\t\t\t// return a list of models (each of type Object) to populate a GraphCollection\n\t\t\t\tvar d = u.deferred(), fd = u.deferred(), this_ = this;\n\t\t\t\tif (this._is_fetched()) {\n\t\t\t\t\t// Nope - don't do anything -- we just wait for websockets to update us.\n\t\t\t\t\tfd.resolve();\n\t\t\t\t} else {\n\t\t\t\t\t// otherwise we aren't fetched, so we just do it\n\t\t\t\t\tvar box = this.get_id();\n\t\t\t\t\tthis._ajax(\"GET\",[box,'get_object_ids'].join('/')).then(\n\t\t\t\t\t\tfunction(response){\n\t\t\t\t\t\t\tu.assert(response['@version'] !== undefined, 'no version provided');\n\t\t\t\t\t\t\tthis_.id = this_.get_id(); // sets so that _is_fetched later returns true\n\t\t\t\t\t\t\tthis_._set_version(response['@version']);\n\t\t\t\t\t\t\tthis_._update_object_list(response.ids);\n\t\t\t\t\t\t\tfd.resolve(this_);\n\t\t\t\t\t\t}).fail(fd.reject);\n\t\t\t\t}\n\t\t\t\tfd.then(function() {\n\t\t\t\t\tthis_.trigger('update-from-master', this_._get_version());\n\t\t\t\t\td.resolve(this_);\n\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// -----------------------------------------------\n\t\t\t_check_token_and_fetch : function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (this.get('token') === undefined) {\n\t\t\t\t\tvar d = u.deferred();\n\t\t\t\t\tthis.get_token()\n\t\t\t\t\t\t.then(function() { this_._fetch().then(d.resolve).fail(d.reject);\t})\n\t\t\t\t\t\t.fail(d.reject);\n\t\t\t\t\treturn d.promise();\n\t\t\t\t}\n\t\t\t\treturn this_._fetch();\n\t\t\t},\n\t\t\t_create_box:function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis.store._ajax('POST', 'admin/create_box', { name: this.get_id() } )\n\t\t\t\t\t.then(function() {\n\t\t\t\t\t\tthis_.fetch().then(function() { d.resolve(); }).fail(function(err) { d.reject(err); });\n\t\t\t\t\t}).fail(function(err) { d.reject(err); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tdelete_box:function(boxid) {\n\t\t\t\treturn this.store._ajax('POST','admin/delete_box', { name: boxid } );\n\t\t\t},\n\t\t\t// =============== :: UPDATE ::  ======================\n\t\t\tWHOLE_BOX: \"__UPDATE__WHOLE__BOX__\",\n\t\t\t_add_to_update_queue:function(ids_to_update) {\n\t\t\t\tvar this_ = this, uq = this._update_queue;\n\t\t\t\t// returns the deferreds\n\t\t\t\tids_to_update = ids_to_update === undefined ? [ this.WHOLE_BOX ] : ids_to_update;\n\t\t\t\treturn ids_to_update.map(function(id) {\n\t\t\t\t\tuq[id] = uq[id] || u.deferred();\n\t\t\t\t\treturn uq[id];\n\t\t\t\t});\n\t\t\t},\n\t\t\t_requeue_update:function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (!this._update_timeout) {\n\t\t\t\t\tthis._update_timeout = setTimeout(function() {\n\t\t\t\t\t\tdelete this_._update_timeout;\n\t\t\t\t\t\tthis_._flush_update_queue();\n\t\t\t\t\t}, 300);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_flush_update_queue:function() {\n\t\t\t\tvar this_ = this, uq = this._update_queue, ids_to_update = _(uq).keys();\n\t\t\t\tif (ids_to_update.length === 0) { return ; }\n\t\t\t\tif (this._updating || this._deleting) {\n\t\t\t\t\treturn this._requeue_update();\n\t\t\t\t}\n\n\t\t\t\tthis._update_queue = {};\n\t\t\t\tvar update_arguments = ids_to_update.indexOf(this.WHOLE_BOX) >= 0 ? undefined : ids_to_update;\n\t\t\t\tthis_._updating = true;\n\n\t\t\t\tthis_._do_update(update_arguments).then(function() {\n\t\t\t\t\tdelete this_._updating;\n\t\t\t\t\t// TODO: resolve all of our deferreds now and delete them\n\t\t\t\t\tids_to_update.map(function(id) { uq[id].resolve();\t\t});\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tdelete this_._updating;\n\t\t\t\t\tif (err.status === 409) {\n\t\t\t\t\t\t// add the defferds back in\n\t\t\t\t\t\t_(uq).map(function(d,id) {\n\t\t\t\t\t\t\tif (this_._update_queue[id]) {\n\t\t\t\t\t\t\t\t// someone's already added one back in! let's chain them\n\t\t\t\t\t\t\t\tu.debug('HEYYYYYYYYYYYYYYYYYYYYYY already added in - lets go');\n\t\t\t\t\t\t\t\tthis_._update_queue[id].then(uq[id].resolve).fail(uq[id].reject);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tu.debug('sneaking him back in - lets go');\n\t\t\t\t\t\t\t\tthis_._update_queue[id] = uq[id];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn this_._requeue_update();\n\t\t\t\t\t}\n\t\t\t\t\t// something bad happened, we'd better reject on those deferreds\n\t\t\t\t\tu.error('UPDATE error ', err);\n\t\t\t\t\tids_to_update.map(function(id) { uq[id].reject(err);});\n\t\t\t\t});\n\t\t\t},\n\t\t\t_do_update:function(ids) {\n\t\t\t\t// this actua\n\t\t\t\tconsole.log('box update >> ');\n\t\t\t\tvar d = u.deferred(), version = this.get('version') || 0, this_ = this,\n\t\t\t\tobjs = this._objcache().filter(function(x) { return ids === undefined || ids.indexOf(x.id) >= 0; }),\n\t\t\t\tobj_ids = objs.map(function(x) { return x.id; }),\n\t\t\t\tsobjs = objs.map(function(obj){ return serialize_obj(obj); });\n\t\t\t\tthis._ajax(\"PUT\",  this.get_id() + \"/update\", { version: escape(version), data : JSON.stringify(sobjs)  })\n\t\t\t\t\t.then(function(response) {\n\t\t\t\t\t\tthis_._set_version(response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._update_object_list(undefined, obj_ids, []); // update object list\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tupdate:function(original_ids) {\n\t\t\t\t// this is called by Backbone.save(),\n\t\t\t\tvar dfds = this._add_to_update_queue(original_ids);\n\t\t\t\tthis._flush_update_queue();\n\t\t\t\treturn dfds;\n\t\t\t},\n\t\t\t// =============== :: DELETE ::  ======================\n\t\t\t_add_to_delete_queue:function(ids) {\n\t\t\t\tvar this_ = this, dq = this._delete_queue;\n\t\t\t\treturn ids.map(function(id) {\n\t\t\t\t\tdq[id] = dq[id] || u.deferred();\n\t\t\t\t\treturn dq[id];\n\t\t\t\t});\n\t\t\t},\n\t\t\t_delete_models:function(ids) {\n\t\t\t\tvar dfds =  this._add_to_delete_queue(ids);\n\t\t\t\tthis._flush_delete_queue();\n\t\t\t\treturn dfds;\n\t\t\t},\n\t\t\t_requeue_delete:function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (!this._delete_timeout) {\n\t\t\t\t\tthis._delete_timeout = setTimeout(function() {\n\t\t\t\t\t\tdelete this_._delete_timeout;\n\t\t\t\t\t\tthis_._flush_delete_queue();\n\t\t\t\t\t}, 300);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_flush_delete_queue:function() {\n\t\t\t\tvar this_ = this, dq = this._delete_queue, delete_ids = _(dq).keys();\n\t\t\t\tif (delete_ids.length === 0) { return ; }\n\t\t\t\tif (this._deleting || this._updating) { return this._requeue_delete();  }\n\t\t\t\tthis_._deleting = true;\n\t\t\t\tthis_._do_delete(delete_ids).then(function() {\n\t\t\t\t\tdelete this_._deleting;\n\t\t\t\t\tdelete_ids.map(function(id) {\n\t\t\t\t\t\tdq[id].resolve(); delete dq[id];\n\t\t\t\t\t});\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tdelete this_._deleting;\n\t\t\t\t\tif (err.status === 409) { this_._requeue_delete();\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t_do_delete:function(m_ids) {\n\t\t\t\tvar version = this.get('version') || 0, d = u.deferred(), this_ = this;\n\t\t\t\tthis._ajax('DELETE', this.id+'/', { version:version, data: JSON.stringify(m_ids) })\n\t\t\t\t\t.then(function(response) {\n\t\t\t\t\t\tu.debug('DELETE response NEW version > ', response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._set_version(response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._update_object_list(undefined, [], m_ids); // update object list\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// =============== :: SYNC ::  ======================\n\t\t\tsync: function(method, box, options){\n\t\t\t\tswitch(method)\n\t\t\t\t{\n\t\t\t\tcase \"create\": return box._create_box();\n\t\t\t\tcase \"read\": return box._check_token_and_fetch();\n\t\t\t\tcase \"update\": return box.update()[0];  // save whole box?\n\t\t\t\tcase \"delete\": return this.delete_box(this.get_id()) // hook up to destroy\n\t\t\t\t}\n\t\t\t},\n\t\t\ttoString: function() { return 'box:' + this.get_id(); }\n\t\t});\n\n\t\tvar BoxCollection = Backbone.Collection.extend({ model: Box });\n\n\t\tvar Store =  Backbone.Model.extend({\n\t\t\tdefaults: {\n\t\t\t\tserver_host:DEFAULT_HOST,\n\t\t\t\tapp:\"--default-app-id--\"\n\t\t\t},\n\t\t\tajax_defaults : {\n\t\t\t\tjsonp: false, contentType: \"application/json\",\n\t\t\t\txhrFields: { withCredentials: true }\n\t\t\t},\n\n\t\t\t/// @opt <{}> attributes\n\t\t\t/// @opt <{}> options\n\t\t\t/// @constructor\n\t\t\tinitialize: function(attributes, options){\n\t\t\t\tthis.set({boxes : new BoxCollection([], {store: this})});\n\t\t\t},\n\n\t\t\t/// Check that the\n\t\t\tis_same_domain:function() {\n\t\t\t\treturn this.get('server_host').indexOf(document.location.host) >= 0 && (document.location.port === (this.get('server_port') || ''));\n\t\t\t},\n\t\t\tboxes:function() { return this.attributes.boxes;\t},\n\t\t\tget_box: function(boxid) {\n\t\t\t\tvar b = this.boxes().get(boxid) || this._create(boxid);\n\t\t\t\tif (!b._get_cached_token()) {\n\t\t\t\t\treturn b.get_token().pipe(function() {\n\t\t\t\t\t\treturn b.fetch();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn u.dresolve(b);\n\t\t\t},\n\n\n\t\t\t/// @arg <string|number> boxid: the id for the box\n\t\t\t///\n\t\t\t/// @then (<Box> the box)\n\t\t\t/// @fail\n\t\t\t///   (<{ code: 409 }> response) box already exists\n\t\t\t///   (<{ code: -1, error: error obj }> response) other error\n\t\t\t///\n\t\t\t/// Attempts to create a box with the given ID\n\t\t\tcreate_box: function (boxid) {\n\t\t\t\tu.debug('create box ', boxid);\n\t\t\t\tif (this.boxes().get(boxid)) {\n\t\t\t\t\treturn u.dreject({ code: 409, message: 'Box already exists: ' + boxid });\n\t\t\t\t}\n\t\t\t\tvar c = this._create(boxid), this_ = this;\n\t\t\t\tu.debug('creating ', boxid);\n\t\t\t\treturn c.save().pipe(function() { return this_.get_box(boxid); });\n\t\t\t},\n\t\t\tcheck_login:function() {\n\t\t\t\t// checks whether you can connect to the server and who is logged in.\n\t\t\t\t// returns a deferred that gets passed an argument\n\t\t\t\t// { code:200 (server is okay),  is_authenticated:true/false,  user:<username>  }\n\t\t\t\treturn this._ajax('GET', 'auth/whoami');\n\t\t\t},\n\t\t\t// todo: change to _\n\t\t\tget_info:function() { return this._ajax('GET', 'admin/info'); },\n\t\t\tlogin : function(username,password) {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tthis.set({username:username,password:password});\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis._ajax('POST', 'auth/login', { username: username, password: password })\n\t\t\t\t\t.then(function(l) { this_.trigger('login', username); d.resolve(l); })\n\t\t\t\t\t.fail(function(l) { d.reject(l); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\treconnect:function() {\n\t\t\t\treturn this.login(this.get('username'),this.get('password'));\n\t\t\t},\n\t\t\tlogout : function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis._ajax('POST', 'auth/logout')\n\t\t\t\t\t.then(function(l) { this_.trigger('logout'); d.resolve(l); })\n\t\t\t\t\t.fail(function(l) { d.reject(l); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_create:function(boxid) {\n\t\t\t\tvar b = new Box({}, {store: this});\n\t\t\t\tb.cid = boxid;\n\t\t\t\tthis.boxes().add(b);\n\t\t\t\treturn b;\n\t\t\t},\n\t\t\tget_box_list:function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tthis._ajax('GET','admin/list_boxes')\n\t\t\t\t\t.success(function(data) {d.resolve(data.list);})\n\t\t\t\t\t.fail(function(err) { d.reject(err); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\tthrow new Error('dont fetch a store - any more!');\n\t\t\t\t//\n\t\t\t\t// fetches list of boxes\n\t\t\t\t/* - do not do this\n\t\t\t\tvar this_ = this, d = u.deferred();\n\t\t\t\tthis._ajax('GET','admin/list_boxes')\n\t\t\t\t\t.success(function(data) {\n\t\t\t\t\t\tu.when(data.list.map(function(boxid) { return this_.get_box(boxid); })).then(function(boxes) {\n\t\t\t\t\t\t\t// console.log(\"boxes !! \", boxes);\n\t\t\t\t\t\t\tthis_.boxes().reset(boxes);\n\t\t\t\t\t\t\td.resolve(boxes);\n\t\t\t\t\t\t});\n\t\t\t\t\t}).error(function(e) { d.reject(e); });\n\t\t\t\treturn d.promise();\n\t\t\t\t*/\n\t\t\t},\n\t\t\t_ajax:function(method, path, data) {\n\t\t\t\t// now uses relative url scheme '//blah:port/path';\n\t\t\t\tvar url = ['/', this.get('server_host'), path].join('/');\n\t\t\t\tvar default_data = { app: this.get('app') };\n\t\t\t\tvar options = _(_(this.ajax_defaults).clone()).extend(\n\t\t\t\t\t{ url: url, method : method, crossDomain: !this.is_same_domain(), data: _(default_data).extend(data) }\n\t\t\t\t);\n\t\t\t\treturn $.ajax( options ); // returns a deferred\n\t\t\t},\n\t\t\tsync: function(method, model, options){\n\t\t\t\tswitch(method){\n\t\t\t\tcase \"create\": return u.error('store.create() : cannot create a store'); // TODO\n\t\t\t\tcase \"read\"  : return model._fetch();\n\t\t\t\tcase \"update\": return u.error('store.update() : cannot update a store'); // TODO\n\t\t\t\tcase \"delete\": return u.error('store.delete() : cannot delete a store'); // tODO\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tvar exports = {\n\t\t\tsafe_apply:utils.safe_apply,\n\t\t\tu : utils,\n\t\t\tStore:Store,\n\t\t\tObj: Obj,\n\t\t\tFile:File,\n\t\t\tBox: Box,\n\t\t\tstore: new Store(),\n\t\t\tloaded : utils.deferred()\n\t\t};\n\t\twindow.u = utils;\n\n\t\t// do not fetch boxes\n\t\texports.loaded.resolve(exports);\n\t\treturn exports;\n\n\t}).factory('backbone', function(client, utils) {\n\t\t// this manages backbone-angular mystification\n\t\tvar deregfns = [];\n\t\tvar deep_clone_obj = function(o) {\n\t\t\treturn utils.dict(_(o).map(function(v,k) { return [k, v.concat()]; }));\n\t\t};\n\t\tvar scope_bind = function($scope, name, model) {\n\t\t\tutils.assert(model instanceof Backbone.Model, \"tried to bind something that was not a model\");\n\t\t\twindow._m = model;\n\t\t\tvar clone = deep_clone_obj(_(model.attributes));\n\t\t\tutils.safe_apply($scope, function() { $scope[name] = clone;\t});\n\t\t\tvar findchanges = function(old,new_,fn) {\n\t\t\t\tvar changes = [];\n\t\t\t\t_(old).map(function(v,k) {\n\t\t\t\t\tif (v.length !== new_[k].length || _(v).filter(function(vi, i) { return vi != new_[k][i]; }).length) {\n\t\t\t\t\t\tutils.log('pushing changes ', k, new_[k]);\n\t\t\t\t\t\tchanges.push(k);\n\t\t\t\t\t\tif (fn) { fn(k,new_[k].concat()); }\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn changes;\n\t\t\t};\n\t\t\t// angular -> backbone\n\t\t\tvar dereg = $scope.$watch(name, function() {\n\t\t\t\t// do a quick diff --\n\t\t\t\t// first check to make sure that our brave model is still\n\t\t\t\tif ($scope[name] !== clone) { return true; }\n\t\t\t\tfindchanges(model.attributes, clone, function(k,v) {model.set(k,v); });\n\t\t\t}, true);\n\t\t\tderegfns.push([$scope,name,model,dereg]);\n\t\t\t// backbone -> angular\n\t\t\tmodel.on('change', function(data) {\n\t\t\t\tutils.safe_apply($scope, function() {\n\t\t\t\t\tfindchanges(clone, model.attributes, function(k,v) { clone[k] = v;\t});\n\t\t\t\t});\n\t\t\t},$scope);\n\t\t};\n\t\treturn {\n\t\t\tscope_bind: scope_bind,\n\t\t\tscope_unbind:function($scope,name) {\n\t\t\t\tderegfns.map(function(tuple) {\n\t\t\t\t\tvar scope = tuple[0],name = tuple[1],model = tuple[2],dereg = tuple[3];\n\t\t\t\t\tmodel.off('change', null, scope);\n\t\t\t\t\tdereg();\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t});\n","methods":[{"name":"initialize","args":[{"name":"attrs","moreInfo":false,"last":false},{"name":"options","moreInfo":false,"last":true}],"start":4854,"line":132,"description":"","result":"","hasArgs":true,"cls":"~classes~0"},{"name":"get_id","args":[],"start":4974,"line":136,"description":"","result":"","cls":"~classes~0"},{"name":"get_url","args":[],"start":5016,"line":137,"description":"","result":"","cls":"~classes~0"}],"properties":[],"match":"File =  Backbone.Model.extend(","name":"File","start":4759,"extend":"~classes~0","end":5739},{"data":"///\n/// @title INDX\n/// blah\n\n/*global $,_,document,window,console,escape,Backbone,exports,WebSocket */\n/*jslint vars:true, todo:true */\n/*\n\n  indx.js is the JS Client SDK for WebBox WebBox\n  which builds upon Backbone's Model architecture.\n\n  CURRENT TODOs:\n  \t- update only supports updating the entire box\n    - Box.fetch() retrieves _entire box contents_\n\t  ... which is a really bad idea.\n\n  @prerequisites:\n\tjquery 1.8.0 or higher\n\tbackbone.js 0.9.2 or higher\n\tunderscore.js 1.4.2 or higher\n\n  This file is part of INDX\n  Copyright 2012 Max Van Kleek, Daniel Alexander Smith\n  Copyright 2012 University of Southampton\n\n  WebBox is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  WebBox is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with Indx.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n\nangular\n\t.module('indx', ['ui'])\n\t.factory('client',function(utils) {\n\t\tvar u = utils; // to be filled in by dependency\n\t\t// set up our parameters for webbox -\n\t\t// default is that we're loading from an _app_ hosted within\n\t\t// indx.\n\t\tvar DEFAULT_HOST = document.location.host; // which may contain the port\n\t\tvar WS_MESSAGES_SEND = {\n\t\t\tauth: function(token) { return JSON.stringify({action:'auth', token:token}); },\n\t\t\tdiff: function(token) { return JSON.stringify({action:'diff', operation:\"start\"}); }\n\t\t};\n\t\tvar serialize_obj = function(obj) {\n\t\t\tvar uri = obj.id;\n\t\t\tvar out_obj = {};\n\t\t\t$.each(obj.attributes, function(pred, vals){\n\t\t\t\tif (pred[0] === \"_\" || pred[0] === \"@\"){\n\t\t\t\t\t// don't expand @id etc.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar obj_vals = [];\n\t\t\t\tif (!(vals instanceof Array)){\n\t\t\t\t\tvals = [vals];\n\t\t\t\t}\n\t\t\t\t$.each(vals, function(){\n\t\t\t\t\tvar val = this;\n\t\t\t\t\tif (val instanceof File) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.id, \"@type\":\"indx-file\", \"@language\":val.get('content-type')});\n\t\t\t\t\t} else if (val instanceof Obj) {\n\t\t\t\t\t\tobj_vals.push({\"@id\": val.id });\n\t\t\t\t\t} else if (typeof val === \"object\" && (val[\"@value\"] || val[\"@id\"])) {\n\t\t\t\t\t\tobj_vals.push(val); // fully expanded string, e.g. {\"@value\": \"foo\", \"@language\": \"en\" ... }\n\t\t\t\t\t} else if (typeof val === \"string\" || val instanceof String ){\n\t\t\t\t\t\tobj_vals.push({\"@value\": val});\n\t\t\t\t\t} else if (_.isDate(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toISOString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"});\n\t\t\t\t\t} else if (_.isNumber(val) && u.isInteger(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#integer\"});\n\t\t\t\t\t} else if (_.isNumber(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#float\"});\n\t\t\t\t\t} else if (_.isBoolean(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#boolean\"});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu.warn(\"Could not determine type of val \", pred, val);\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString()});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tout_obj[pred] = obj_vals;\n\t\t\t});\n\t\t\tout_obj['@id'] = uri;\n\t\t\treturn out_obj;\n\t\t};\n\n\t\tvar literal_deserializers = {\n\t\t\t'': function(o) { return o['@value']; },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#integer\": function(o) { return parseInt(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#float\": function(o) { return parseFloat(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#double\": function(o) { return parseFloat(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#boolean\": function(o) { return o['@value'].toLowerCase() === 'true'; },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#dateTime\": function(o) { return new Date(Date.parse(o['@value'])); },\n\t\t\t\"indx-file\": function(o,box) {\n\t\t\t\tvar f = box.get_or_create_file(o['@value']);\n\t\t\t\tf.set(\"content-type\", o['@language']);\n\t\t\t\treturn f;\n\t\t\t}\n\t\t};\n\t\tvar deserialize_literal = function(obj, box) {\n\t\t\treturn obj['@value'] !== undefined ? literal_deserializers[ obj['@type'] || '' ](obj, box) : obj;\n\t\t};\n\n\t\tvar deserialize_value = function(s_val, box) {\n\t\t\tvar vd = u.deferred();\n\t\t\t// it's an object, so return that\n\t\t\tif (s_val.hasOwnProperty(\"@id\")) {\n\t\t\t\t// object\n\t\t\t\tbox.get_obj(s_val[\"@id\"]).then(vd.resolve).fail(vd.reject);\n\t\t\t}\n\t\t\telse if (s_val.hasOwnProperty(\"@value\")) {\n\t\t\t\t// literal\n\t\t\t\tvd.resolve(deserialize_literal(s_val, box));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// don't know what it is!\n\t\t\t\tvd.reject('cannot unpack value ', s_val);\n\t\t\t}\n\t\t\treturn vd.promise();\n\t\t};\n\n\t\tvar File =  Backbone.Model.extend({\n\t\t\tidAttribute: \"@id\", // the URI attribute is '@id' in JSON-LD\n\t\t\tinitialize:function(attrs, options) {\n\t\t\t\tu.debug('options >> ', attrs, options );\n\t\t\t\tthis.box = options.box;\n\t\t\t},\n\t\t\tget_id:function() { return this.id;\t},\n\t\t\tget_url:function() {\n\t\t\t\tvar params = {\n\t\t\t\t\tid:this.get_id(),\n\t\t\t\t\tapp:this.box.store.get('app'),\n\t\t\t\t\ttoken:this.box.get('token'),\n\t\t\t\t\tbox:this.box.get_id()\n\t\t\t\t}, url = ['/', this.box.store.get('server_host'), this.box.id, 'files'].join('/') + '?' + $.param(params);\n\t\t\t\t// u.debug(\"IMAGE URL IS \", url, params);\n\t\t\t\treturn url;\n\t\t\t}\n\t\t});\n\n\n\t\t// MAP OF THIS MODUULE :::::::::::::: -----\n\t\t//\n\t\t// An Obj is a single instance, thing in Indx.\n\t\t//\n\t\t// A Box is a model that has an attribute called 'Objs'.\n\t\t// ...  which is a Backbone.Collection of Graph objects.\n\t\t//\n\t\t// A _Store_ represents a single Indx server, which has an\n\t\t//\t attribute called 'boxes' -\n\t\t// ... which is a collection of Box objects\n\t\tvar Obj =  Backbone.Model.extend({\n\t\t\tidAttribute: \"@id\", // the URI attribute is '@id' in JSON-LD\n\t\t\tinitialize:function(attrs, options) {\n\t\t\t\tthis.box = options.box;\n\t\t\t},\n\t\t\t_is_fetched: function() { return this._fetched || false; },\n\t\t\t_set_fetched : function() { this._fetched = true; },\n\t\t\tget_id:function() { return this.id;\t},\n\t\t\t_value_to_array:function(k,v) {\n\t\t\t\tif (k === '@id') { return v; }\n\t\t\t\tif (!_(v).isUndefined() && !_(v).isArray()) {\n\t\t\t\t\treturn [v];\n\t\t\t\t}\n\t\t\t\treturn v;\n\t\t\t},\n\t\t\t_all_values_to_arrays:function(o) {\n\t\t\t\tif (!_(o).isObject()) { utils.error(' not an object', o); return o; }\n\t\t\t\tvar this_ = this;\n\t\t\t\t// ?!?! this isn't doing anything (!!)\n\t\t\t\treturn u.dict(_(o).map(function(v,k) {\n\t\t\t\t\tvar val = this_._value_to_array(k,v);\n\t\t\t\t\tif (u.defined(val)) { return [k,val]; }\n\t\t\t\t\treturn undefined;\n\t\t\t\t}).filter(u.defined));\n\t\t\t},\n\t\t\tset:function(k,v,options) {\n\t\t\t\t// set is tricky because it can be called like\n\t\t\t\t// set('foo',123) or set({foo:123})\n\t\t\t\tif (typeof k === 'string') { v = this._value_to_array(k,v);\t}\n\t\t\t\telse {\tk = this._all_values_to_arrays(k);\t}\n\t\t\t\treturn Backbone.Model.prototype.set.apply(this,[k,v,options]);\n\t\t\t},\n\t\t\tdelete_properties:function(props, silent)  {\n\t\t\t\tvar this_ = this;\n\t\t\t\tprops.map(function(p) { this_.unset(p, silent ? {silent:true} : {}); });\n\t\t\t},\n\t\t\t_deserialise_and_set:function(s_obj, silent) {\n\t\t\t\t// returns a promise\n\t\t\t\tvar this_ = this;\n\t\t\t\tvar dfds = _(s_obj).map(function(vals, key) {\n\t\t\t\t\tvar kd = u.deferred();\n\t\t\t\t\tif (key.indexOf('@') === 0) { return; }\n\t\t\t\t\tvar val_dfds = vals.map(function(val) {\n\t\t\t\t\t\tvar vd = u.deferred();\n\t\t\t\t\t\t// it's an object, so return that\n\t\t\t\t\t\tif (val.hasOwnProperty(\"@id\")) {\n\t\t\t\t\t\t\t// object\n\t\t\t\t\t\t\tthis_.box.get_obj(val[\"@id\"]).then(vd.resolve).fail(vd.reject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (val.hasOwnProperty(\"@value\")) {\n\t\t\t\t\t\t\t// literal\n\t\t\t\t\t\t\tvd.resolve(deserialize_literal(val, this_.box));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// don't know what it is!\n\t\t\t\t\t\t\tvd.reject('cannot unpack value ', val);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn vd.promise();\n\t\t\t\t\t});\n\t\t\t\t\tu.when(val_dfds).then(function(obj_vals) {\n\t\t\t\t\t\t// only update keys that have changed\n\t\t\t\t\t\tvar prev_vals = this_.get(key);\n\t\t\t\t\t\tif ( prev_vals === undefined || obj_vals.length !== prev_vals.length ||\n\t\t\t\t\t\t\t _(obj_vals).difference(prev_vals).length > 0 ||\n\t\t\t\t\t\t\t _(prev_vals).difference(obj_vals).length > 0) {\n\t\t\t\t\t\t\tthis_.set(key, obj_vals, { silent : silent });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkd.resolve();\n\t\t\t\t\t}).fail(kd.reject);\n\t\t\t\t\treturn kd.promise();\n\t\t\t\t}).filter(u.defined);\n\t\t\t\treturn u.when(dfds);\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\tvar this_ = this, fd = u.deferred(), box = this.box.get_id();\n\t\t\t\tthis.box._ajax('GET', box, {'id':this.id}).then(function(response) {\n\t\t\t\t\tthis_._set_fetched(true);\n\t\t\t\t\tvar objdata = response.data;\n\t\t\t\t\tif (objdata['@version'] === undefined) {\n\t\t\t\t\t\t// then the server thinks we've been deleted, so let's just die.\n\t\t\t\t\t\treturn fd.reject(this_.id);\n\t\t\t\t\t\t// old code:\n\t\t\t\t\t\t// according to the server, we're dead.\n\t\t\t\t\t\t// console.log('zombie detected ', this_.id);\n\t\t\t\t\t\t// this_.cid = this_.id;\n\t\t\t\t\t\t// this_.unset({});\n\t\t\t\t\t\t// delete this_.id;\n\t\t\t\t\t\t// fd.resolve();\n\t\t\t\t\t\t// return;\n\t\t\t\t\t}\n\t\t\t\t\t// we are at current known version as far as we know\n\t\t\t\t\tvar obj_save_dfds = _(objdata).map(function(obj,uri) {\n\t\t\t\t\t\t// top level keys - corresponding to box level properties\n\t\t\t\t\t\tif (uri[0] === \"@\") { return; } // ignore \"@id\", \"@version\" etc\n\t\t\t\t\t\t// not one of those, so must be a\n\t\t\t\t\t\t// < uri > : { prop1 .. prop2 ... }\n\t\t\t\t\t\tu.assert(uri === this_.id, 'can only deserialise this object ');\n\t\t\t\t\t\treturn this_._deserialise_and_set(obj);\n\t\t\t\t\t});\n\t\t\t\t\tu.when(obj_save_dfds).then(function(){ fd.resolve(this_); }).fail(fd.reject);\n\t\t\t\t});\n\t\t\t\treturn fd.promise();\n\t\t\t},\n\t\t\tsync: function(method, model, options){\n\t\t\t\tswitch(method){\n\t\t\t\tcase \"create\": return u.assert(false, \"create is never used for Objs\");\n\t\t\t\tcase \"read\"  : return model._fetch();\n\t\t\t\tcase \"update\":\n\t\t\t\t\treturn  model.box.update([model.id])[0];\n\t\t\t\tcase \"delete\":\n\t\t\t\t\treturn this.box._delete_models([this.id])[0];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\n\t\t// Box =================================================\n\t\t// GraphCollection is the list of Objs in a Graph\n\t\tvar ObjCollection = Backbone.Collection.extend({ model: Obj }),\n\t\t\tFileCollection = Backbone.Collection.extend({ model: File });\n\n\t\t// new client: fetch is always lazy, only gets ids, and\n\t\t// lazily get objects as you go\n\t\tvar Box = Backbone.Model.extend({\n\t\t\tidAttribute:\"@id\",\n\t\t\tdefault_options: { use_websockets:true, ws_auto_reconnect:false\t},\n\t\t\tinitialize:function(attributes, options) {\n\t\t\t\tvar this_ = this;\n\t\t\t\tu.assert(options.store, \"no store provided\");\n\t\t\t\tthis.store = options.store;\n\t\t\t\tthis.set({objcache: new ObjCollection(), objlist: [], files : new FileCollection() });\n\t\t\t\tthis.options = _(this.default_options).chain().clone().extend(options || {}).value();\n\t\t\t\tthis.set_up_websocket();\n\t\t\t\tthis._update_queue = {};\n\t\t\t\tthis._delete_queue = {};\n\t\t\t\tthis._fetching_queue = {};\n\t\t\t\tthis.on('update-from-master', function() {\n\t\t\t\t\t// u.log(\"UPDATE FROM MASTER >> flushing \");\n\t\t\t\t\tthis_._flush_update_queue();\n\t\t\t\t\tthis_._flush_delete_queue();\n\t\t\t\t});\n\t\t\t},\n\t\t\t/// <string> fid file id\n\t\t\t/// Tries to get a file with given id. If it doesn't exist, a file with that name is created.\n\t\t\t/// @return <File> the file\n\t\t\tget_or_create_file:function(fid) {\n\t\t\t\tvar files = this.get('files');\n\t\t\t\tif (files.get(fid) === undefined) {\n\t\t\t\t\tfiles.add(new File({\"@id\": fid}, { box: this }));\n\t\t\t\t}\n\t\t\t\treturn files.get(fid);\n\t\t\t},\n\t\t\tset_up_websocket:function() {\n\t\t\t\tvar this_ = this, server_host = this.store.get('server_host');\n\t\t\t\tif (! this.get_use_websockets() ) { return; }\n\t\t\t\tthis.on('new-token', function(token) {\n\t\t\t\t\tvar ws = this_._ws;\n\t\t\t\t\tif (ws) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tws.close();\n\t\t\t\t\t\t\tdelete this_._ws;\n\t\t\t\t\t\t} catch(e) { u.error(); }\n\t\t\t\t\t}\n\t\t\t\t\tvar protocol = (document.location.protocol === 'https:') ? 'wss:/' : 'ws:/';\n\t\t\t\t\tvar ws_url = [protocol,server_host,'ws'].join('/');\n\t\t\t\t\tws = new WebSocket(ws_url);\n\t\t\t\t\tws.onmessage = function(evt) {\n\t\t\t\t\t\tu.debug('websocket :: incoming a message ', evt.data.toString().substring(0,190));\n\t\t\t\t\t\tvar pdata = JSON.parse(evt.data);\n\t\t\t\t\t\tif (pdata.action === 'diff') {\n\t\t\t\t\t\t\tthis_._diff_update(pdata.data)\n\t\t\t\t\t\t\t\t.then(function() {\n\t\t\t\t\t\t\t\t\tthis_.trigger('update-from-master', this_._get_version());\n\t\t\t\t\t\t\t\t}).fail(function(err) {\n\t\t\t\t\t\t\t\t\tu.error(err); /*  u.log('done diffing '); */\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tws.onopen = function() {\n\t\t\t\t\t\tvar data = WS_MESSAGES_SEND.auth(this_.get('token'));\n\t\t\t\t\t\tws.send(data);\n\t\t\t\t\t\tdata = WS_MESSAGES_SEND.diff();\n\t\t\t\t\t\tws.send(data);\n\t\t\t\t\t\tthis_._ws = ws;\n\t\t\t\t\t\tthis_.trigger('ws-connect');\n\t\t\t\t\t};\n\t\t\t\t\tws.onclose = function(evt) {\n\t\t\t\t\t\t// what do we do now?!\n\t\t\t\t\t\tu.error('websocket closed -- ');\n\t\t\t\t\t\t// TODO\n\t\t\t\t\t\tvar interval;\n\t\t\t\t\t\tinterval = setInterval(function() {\n\t\t\t\t\t\t\tthis_.store.reconnect().then(function() {\n\t\t\t\t\t\t\t\tthis_.get_token().then(function() {\n\t\t\t\t\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},1000);\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t},\n\t\t\tget_use_websockets:function() { return this.options.use_websockets; },\n\t\t\tget_cache_size:function(i) { return this._objcache().length; },\n\t\t\tget_obj_ids:function() { return this._objlist().slice(); },\n\t\t\t_objcache:function() { return this.attributes.objcache; },\n\t\t\t_objlist:function() { return this.attributes.objlist !== undefined ? this.attributes.objlist : []; },\n\t\t\t_set_objlist:function(ol) { return this.set({objlist:ol.slice()}); },\n\t\t\t_get_cached_token:function() { return this.get(\"token\"); },\n\t\t\t_set_token:function(token) { this.set(\"token\", token);\t},\n\t\t\t_set_version:function(v) { this.set(\"version\", v);\t},\n\t\t\t_get_version:function(v) { return this.get(\"version\"); },\n\t\t\tget_token:function() {\n\t\t\t\t// utils.debug('>> get_token ', ' id: ',this.id, ' cid: ',this.cid);\n\t\t\t\t// try { throw new Error(''); } catch(e) { console.error(e); }\n\t\t\t\tvar this_ = this, d = u.deferred();\n\t\t\t\tthis._ajax('POST', 'auth/get_token', { app: this.store.get('app') })\n\t\t\t\t\t.then(function(data) {\n\t\t\t\t\t\tconsole.log('setting token ', data.token);\n\t\t\t\t\t\tthis_._set_token( data.token );\n\t\t\t\t\t\tthis_.trigger('new-token', data.token);\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tget_id:function() { return this.id || this.cid;\t},\n\t\t\t_ajax:function(method, path, data) {\n\t\t\t\tdata = _(_(data||{}).clone()).extend({box: this.id || this.cid, token:this.get('token')});\n\t\t\t\treturn this.store._ajax(method, path, data);\n\t\t\t},\n\t\t\tput_file:function(id,filedata,contenttype) {\n\t\t\t\t// creates a File object and hands it back in the resolve\n\t\t\t\tcontenttype = contenttype || filedata.type;\n\t\t\t\tvar d = u.deferred(), this_ = this, newFile = this.get_or_create_file(id);\n\t\t\t\tnewFile.set({\"content-type\": contenttype});\n\t\t\t\tthis._do_put_file(id,filedata,contenttype).then(function(){\n\t\t\t\t\tu.debug('image put success ');\n\t\t\t\t\td.resolve(newFile);\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tif (err.status === 409) {\n\t\t\t\t\t\tvar cb = function() {\n\t\t\t\t\t\t\tthis_.off('update-from-master', cb, newFile);\n\t\t\t\t\t\t\tthis_._put_file(id, filedata, contenttype).then(d.resolve).fail(d.reject);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis_.on('update-from-master', cb, newFile);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu.error('error putting, dammit ', err);\n\t\t\t\t\t\td.reject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_do_put_file:function(id,file,contenttype) {\n\t\t\t\t// now uses relative url scheme '//blah:port/path';\n\t\t\t\t// all files must be PUT into boxname/files\n\t\t\t\t// here the parameters are get encoded\n\t\t\t\t// // 'http://' + this.store.get('server_host') + \"/\" +  boxid + \"/\" + 'files',\n\t\t\t\tvar boxid = this.id || this.cid,\n\t\t\t\tbase_url = ['/', this.store.get('server_host'), boxid, 'files'].join('/'),\n\t\t\t\toptions = { app: this.store.get('app'), id: id, token:this.get('token'),  box: boxid, version: this._get_version() },\n\t\t\t\toption_params = $.param(options),\n\t\t\t\turl = base_url+\"?\"+option_params,\n\t\t\t\td = u.deferred();\n\t\t\t\tconsole.log(\"PUTTING FILE \", url);\n\t\t\t\tvar ajax_args  = _(_(this.store.ajax_defaults).clone()).extend(\n\t\t\t\t\t{ url: url, method : 'PUT', crossDomain:false, data:file, contentType: contenttype, processData:false }\n\t\t\t\t);\n\t\t\t\treturn $.ajax( ajax_args );\n\t\t\t},\n\t\t\tquery: function(q){\n\t\t\t\t// @TODO ::::::::::::::::::::::::::\n\t\t\t\tu.NotImplementedYet();\n\t\t\t\t// var d = u.deferred();\n\t\t\t\t// this._ajax(this, \"/query\", \"GET\", {\"q\": JSON.stringify(q)})\n\t\t\t\t// \t.then(function(data){\n\t\t\t\t// \t\tconsole.debug(\"query results:\",data);\n\t\t\t\t// \t}).fail(function(data) {\n\t\t\t\t// \t\tconsole.debug(\"fail query\");\n\t\t\t\t// \t});\n\t\t\t\t// return d.promise();\n\t\t\t},\n\t\t\t_diff_update:function(response) {\n\t\t\t\tvar d = u.deferred(), this_ = this, latest_version = response['@to_version'],\n\t\t\t\tadded_ids  = _(response.data.added).keys(),\n\t\t\t\tchanged_ids = _(response.data.changed).keys(),\n\t\t\t\tdeleted_ids = _(response.data.deleted).keys(),\n\t\t\t\tchanged_objs = response.data.changed;\n\n\t\t\t\tu.assert(latest_version !== undefined, 'latest version not provided');\n\t\t\t\tu.assert(added_ids !== undefined, 'added_ids not provided');\n\t\t\t\tu.assert(changed_ids !== undefined, 'changed not provided');\n\t\t\t\tu.assert(deleted_ids !== undefined, 'deleted _ids not provided');\n\n\t\t\t\tif (latest_version <= this_._get_version()) {\n\t\t\t\t\tu.debug('asked to diff update, but already up to date, so just relax!', latest_version, this_._get_version());\n\t\t\t\t\treturn d.resolve();\n\t\t\t\t}\n\t\t\t\tu.debug('setting latest version >> ', latest_version, added_ids, changed_ids, deleted_ids);\n\t\t\t\tthis_._set_version(latest_version);\n\t\t\t\tthis_._update_object_list(undefined, added_ids, deleted_ids);\n\t\t\t\tvar change_dfds = _(changed_objs).map(function(obj, uri) {\n\t\t\t\t\tu.debug(' checking to see if in --- ', uri, this_._objcache().get(uri));\n\t\t\t\t\tu.debug('obj >> ', obj);\n\t\t\t\t\tvar cached_obj = this_._objcache().get(uri), cdfd = u.deferred();\n\t\t\t\t\tif (cached_obj) {\n\t\t\t\t\t\t// { prop : [ {sval1 - @type:\"\"}, {sval2 - @type} ... ]\n\t\t\t\t\t\tvar changed_properties = [];\n\t\t\t\t\t\t// console.log(\"obj deleted \", obj.deleted);\n\t\t\t\t\t\tvar deleted_propval_dfds = _(obj.deleted).map(function(vs, k) {\n\t\t\t\t\t\t\tchanged_properties = _(changed_properties).union([k]);\n\t\t\t\t\t\t\tvar dd = u.deferred();\n\t\t\t\t\t\t\tu.when(vs.map(function(v) {\treturn deserialize_value(v, this_);\t})).then(function(values) {\n\t\t\t\t\t\t\t\tvar new_vals = _(cached_obj.get(k) || []).difference(values);\n\t\t\t\t\t\t\t\t// console.log(\"DESERIALISED deleted values \", values, \" - \", \" new_vals \", new_vals);\n\t\t\t\t\t\t\t\t// window._values = values; window._newvals = new_vals;\n\t\t\t\t\t\t\t\tcached_obj.set(k,new_vals);\n\t\t\t\t\t\t\t\t// semantics - if a property has no value then we delete it\n\t\t\t\t\t\t\t\tif (new_vals.length === 0) { cached_obj.unset(k); }\n\t\t\t\t\t\t\t\tdd.resolve();\n\t\t\t\t\t\t\t}).fail(dd.reject);\n\t\t\t\t\t\t\treturn dd.promise();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tvar added_propval_dfds = _(obj.added).map(function(vs, k) {\n\t\t\t\t\t\t\tchanged_properties = _(changed_properties).union([k]);\n\t\t\t\t\t\t\tvar dd = u.deferred();\n\t\t\t\t\t\t\tu.when(vs.map(function(v) {\treturn deserialize_value(v, this_);\t})).then(function(values) {\n\t\t\t\t\t\t\t\tvar new_vals = (cached_obj.get(k) || []).concat(values);\n\t\t\t\t\t\t\t\tcached_obj.set(k,new_vals);\n\t\t\t\t\t\t\t\tdd.resolve();\n\t\t\t\t\t\t\t}).fail(dd.reject);\n\t\t\t\t\t\t\treturn dd.promise();\n\t\t\t\t\t\t});\n                        var replaced_propval_dfs = _(obj.replaced).map(function(vs, k) {\n                            console.debug(\"Processing replaced property\");\n                            changed_properties = _(changed_properties).union([k]);\n                            var dd = u.deferred();\n                            u.when(vs.map(function(v) { return deserialize_value(v, this_); })).then(function(values) {\n                                var new_vals = values; // this is the difference from added - just replace (by DS)\n                                cached_obj.set(k,new_vals);\n                                dd.resolve();\n                            }).fail(dd.reject);\n                            return dd.promise();\n                        });\n                        u.when(added_propval_dfds.concat(deleted_propval_dfds).concat(replaced_propval_dfs)).then(function() {\n\t\t\t\t\t\t\t// u.debug(\"triggering changed properties \", changed_properties);\n\t\t\t\t\t\t\tchanged_properties.map(function(k) {\n\t\t\t\t\t\t\t\tcached_obj.trigger('change:'+k, (cached_obj.get(k) || []).slice());\n\t\t\t\t\t\t\t\tu.debug(\"trigger! change:\"+k);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcdfd.resolve(cached_obj);\n\t\t\t\t\t\t}).fail(cdfd.reject);\n\t\t\t\t\t\treturn cdfd.promise();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tu.when(change_dfds).then(d.resolve).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_create_model_for_id: function(obj_id){\n\t\t\t\tvar model = new Obj({\"@id\":obj_id}, {box:this});\n\t\t\t\tthis._objcache().add(model);\n\t\t\t\treturn model;\n\t\t\t},\n\t\t\tget_obj:function(objid) {\n\t\t\t\t// get_obj always returns a promise\n\t\t\t\tu.assert(typeof objid === 'string' || typeof objid === 'number', \"objid has to be a number or string\");\n\t\t\t\tvar d = u.deferred(),\n\t\t\t\tcachemodel = this._objcache().get(objid),\n\t\t\t\tfetching_dfd = this._fetching_queue[objid],\n\t\t\t\thasmodel = cachemodel && fetching_dfd === undefined,\n\t\t\t\tthis_ = this;\n\n\t\t\t\tif (hasmodel) {\n\t\t\t\t\tconsole.log('returning cached ', objid);\n\t\t\t\t\td.resolve(cachemodel); return d.promise();\n\t\t\t\t}\n\n\t\t\t\t// check to see if already fetching, then we can tag along\n\t\t\t\tif (fetching_dfd) {\n\t\t\t\t\t// to fix a deadlock condition -\n\t\t\t\t\t// if we fetch someone who loops back to us\n\t\t\t\t\t// then we will never resolve with this code:\n\t\t\t\t\t//\n\t\t\t\t\t// fetching_dfd.then(d.resolve).fail(d.reject);\n\t\t\t\t\t// return d.promise();\n\t\t\t\t\t// --\n\t\t\t\t\t// therefore a fix:\n\t\t\t\t\td.resolve(cachemodel);\n\t\t\t\t\treturn d.promise();\n\t\t\t\t}\n\n\t\t\t\t// if not already fetching then we have to fetch\n\t\t\t\tthis._fetching_queue[objid] = d;\n\t\t\t\tvar model = this_._create_model_for_id(objid);\n\t\t\t\t// if the serve knows about it, then we fetch its definition\n\t\t\t\tconsole.log('objlist ', this._objlist());\n\n\t\t\t\t// old code ::\n\t\t\t\t// if (this._objlist().indexOf(objid) >= 0) {\n\t\t\t\t// \tconsole.log('object exists, going to fetch it ');\n\t\t\t\t// \tmodel.fetch().then(function() {\n\t\t\t\t// \t\td.resolve(model);\n\t\t\t\t// \t\tdelete this_._fetching_queue[objid];\n\t\t\t\t// \t}).fail(d.reject);\n\t\t\t\t// } else {\n\t\t\t\t// \tconsole.log('object doesnt exist, not going to fetch it ');\n\t\t\t\t// \t// otherwise it must be new!\n\t\t\t\t// \tmodel.is_new = true;\n\t\t\t\t// \td.resolve(model);\n\t\t\t\t// }\n\n\t\t\t\tconsole.log('trying to fetch ', objid);\n\t\t\t\tmodel.fetch().then(function() {\n\t\t\t\t\td.resolve(model);\n\t\t\t\t\tdelete this_._fetching_queue[objid];\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tconsole.log('failed.. declaring it new ', objid);\n\t\t\t\t\t// TODO check if 404'd\n\t\t\t\t\tconsole.log('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA err - didnt exist ? ', err);\n\t\t\t\t\tmodel.is_new = true;\n\t\t\t\t\td.resolve(model);\n\t\t\t\t\tdelete this_._fetching_queue[objid];\n\t\t\t\t});\n\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// ----------------------------------------------------\n\t\t\t_update_object_list:function(updated_obj_ids, added, deleted) {\n\t\t\t\tvar current, olds = this._objlist().slice(), this_ = this, news, died;\n\t\t\t\t// u.debug('_update_object_list +', added ? added.length : ' ', '-', deleted ? deleted.length : ' ');\n\t\t\t\t// u.debug('_update_object_list +', added || ' ', deleted || ' ');\n\t\t\t\tif (updated_obj_ids === undefined ) {\n\t\t\t\t\tcurrent = _(olds).chain().union(added).difference(deleted).value();\n\t\t\t\t\tnews = (added || []).slice(); died = (deleted || []).slice();\n\t\t\t\t} else {\n\t\t\t\t\tcurrent = updated_obj_ids.slice();\n\t\t\t\t\tnews = _(current).difference(olds);\n\t\t\t\t\tdied = _(olds).difference(current);\n\t\t\t\t}\n\t\t\t\t// u.debug('old objlist had ', olds.length, ' new has ', current.length, 'news > ', news);\n\t\t\t\tthis._set_objlist(current);\n\t\t\t\tnews.map(function(aid) {\tthis_.trigger('obj-add', aid);\t});\n\t\t\t\tdied.map(function(rid) {\n\t\t\t\t\tthis_.trigger('obj-remove', rid);\n\t\t\t\t\tthis_._objcache().remove(rid);\n\t\t\t\t});\n\t\t\t},\n\t\t\t_is_fetched: function() {\n\t\t\t\treturn this.id !== undefined;\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\t// all fetch really does is retrieve ids!\n\t\t\t\t// new client :: this now _only_ fetches object ids\n\t\t\t\t// return a list of models (each of type Object) to populate a GraphCollection\n\t\t\t\tvar d = u.deferred(), fd = u.deferred(), this_ = this;\n\t\t\t\tif (this._is_fetched()) {\n\t\t\t\t\t// Nope - don't do anything -- we just wait for websockets to update us.\n\t\t\t\t\tfd.resolve();\n\t\t\t\t} else {\n\t\t\t\t\t// otherwise we aren't fetched, so we just do it\n\t\t\t\t\tvar box = this.get_id();\n\t\t\t\t\tthis._ajax(\"GET\",[box,'get_object_ids'].join('/')).then(\n\t\t\t\t\t\tfunction(response){\n\t\t\t\t\t\t\tu.assert(response['@version'] !== undefined, 'no version provided');\n\t\t\t\t\t\t\tthis_.id = this_.get_id(); // sets so that _is_fetched later returns true\n\t\t\t\t\t\t\tthis_._set_version(response['@version']);\n\t\t\t\t\t\t\tthis_._update_object_list(response.ids);\n\t\t\t\t\t\t\tfd.resolve(this_);\n\t\t\t\t\t\t}).fail(fd.reject);\n\t\t\t\t}\n\t\t\t\tfd.then(function() {\n\t\t\t\t\tthis_.trigger('update-from-master', this_._get_version());\n\t\t\t\t\td.resolve(this_);\n\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// -----------------------------------------------\n\t\t\t_check_token_and_fetch : function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (this.get('token') === undefined) {\n\t\t\t\t\tvar d = u.deferred();\n\t\t\t\t\tthis.get_token()\n\t\t\t\t\t\t.then(function() { this_._fetch().then(d.resolve).fail(d.reject);\t})\n\t\t\t\t\t\t.fail(d.reject);\n\t\t\t\t\treturn d.promise();\n\t\t\t\t}\n\t\t\t\treturn this_._fetch();\n\t\t\t},\n\t\t\t_create_box:function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis.store._ajax('POST', 'admin/create_box', { name: this.get_id() } )\n\t\t\t\t\t.then(function() {\n\t\t\t\t\t\tthis_.fetch().then(function() { d.resolve(); }).fail(function(err) { d.reject(err); });\n\t\t\t\t\t}).fail(function(err) { d.reject(err); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tdelete_box:function(boxid) {\n\t\t\t\treturn this.store._ajax('POST','admin/delete_box', { name: boxid } );\n\t\t\t},\n\t\t\t// =============== :: UPDATE ::  ======================\n\t\t\tWHOLE_BOX: \"__UPDATE__WHOLE__BOX__\",\n\t\t\t_add_to_update_queue:function(ids_to_update) {\n\t\t\t\tvar this_ = this, uq = this._update_queue;\n\t\t\t\t// returns the deferreds\n\t\t\t\tids_to_update = ids_to_update === undefined ? [ this.WHOLE_BOX ] : ids_to_update;\n\t\t\t\treturn ids_to_update.map(function(id) {\n\t\t\t\t\tuq[id] = uq[id] || u.deferred();\n\t\t\t\t\treturn uq[id];\n\t\t\t\t});\n\t\t\t},\n\t\t\t_requeue_update:function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (!this._update_timeout) {\n\t\t\t\t\tthis._update_timeout = setTimeout(function() {\n\t\t\t\t\t\tdelete this_._update_timeout;\n\t\t\t\t\t\tthis_._flush_update_queue();\n\t\t\t\t\t}, 300);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_flush_update_queue:function() {\n\t\t\t\tvar this_ = this, uq = this._update_queue, ids_to_update = _(uq).keys();\n\t\t\t\tif (ids_to_update.length === 0) { return ; }\n\t\t\t\tif (this._updating || this._deleting) {\n\t\t\t\t\treturn this._requeue_update();\n\t\t\t\t}\n\n\t\t\t\tthis._update_queue = {};\n\t\t\t\tvar update_arguments = ids_to_update.indexOf(this.WHOLE_BOX) >= 0 ? undefined : ids_to_update;\n\t\t\t\tthis_._updating = true;\n\n\t\t\t\tthis_._do_update(update_arguments).then(function() {\n\t\t\t\t\tdelete this_._updating;\n\t\t\t\t\t// TODO: resolve all of our deferreds now and delete them\n\t\t\t\t\tids_to_update.map(function(id) { uq[id].resolve();\t\t});\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tdelete this_._updating;\n\t\t\t\t\tif (err.status === 409) {\n\t\t\t\t\t\t// add the defferds back in\n\t\t\t\t\t\t_(uq).map(function(d,id) {\n\t\t\t\t\t\t\tif (this_._update_queue[id]) {\n\t\t\t\t\t\t\t\t// someone's already added one back in! let's chain them\n\t\t\t\t\t\t\t\tu.debug('HEYYYYYYYYYYYYYYYYYYYYYY already added in - lets go');\n\t\t\t\t\t\t\t\tthis_._update_queue[id].then(uq[id].resolve).fail(uq[id].reject);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tu.debug('sneaking him back in - lets go');\n\t\t\t\t\t\t\t\tthis_._update_queue[id] = uq[id];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn this_._requeue_update();\n\t\t\t\t\t}\n\t\t\t\t\t// something bad happened, we'd better reject on those deferreds\n\t\t\t\t\tu.error('UPDATE error ', err);\n\t\t\t\t\tids_to_update.map(function(id) { uq[id].reject(err);});\n\t\t\t\t});\n\t\t\t},\n\t\t\t_do_update:function(ids) {\n\t\t\t\t// this actua\n\t\t\t\tconsole.log('box update >> ');\n\t\t\t\tvar d = u.deferred(), version = this.get('version') || 0, this_ = this,\n\t\t\t\tobjs = this._objcache().filter(function(x) { return ids === undefined || ids.indexOf(x.id) >= 0; }),\n\t\t\t\tobj_ids = objs.map(function(x) { return x.id; }),\n\t\t\t\tsobjs = objs.map(function(obj){ return serialize_obj(obj); });\n\t\t\t\tthis._ajax(\"PUT\",  this.get_id() + \"/update\", { version: escape(version), data : JSON.stringify(sobjs)  })\n\t\t\t\t\t.then(function(response) {\n\t\t\t\t\t\tthis_._set_version(response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._update_object_list(undefined, obj_ids, []); // update object list\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tupdate:function(original_ids) {\n\t\t\t\t// this is called by Backbone.save(),\n\t\t\t\tvar dfds = this._add_to_update_queue(original_ids);\n\t\t\t\tthis._flush_update_queue();\n\t\t\t\treturn dfds;\n\t\t\t},\n\t\t\t// =============== :: DELETE ::  ======================\n\t\t\t_add_to_delete_queue:function(ids) {\n\t\t\t\tvar this_ = this, dq = this._delete_queue;\n\t\t\t\treturn ids.map(function(id) {\n\t\t\t\t\tdq[id] = dq[id] || u.deferred();\n\t\t\t\t\treturn dq[id];\n\t\t\t\t});\n\t\t\t},\n\t\t\t_delete_models:function(ids) {\n\t\t\t\tvar dfds =  this._add_to_delete_queue(ids);\n\t\t\t\tthis._flush_delete_queue();\n\t\t\t\treturn dfds;\n\t\t\t},\n\t\t\t_requeue_delete:function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (!this._delete_timeout) {\n\t\t\t\t\tthis._delete_timeout = setTimeout(function() {\n\t\t\t\t\t\tdelete this_._delete_timeout;\n\t\t\t\t\t\tthis_._flush_delete_queue();\n\t\t\t\t\t}, 300);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_flush_delete_queue:function() {\n\t\t\t\tvar this_ = this, dq = this._delete_queue, delete_ids = _(dq).keys();\n\t\t\t\tif (delete_ids.length === 0) { return ; }\n\t\t\t\tif (this._deleting || this._updating) { return this._requeue_delete();  }\n\t\t\t\tthis_._deleting = true;\n\t\t\t\tthis_._do_delete(delete_ids).then(function() {\n\t\t\t\t\tdelete this_._deleting;\n\t\t\t\t\tdelete_ids.map(function(id) {\n\t\t\t\t\t\tdq[id].resolve(); delete dq[id];\n\t\t\t\t\t});\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tdelete this_._deleting;\n\t\t\t\t\tif (err.status === 409) { this_._requeue_delete();\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t_do_delete:function(m_ids) {\n\t\t\t\tvar version = this.get('version') || 0, d = u.deferred(), this_ = this;\n\t\t\t\tthis._ajax('DELETE', this.id+'/', { version:version, data: JSON.stringify(m_ids) })\n\t\t\t\t\t.then(function(response) {\n\t\t\t\t\t\tu.debug('DELETE response NEW version > ', response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._set_version(response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._update_object_list(undefined, [], m_ids); // update object list\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// =============== :: SYNC ::  ======================\n\t\t\tsync: function(method, box, options){\n\t\t\t\tswitch(method)\n\t\t\t\t{\n\t\t\t\tcase \"create\": return box._create_box();\n\t\t\t\tcase \"read\": return box._check_token_and_fetch();\n\t\t\t\tcase \"update\": return box.update()[0];  // save whole box?\n\t\t\t\tcase \"delete\": return this.delete_box(this.get_id()) // hook up to destroy\n\t\t\t\t}\n\t\t\t},\n\t\t\ttoString: function() { return 'box:' + this.get_id(); }\n\t\t});\n\n\t\tvar BoxCollection = Backbone.Collection.extend({ model: Box });\n\n\t\tvar Store =  Backbone.Model.extend({\n\t\t\tdefaults: {\n\t\t\t\tserver_host:DEFAULT_HOST,\n\t\t\t\tapp:\"--default-app-id--\"\n\t\t\t},\n\t\t\tajax_defaults : {\n\t\t\t\tjsonp: false, contentType: \"application/json\",\n\t\t\t\txhrFields: { withCredentials: true }\n\t\t\t},\n\n\t\t\t/// @opt <{}> attributes\n\t\t\t/// @opt <{}> options\n\t\t\t/// @constructor\n\t\t\tinitialize: function(attributes, options){\n\t\t\t\tthis.set({boxes : new BoxCollection([], {store: this})});\n\t\t\t},\n\n\t\t\t/// Check that the\n\t\t\tis_same_domain:function() {\n\t\t\t\treturn this.get('server_host').indexOf(document.location.host) >= 0 && (document.location.port === (this.get('server_port') || ''));\n\t\t\t},\n\t\t\tboxes:function() { return this.attributes.boxes;\t},\n\t\t\tget_box: function(boxid) {\n\t\t\t\tvar b = this.boxes().get(boxid) || this._create(boxid);\n\t\t\t\tif (!b._get_cached_token()) {\n\t\t\t\t\treturn b.get_token().pipe(function() {\n\t\t\t\t\t\treturn b.fetch();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn u.dresolve(b);\n\t\t\t},\n\n\n\t\t\t/// @arg <string|number> boxid: the id for the box\n\t\t\t///\n\t\t\t/// @then (<Box> the box)\n\t\t\t/// @fail\n\t\t\t///   (<{ code: 409 }> response) box already exists\n\t\t\t///   (<{ code: -1, error: error obj }> response) other error\n\t\t\t///\n\t\t\t/// Attempts to create a box with the given ID\n\t\t\tcreate_box: function (boxid) {\n\t\t\t\tu.debug('create box ', boxid);\n\t\t\t\tif (this.boxes().get(boxid)) {\n\t\t\t\t\treturn u.dreject({ code: 409, message: 'Box already exists: ' + boxid });\n\t\t\t\t}\n\t\t\t\tvar c = this._create(boxid), this_ = this;\n\t\t\t\tu.debug('creating ', boxid);\n\t\t\t\treturn c.save().pipe(function() { return this_.get_box(boxid); });\n\t\t\t},\n\t\t\tcheck_login:function() {\n\t\t\t\t// checks whether you can connect to the server and who is logged in.\n\t\t\t\t// returns a deferred that gets passed an argument\n\t\t\t\t// { code:200 (server is okay),  is_authenticated:true/false,  user:<username>  }\n\t\t\t\treturn this._ajax('GET', 'auth/whoami');\n\t\t\t},\n\t\t\t// todo: change to _\n\t\t\tget_info:function() { return this._ajax('GET', 'admin/info'); },\n\t\t\tlogin : function(username,password) {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tthis.set({username:username,password:password});\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis._ajax('POST', 'auth/login', { username: username, password: password })\n\t\t\t\t\t.then(function(l) { this_.trigger('login', username); d.resolve(l); })\n\t\t\t\t\t.fail(function(l) { d.reject(l); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\treconnect:function() {\n\t\t\t\treturn this.login(this.get('username'),this.get('password'));\n\t\t\t},\n\t\t\tlogout : function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis._ajax('POST', 'auth/logout')\n\t\t\t\t\t.then(function(l) { this_.trigger('logout'); d.resolve(l); })\n\t\t\t\t\t.fail(function(l) { d.reject(l); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_create:function(boxid) {\n\t\t\t\tvar b = new Box({}, {store: this});\n\t\t\t\tb.cid = boxid;\n\t\t\t\tthis.boxes().add(b);\n\t\t\t\treturn b;\n\t\t\t},\n\t\t\tget_box_list:function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tthis._ajax('GET','admin/list_boxes')\n\t\t\t\t\t.success(function(data) {d.resolve(data.list);})\n\t\t\t\t\t.fail(function(err) { d.reject(err); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\tthrow new Error('dont fetch a store - any more!');\n\t\t\t\t//\n\t\t\t\t// fetches list of boxes\n\t\t\t\t/* - do not do this\n\t\t\t\tvar this_ = this, d = u.deferred();\n\t\t\t\tthis._ajax('GET','admin/list_boxes')\n\t\t\t\t\t.success(function(data) {\n\t\t\t\t\t\tu.when(data.list.map(function(boxid) { return this_.get_box(boxid); })).then(function(boxes) {\n\t\t\t\t\t\t\t// console.log(\"boxes !! \", boxes);\n\t\t\t\t\t\t\tthis_.boxes().reset(boxes);\n\t\t\t\t\t\t\td.resolve(boxes);\n\t\t\t\t\t\t});\n\t\t\t\t\t}).error(function(e) { d.reject(e); });\n\t\t\t\treturn d.promise();\n\t\t\t\t*/\n\t\t\t},\n\t\t\t_ajax:function(method, path, data) {\n\t\t\t\t// now uses relative url scheme '//blah:port/path';\n\t\t\t\tvar url = ['/', this.get('server_host'), path].join('/');\n\t\t\t\tvar default_data = { app: this.get('app') };\n\t\t\t\tvar options = _(_(this.ajax_defaults).clone()).extend(\n\t\t\t\t\t{ url: url, method : method, crossDomain: !this.is_same_domain(), data: _(default_data).extend(data) }\n\t\t\t\t);\n\t\t\t\treturn $.ajax( options ); // returns a deferred\n\t\t\t},\n\t\t\tsync: function(method, model, options){\n\t\t\t\tswitch(method){\n\t\t\t\tcase \"create\": return u.error('store.create() : cannot create a store'); // TODO\n\t\t\t\tcase \"read\"  : return model._fetch();\n\t\t\t\tcase \"update\": return u.error('store.update() : cannot update a store'); // TODO\n\t\t\t\tcase \"delete\": return u.error('store.delete() : cannot delete a store'); // tODO\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tvar exports = {\n\t\t\tsafe_apply:utils.safe_apply,\n\t\t\tu : utils,\n\t\t\tStore:Store,\n\t\t\tObj: Obj,\n\t\t\tFile:File,\n\t\t\tBox: Box,\n\t\t\tstore: new Store(),\n\t\t\tloaded : utils.deferred()\n\t\t};\n\t\twindow.u = utils;\n\n\t\t// do not fetch boxes\n\t\texports.loaded.resolve(exports);\n\t\treturn exports;\n\n\t}).factory('backbone', function(client, utils) {\n\t\t// this manages backbone-angular mystification\n\t\tvar deregfns = [];\n\t\tvar deep_clone_obj = function(o) {\n\t\t\treturn utils.dict(_(o).map(function(v,k) { return [k, v.concat()]; }));\n\t\t};\n\t\tvar scope_bind = function($scope, name, model) {\n\t\t\tutils.assert(model instanceof Backbone.Model, \"tried to bind something that was not a model\");\n\t\t\twindow._m = model;\n\t\t\tvar clone = deep_clone_obj(_(model.attributes));\n\t\t\tutils.safe_apply($scope, function() { $scope[name] = clone;\t});\n\t\t\tvar findchanges = function(old,new_,fn) {\n\t\t\t\tvar changes = [];\n\t\t\t\t_(old).map(function(v,k) {\n\t\t\t\t\tif (v.length !== new_[k].length || _(v).filter(function(vi, i) { return vi != new_[k][i]; }).length) {\n\t\t\t\t\t\tutils.log('pushing changes ', k, new_[k]);\n\t\t\t\t\t\tchanges.push(k);\n\t\t\t\t\t\tif (fn) { fn(k,new_[k].concat()); }\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn changes;\n\t\t\t};\n\t\t\t// angular -> backbone\n\t\t\tvar dereg = $scope.$watch(name, function() {\n\t\t\t\t// do a quick diff --\n\t\t\t\t// first check to make sure that our brave model is still\n\t\t\t\tif ($scope[name] !== clone) { return true; }\n\t\t\t\tfindchanges(model.attributes, clone, function(k,v) {model.set(k,v); });\n\t\t\t}, true);\n\t\t\tderegfns.push([$scope,name,model,dereg]);\n\t\t\t// backbone -> angular\n\t\t\tmodel.on('change', function(data) {\n\t\t\t\tutils.safe_apply($scope, function() {\n\t\t\t\t\tfindchanges(clone, model.attributes, function(k,v) { clone[k] = v;\t});\n\t\t\t\t});\n\t\t\t},$scope);\n\t\t};\n\t\treturn {\n\t\t\tscope_bind: scope_bind,\n\t\t\tscope_unbind:function($scope,name) {\n\t\t\t\tderegfns.map(function(tuple) {\n\t\t\t\t\tvar scope = tuple[0],name = tuple[1],model = tuple[2],dereg = tuple[3];\n\t\t\t\t\tmodel.off('change', null, scope);\n\t\t\t\t\tdereg();\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t});\n","methods":[{"name":"initialize","args":[{"name":"attrs","moreInfo":false,"last":false},{"name":"options","moreInfo":false,"last":true}],"start":5834,"line":162,"description":"","result":"","hasArgs":true,"cls":"~1"},{"name":"get_id","args":[],"start":6028,"line":167,"description":"","result":"","cls":"~1"},{"name":"set","args":[{"name":"k","moreInfo":false,"last":false},{"name":"v","moreInfo":false,"last":false},{"name":"options","moreInfo":false,"last":true}],"start":6598,"line":185,"description":"","result":"","hasArgs":true,"cls":"~1"},{"name":"delete_properties","args":[{"name":"props","moreInfo":false,"last":false},{"name":"silent","moreInfo":false,"last":true}],"start":6907,"line":192,"description":"","result":"","hasArgs":true,"cls":"~1"},{"name":"sync","args":[{"name":"method","moreInfo":false,"last":false},{"name":"model","moreInfo":false,"last":false},{"name":"options","moreInfo":false,"last":true}],"start":9512,"line":263,"description":"","result":"","hasArgs":true,"cls":"~1"}],"properties":[],"match":"Obj =  Backbone.Model.extend(","name":"Obj","start":5740,"extend":"~classes~0","end":9964},{"data":"///\n/// @title INDX\n/// blah\n\n/*global $,_,document,window,console,escape,Backbone,exports,WebSocket */\n/*jslint vars:true, todo:true */\n/*\n\n  indx.js is the JS Client SDK for WebBox WebBox\n  which builds upon Backbone's Model architecture.\n\n  CURRENT TODOs:\n  \t- update only supports updating the entire box\n    - Box.fetch() retrieves _entire box contents_\n\t  ... which is a really bad idea.\n\n  @prerequisites:\n\tjquery 1.8.0 or higher\n\tbackbone.js 0.9.2 or higher\n\tunderscore.js 1.4.2 or higher\n\n  This file is part of INDX\n  Copyright 2012 Max Van Kleek, Daniel Alexander Smith\n  Copyright 2012 University of Southampton\n\n  WebBox is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  WebBox is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with Indx.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n\nangular\n\t.module('indx', ['ui'])\n\t.factory('client',function(utils) {\n\t\tvar u = utils; // to be filled in by dependency\n\t\t// set up our parameters for webbox -\n\t\t// default is that we're loading from an _app_ hosted within\n\t\t// indx.\n\t\tvar DEFAULT_HOST = document.location.host; // which may contain the port\n\t\tvar WS_MESSAGES_SEND = {\n\t\t\tauth: function(token) { return JSON.stringify({action:'auth', token:token}); },\n\t\t\tdiff: function(token) { return JSON.stringify({action:'diff', operation:\"start\"}); }\n\t\t};\n\t\tvar serialize_obj = function(obj) {\n\t\t\tvar uri = obj.id;\n\t\t\tvar out_obj = {};\n\t\t\t$.each(obj.attributes, function(pred, vals){\n\t\t\t\tif (pred[0] === \"_\" || pred[0] === \"@\"){\n\t\t\t\t\t// don't expand @id etc.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar obj_vals = [];\n\t\t\t\tif (!(vals instanceof Array)){\n\t\t\t\t\tvals = [vals];\n\t\t\t\t}\n\t\t\t\t$.each(vals, function(){\n\t\t\t\t\tvar val = this;\n\t\t\t\t\tif (val instanceof File) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.id, \"@type\":\"indx-file\", \"@language\":val.get('content-type')});\n\t\t\t\t\t} else if (val instanceof Obj) {\n\t\t\t\t\t\tobj_vals.push({\"@id\": val.id });\n\t\t\t\t\t} else if (typeof val === \"object\" && (val[\"@value\"] || val[\"@id\"])) {\n\t\t\t\t\t\tobj_vals.push(val); // fully expanded string, e.g. {\"@value\": \"foo\", \"@language\": \"en\" ... }\n\t\t\t\t\t} else if (typeof val === \"string\" || val instanceof String ){\n\t\t\t\t\t\tobj_vals.push({\"@value\": val});\n\t\t\t\t\t} else if (_.isDate(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toISOString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"});\n\t\t\t\t\t} else if (_.isNumber(val) && u.isInteger(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#integer\"});\n\t\t\t\t\t} else if (_.isNumber(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#float\"});\n\t\t\t\t\t} else if (_.isBoolean(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#boolean\"});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu.warn(\"Could not determine type of val \", pred, val);\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString()});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tout_obj[pred] = obj_vals;\n\t\t\t});\n\t\t\tout_obj['@id'] = uri;\n\t\t\treturn out_obj;\n\t\t};\n\n\t\tvar literal_deserializers = {\n\t\t\t'': function(o) { return o['@value']; },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#integer\": function(o) { return parseInt(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#float\": function(o) { return parseFloat(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#double\": function(o) { return parseFloat(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#boolean\": function(o) { return o['@value'].toLowerCase() === 'true'; },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#dateTime\": function(o) { return new Date(Date.parse(o['@value'])); },\n\t\t\t\"indx-file\": function(o,box) {\n\t\t\t\tvar f = box.get_or_create_file(o['@value']);\n\t\t\t\tf.set(\"content-type\", o['@language']);\n\t\t\t\treturn f;\n\t\t\t}\n\t\t};\n\t\tvar deserialize_literal = function(obj, box) {\n\t\t\treturn obj['@value'] !== undefined ? literal_deserializers[ obj['@type'] || '' ](obj, box) : obj;\n\t\t};\n\n\t\tvar deserialize_value = function(s_val, box) {\n\t\t\tvar vd = u.deferred();\n\t\t\t// it's an object, so return that\n\t\t\tif (s_val.hasOwnProperty(\"@id\")) {\n\t\t\t\t// object\n\t\t\t\tbox.get_obj(s_val[\"@id\"]).then(vd.resolve).fail(vd.reject);\n\t\t\t}\n\t\t\telse if (s_val.hasOwnProperty(\"@value\")) {\n\t\t\t\t// literal\n\t\t\t\tvd.resolve(deserialize_literal(s_val, box));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// don't know what it is!\n\t\t\t\tvd.reject('cannot unpack value ', s_val);\n\t\t\t}\n\t\t\treturn vd.promise();\n\t\t};\n\n\t\tvar File =  Backbone.Model.extend({\n\t\t\tidAttribute: \"@id\", // the URI attribute is '@id' in JSON-LD\n\t\t\tinitialize:function(attrs, options) {\n\t\t\t\tu.debug('options >> ', attrs, options );\n\t\t\t\tthis.box = options.box;\n\t\t\t},\n\t\t\tget_id:function() { return this.id;\t},\n\t\t\tget_url:function() {\n\t\t\t\tvar params = {\n\t\t\t\t\tid:this.get_id(),\n\t\t\t\t\tapp:this.box.store.get('app'),\n\t\t\t\t\ttoken:this.box.get('token'),\n\t\t\t\t\tbox:this.box.get_id()\n\t\t\t\t}, url = ['/', this.box.store.get('server_host'), this.box.id, 'files'].join('/') + '?' + $.param(params);\n\t\t\t\t// u.debug(\"IMAGE URL IS \", url, params);\n\t\t\t\treturn url;\n\t\t\t}\n\t\t});\n\n\n\t\t// MAP OF THIS MODUULE :::::::::::::: -----\n\t\t//\n\t\t// An Obj is a single instance, thing in Indx.\n\t\t//\n\t\t// A Box is a model that has an attribute called 'Objs'.\n\t\t// ...  which is a Backbone.Collection of Graph objects.\n\t\t//\n\t\t// A _Store_ represents a single Indx server, which has an\n\t\t//\t attribute called 'boxes' -\n\t\t// ... which is a collection of Box objects\n\t\tvar Obj =  Backbone.Model.extend({\n\t\t\tidAttribute: \"@id\", // the URI attribute is '@id' in JSON-LD\n\t\t\tinitialize:function(attrs, options) {\n\t\t\t\tthis.box = options.box;\n\t\t\t},\n\t\t\t_is_fetched: function() { return this._fetched || false; },\n\t\t\t_set_fetched : function() { this._fetched = true; },\n\t\t\tget_id:function() { return this.id;\t},\n\t\t\t_value_to_array:function(k,v) {\n\t\t\t\tif (k === '@id') { return v; }\n\t\t\t\tif (!_(v).isUndefined() && !_(v).isArray()) {\n\t\t\t\t\treturn [v];\n\t\t\t\t}\n\t\t\t\treturn v;\n\t\t\t},\n\t\t\t_all_values_to_arrays:function(o) {\n\t\t\t\tif (!_(o).isObject()) { utils.error(' not an object', o); return o; }\n\t\t\t\tvar this_ = this;\n\t\t\t\t// ?!?! this isn't doing anything (!!)\n\t\t\t\treturn u.dict(_(o).map(function(v,k) {\n\t\t\t\t\tvar val = this_._value_to_array(k,v);\n\t\t\t\t\tif (u.defined(val)) { return [k,val]; }\n\t\t\t\t\treturn undefined;\n\t\t\t\t}).filter(u.defined));\n\t\t\t},\n\t\t\tset:function(k,v,options) {\n\t\t\t\t// set is tricky because it can be called like\n\t\t\t\t// set('foo',123) or set({foo:123})\n\t\t\t\tif (typeof k === 'string') { v = this._value_to_array(k,v);\t}\n\t\t\t\telse {\tk = this._all_values_to_arrays(k);\t}\n\t\t\t\treturn Backbone.Model.prototype.set.apply(this,[k,v,options]);\n\t\t\t},\n\t\t\tdelete_properties:function(props, silent)  {\n\t\t\t\tvar this_ = this;\n\t\t\t\tprops.map(function(p) { this_.unset(p, silent ? {silent:true} : {}); });\n\t\t\t},\n\t\t\t_deserialise_and_set:function(s_obj, silent) {\n\t\t\t\t// returns a promise\n\t\t\t\tvar this_ = this;\n\t\t\t\tvar dfds = _(s_obj).map(function(vals, key) {\n\t\t\t\t\tvar kd = u.deferred();\n\t\t\t\t\tif (key.indexOf('@') === 0) { return; }\n\t\t\t\t\tvar val_dfds = vals.map(function(val) {\n\t\t\t\t\t\tvar vd = u.deferred();\n\t\t\t\t\t\t// it's an object, so return that\n\t\t\t\t\t\tif (val.hasOwnProperty(\"@id\")) {\n\t\t\t\t\t\t\t// object\n\t\t\t\t\t\t\tthis_.box.get_obj(val[\"@id\"]).then(vd.resolve).fail(vd.reject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (val.hasOwnProperty(\"@value\")) {\n\t\t\t\t\t\t\t// literal\n\t\t\t\t\t\t\tvd.resolve(deserialize_literal(val, this_.box));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// don't know what it is!\n\t\t\t\t\t\t\tvd.reject('cannot unpack value ', val);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn vd.promise();\n\t\t\t\t\t});\n\t\t\t\t\tu.when(val_dfds).then(function(obj_vals) {\n\t\t\t\t\t\t// only update keys that have changed\n\t\t\t\t\t\tvar prev_vals = this_.get(key);\n\t\t\t\t\t\tif ( prev_vals === undefined || obj_vals.length !== prev_vals.length ||\n\t\t\t\t\t\t\t _(obj_vals).difference(prev_vals).length > 0 ||\n\t\t\t\t\t\t\t _(prev_vals).difference(obj_vals).length > 0) {\n\t\t\t\t\t\t\tthis_.set(key, obj_vals, { silent : silent });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkd.resolve();\n\t\t\t\t\t}).fail(kd.reject);\n\t\t\t\t\treturn kd.promise();\n\t\t\t\t}).filter(u.defined);\n\t\t\t\treturn u.when(dfds);\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\tvar this_ = this, fd = u.deferred(), box = this.box.get_id();\n\t\t\t\tthis.box._ajax('GET', box, {'id':this.id}).then(function(response) {\n\t\t\t\t\tthis_._set_fetched(true);\n\t\t\t\t\tvar objdata = response.data;\n\t\t\t\t\tif (objdata['@version'] === undefined) {\n\t\t\t\t\t\t// then the server thinks we've been deleted, so let's just die.\n\t\t\t\t\t\treturn fd.reject(this_.id);\n\t\t\t\t\t\t// old code:\n\t\t\t\t\t\t// according to the server, we're dead.\n\t\t\t\t\t\t// console.log('zombie detected ', this_.id);\n\t\t\t\t\t\t// this_.cid = this_.id;\n\t\t\t\t\t\t// this_.unset({});\n\t\t\t\t\t\t// delete this_.id;\n\t\t\t\t\t\t// fd.resolve();\n\t\t\t\t\t\t// return;\n\t\t\t\t\t}\n\t\t\t\t\t// we are at current known version as far as we know\n\t\t\t\t\tvar obj_save_dfds = _(objdata).map(function(obj,uri) {\n\t\t\t\t\t\t// top level keys - corresponding to box level properties\n\t\t\t\t\t\tif (uri[0] === \"@\") { return; } // ignore \"@id\", \"@version\" etc\n\t\t\t\t\t\t// not one of those, so must be a\n\t\t\t\t\t\t// < uri > : { prop1 .. prop2 ... }\n\t\t\t\t\t\tu.assert(uri === this_.id, 'can only deserialise this object ');\n\t\t\t\t\t\treturn this_._deserialise_and_set(obj);\n\t\t\t\t\t});\n\t\t\t\t\tu.when(obj_save_dfds).then(function(){ fd.resolve(this_); }).fail(fd.reject);\n\t\t\t\t});\n\t\t\t\treturn fd.promise();\n\t\t\t},\n\t\t\tsync: function(method, model, options){\n\t\t\t\tswitch(method){\n\t\t\t\tcase \"create\": return u.assert(false, \"create is never used for Objs\");\n\t\t\t\tcase \"read\"  : return model._fetch();\n\t\t\t\tcase \"update\":\n\t\t\t\t\treturn  model.box.update([model.id])[0];\n\t\t\t\tcase \"delete\":\n\t\t\t\t\treturn this.box._delete_models([this.id])[0];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\n\t\t// Box =================================================\n\t\t// GraphCollection is the list of Objs in a Graph\n\t\tvar ObjCollection = Backbone.Collection.extend({ model: Obj }),\n\t\t\tFileCollection = Backbone.Collection.extend({ model: File });\n\n\t\t// new client: fetch is always lazy, only gets ids, and\n\t\t// lazily get objects as you go\n\t\tvar Box = Backbone.Model.extend({\n\t\t\tidAttribute:\"@id\",\n\t\t\tdefault_options: { use_websockets:true, ws_auto_reconnect:false\t},\n\t\t\tinitialize:function(attributes, options) {\n\t\t\t\tvar this_ = this;\n\t\t\t\tu.assert(options.store, \"no store provided\");\n\t\t\t\tthis.store = options.store;\n\t\t\t\tthis.set({objcache: new ObjCollection(), objlist: [], files : new FileCollection() });\n\t\t\t\tthis.options = _(this.default_options).chain().clone().extend(options || {}).value();\n\t\t\t\tthis.set_up_websocket();\n\t\t\t\tthis._update_queue = {};\n\t\t\t\tthis._delete_queue = {};\n\t\t\t\tthis._fetching_queue = {};\n\t\t\t\tthis.on('update-from-master', function() {\n\t\t\t\t\t// u.log(\"UPDATE FROM MASTER >> flushing \");\n\t\t\t\t\tthis_._flush_update_queue();\n\t\t\t\t\tthis_._flush_delete_queue();\n\t\t\t\t});\n\t\t\t},\n\t\t\t/// <string> fid file id\n\t\t\t/// Tries to get a file with given id. If it doesn't exist, a file with that name is created.\n\t\t\t/// @return <File> the file\n\t\t\tget_or_create_file:function(fid) {\n\t\t\t\tvar files = this.get('files');\n\t\t\t\tif (files.get(fid) === undefined) {\n\t\t\t\t\tfiles.add(new File({\"@id\": fid}, { box: this }));\n\t\t\t\t}\n\t\t\t\treturn files.get(fid);\n\t\t\t},\n\t\t\tset_up_websocket:function() {\n\t\t\t\tvar this_ = this, server_host = this.store.get('server_host');\n\t\t\t\tif (! this.get_use_websockets() ) { return; }\n\t\t\t\tthis.on('new-token', function(token) {\n\t\t\t\t\tvar ws = this_._ws;\n\t\t\t\t\tif (ws) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tws.close();\n\t\t\t\t\t\t\tdelete this_._ws;\n\t\t\t\t\t\t} catch(e) { u.error(); }\n\t\t\t\t\t}\n\t\t\t\t\tvar protocol = (document.location.protocol === 'https:') ? 'wss:/' : 'ws:/';\n\t\t\t\t\tvar ws_url = [protocol,server_host,'ws'].join('/');\n\t\t\t\t\tws = new WebSocket(ws_url);\n\t\t\t\t\tws.onmessage = function(evt) {\n\t\t\t\t\t\tu.debug('websocket :: incoming a message ', evt.data.toString().substring(0,190));\n\t\t\t\t\t\tvar pdata = JSON.parse(evt.data);\n\t\t\t\t\t\tif (pdata.action === 'diff') {\n\t\t\t\t\t\t\tthis_._diff_update(pdata.data)\n\t\t\t\t\t\t\t\t.then(function() {\n\t\t\t\t\t\t\t\t\tthis_.trigger('update-from-master', this_._get_version());\n\t\t\t\t\t\t\t\t}).fail(function(err) {\n\t\t\t\t\t\t\t\t\tu.error(err); /*  u.log('done diffing '); */\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tws.onopen = function() {\n\t\t\t\t\t\tvar data = WS_MESSAGES_SEND.auth(this_.get('token'));\n\t\t\t\t\t\tws.send(data);\n\t\t\t\t\t\tdata = WS_MESSAGES_SEND.diff();\n\t\t\t\t\t\tws.send(data);\n\t\t\t\t\t\tthis_._ws = ws;\n\t\t\t\t\t\tthis_.trigger('ws-connect');\n\t\t\t\t\t};\n\t\t\t\t\tws.onclose = function(evt) {\n\t\t\t\t\t\t// what do we do now?!\n\t\t\t\t\t\tu.error('websocket closed -- ');\n\t\t\t\t\t\t// TODO\n\t\t\t\t\t\tvar interval;\n\t\t\t\t\t\tinterval = setInterval(function() {\n\t\t\t\t\t\t\tthis_.store.reconnect().then(function() {\n\t\t\t\t\t\t\t\tthis_.get_token().then(function() {\n\t\t\t\t\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},1000);\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t},\n\t\t\tget_use_websockets:function() { return this.options.use_websockets; },\n\t\t\tget_cache_size:function(i) { return this._objcache().length; },\n\t\t\tget_obj_ids:function() { return this._objlist().slice(); },\n\t\t\t_objcache:function() { return this.attributes.objcache; },\n\t\t\t_objlist:function() { return this.attributes.objlist !== undefined ? this.attributes.objlist : []; },\n\t\t\t_set_objlist:function(ol) { return this.set({objlist:ol.slice()}); },\n\t\t\t_get_cached_token:function() { return this.get(\"token\"); },\n\t\t\t_set_token:function(token) { this.set(\"token\", token);\t},\n\t\t\t_set_version:function(v) { this.set(\"version\", v);\t},\n\t\t\t_get_version:function(v) { return this.get(\"version\"); },\n\t\t\tget_token:function() {\n\t\t\t\t// utils.debug('>> get_token ', ' id: ',this.id, ' cid: ',this.cid);\n\t\t\t\t// try { throw new Error(''); } catch(e) { console.error(e); }\n\t\t\t\tvar this_ = this, d = u.deferred();\n\t\t\t\tthis._ajax('POST', 'auth/get_token', { app: this.store.get('app') })\n\t\t\t\t\t.then(function(data) {\n\t\t\t\t\t\tconsole.log('setting token ', data.token);\n\t\t\t\t\t\tthis_._set_token( data.token );\n\t\t\t\t\t\tthis_.trigger('new-token', data.token);\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tget_id:function() { return this.id || this.cid;\t},\n\t\t\t_ajax:function(method, path, data) {\n\t\t\t\tdata = _(_(data||{}).clone()).extend({box: this.id || this.cid, token:this.get('token')});\n\t\t\t\treturn this.store._ajax(method, path, data);\n\t\t\t},\n\t\t\tput_file:function(id,filedata,contenttype) {\n\t\t\t\t// creates a File object and hands it back in the resolve\n\t\t\t\tcontenttype = contenttype || filedata.type;\n\t\t\t\tvar d = u.deferred(), this_ = this, newFile = this.get_or_create_file(id);\n\t\t\t\tnewFile.set({\"content-type\": contenttype});\n\t\t\t\tthis._do_put_file(id,filedata,contenttype).then(function(){\n\t\t\t\t\tu.debug('image put success ');\n\t\t\t\t\td.resolve(newFile);\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tif (err.status === 409) {\n\t\t\t\t\t\tvar cb = function() {\n\t\t\t\t\t\t\tthis_.off('update-from-master', cb, newFile);\n\t\t\t\t\t\t\tthis_._put_file(id, filedata, contenttype).then(d.resolve).fail(d.reject);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis_.on('update-from-master', cb, newFile);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu.error('error putting, dammit ', err);\n\t\t\t\t\t\td.reject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_do_put_file:function(id,file,contenttype) {\n\t\t\t\t// now uses relative url scheme '//blah:port/path';\n\t\t\t\t// all files must be PUT into boxname/files\n\t\t\t\t// here the parameters are get encoded\n\t\t\t\t// // 'http://' + this.store.get('server_host') + \"/\" +  boxid + \"/\" + 'files',\n\t\t\t\tvar boxid = this.id || this.cid,\n\t\t\t\tbase_url = ['/', this.store.get('server_host'), boxid, 'files'].join('/'),\n\t\t\t\toptions = { app: this.store.get('app'), id: id, token:this.get('token'),  box: boxid, version: this._get_version() },\n\t\t\t\toption_params = $.param(options),\n\t\t\t\turl = base_url+\"?\"+option_params,\n\t\t\t\td = u.deferred();\n\t\t\t\tconsole.log(\"PUTTING FILE \", url);\n\t\t\t\tvar ajax_args  = _(_(this.store.ajax_defaults).clone()).extend(\n\t\t\t\t\t{ url: url, method : 'PUT', crossDomain:false, data:file, contentType: contenttype, processData:false }\n\t\t\t\t);\n\t\t\t\treturn $.ajax( ajax_args );\n\t\t\t},\n\t\t\tquery: function(q){\n\t\t\t\t// @TODO ::::::::::::::::::::::::::\n\t\t\t\tu.NotImplementedYet();\n\t\t\t\t// var d = u.deferred();\n\t\t\t\t// this._ajax(this, \"/query\", \"GET\", {\"q\": JSON.stringify(q)})\n\t\t\t\t// \t.then(function(data){\n\t\t\t\t// \t\tconsole.debug(\"query results:\",data);\n\t\t\t\t// \t}).fail(function(data) {\n\t\t\t\t// \t\tconsole.debug(\"fail query\");\n\t\t\t\t// \t});\n\t\t\t\t// return d.promise();\n\t\t\t},\n\t\t\t_diff_update:function(response) {\n\t\t\t\tvar d = u.deferred(), this_ = this, latest_version = response['@to_version'],\n\t\t\t\tadded_ids  = _(response.data.added).keys(),\n\t\t\t\tchanged_ids = _(response.data.changed).keys(),\n\t\t\t\tdeleted_ids = _(response.data.deleted).keys(),\n\t\t\t\tchanged_objs = response.data.changed;\n\n\t\t\t\tu.assert(latest_version !== undefined, 'latest version not provided');\n\t\t\t\tu.assert(added_ids !== undefined, 'added_ids not provided');\n\t\t\t\tu.assert(changed_ids !== undefined, 'changed not provided');\n\t\t\t\tu.assert(deleted_ids !== undefined, 'deleted _ids not provided');\n\n\t\t\t\tif (latest_version <= this_._get_version()) {\n\t\t\t\t\tu.debug('asked to diff update, but already up to date, so just relax!', latest_version, this_._get_version());\n\t\t\t\t\treturn d.resolve();\n\t\t\t\t}\n\t\t\t\tu.debug('setting latest version >> ', latest_version, added_ids, changed_ids, deleted_ids);\n\t\t\t\tthis_._set_version(latest_version);\n\t\t\t\tthis_._update_object_list(undefined, added_ids, deleted_ids);\n\t\t\t\tvar change_dfds = _(changed_objs).map(function(obj, uri) {\n\t\t\t\t\tu.debug(' checking to see if in --- ', uri, this_._objcache().get(uri));\n\t\t\t\t\tu.debug('obj >> ', obj);\n\t\t\t\t\tvar cached_obj = this_._objcache().get(uri), cdfd = u.deferred();\n\t\t\t\t\tif (cached_obj) {\n\t\t\t\t\t\t// { prop : [ {sval1 - @type:\"\"}, {sval2 - @type} ... ]\n\t\t\t\t\t\tvar changed_properties = [];\n\t\t\t\t\t\t// console.log(\"obj deleted \", obj.deleted);\n\t\t\t\t\t\tvar deleted_propval_dfds = _(obj.deleted).map(function(vs, k) {\n\t\t\t\t\t\t\tchanged_properties = _(changed_properties).union([k]);\n\t\t\t\t\t\t\tvar dd = u.deferred();\n\t\t\t\t\t\t\tu.when(vs.map(function(v) {\treturn deserialize_value(v, this_);\t})).then(function(values) {\n\t\t\t\t\t\t\t\tvar new_vals = _(cached_obj.get(k) || []).difference(values);\n\t\t\t\t\t\t\t\t// console.log(\"DESERIALISED deleted values \", values, \" - \", \" new_vals \", new_vals);\n\t\t\t\t\t\t\t\t// window._values = values; window._newvals = new_vals;\n\t\t\t\t\t\t\t\tcached_obj.set(k,new_vals);\n\t\t\t\t\t\t\t\t// semantics - if a property has no value then we delete it\n\t\t\t\t\t\t\t\tif (new_vals.length === 0) { cached_obj.unset(k); }\n\t\t\t\t\t\t\t\tdd.resolve();\n\t\t\t\t\t\t\t}).fail(dd.reject);\n\t\t\t\t\t\t\treturn dd.promise();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tvar added_propval_dfds = _(obj.added).map(function(vs, k) {\n\t\t\t\t\t\t\tchanged_properties = _(changed_properties).union([k]);\n\t\t\t\t\t\t\tvar dd = u.deferred();\n\t\t\t\t\t\t\tu.when(vs.map(function(v) {\treturn deserialize_value(v, this_);\t})).then(function(values) {\n\t\t\t\t\t\t\t\tvar new_vals = (cached_obj.get(k) || []).concat(values);\n\t\t\t\t\t\t\t\tcached_obj.set(k,new_vals);\n\t\t\t\t\t\t\t\tdd.resolve();\n\t\t\t\t\t\t\t}).fail(dd.reject);\n\t\t\t\t\t\t\treturn dd.promise();\n\t\t\t\t\t\t});\n                        var replaced_propval_dfs = _(obj.replaced).map(function(vs, k) {\n                            console.debug(\"Processing replaced property\");\n                            changed_properties = _(changed_properties).union([k]);\n                            var dd = u.deferred();\n                            u.when(vs.map(function(v) { return deserialize_value(v, this_); })).then(function(values) {\n                                var new_vals = values; // this is the difference from added - just replace (by DS)\n                                cached_obj.set(k,new_vals);\n                                dd.resolve();\n                            }).fail(dd.reject);\n                            return dd.promise();\n                        });\n                        u.when(added_propval_dfds.concat(deleted_propval_dfds).concat(replaced_propval_dfs)).then(function() {\n\t\t\t\t\t\t\t// u.debug(\"triggering changed properties \", changed_properties);\n\t\t\t\t\t\t\tchanged_properties.map(function(k) {\n\t\t\t\t\t\t\t\tcached_obj.trigger('change:'+k, (cached_obj.get(k) || []).slice());\n\t\t\t\t\t\t\t\tu.debug(\"trigger! change:\"+k);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcdfd.resolve(cached_obj);\n\t\t\t\t\t\t}).fail(cdfd.reject);\n\t\t\t\t\t\treturn cdfd.promise();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tu.when(change_dfds).then(d.resolve).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_create_model_for_id: function(obj_id){\n\t\t\t\tvar model = new Obj({\"@id\":obj_id}, {box:this});\n\t\t\t\tthis._objcache().add(model);\n\t\t\t\treturn model;\n\t\t\t},\n\t\t\tget_obj:function(objid) {\n\t\t\t\t// get_obj always returns a promise\n\t\t\t\tu.assert(typeof objid === 'string' || typeof objid === 'number', \"objid has to be a number or string\");\n\t\t\t\tvar d = u.deferred(),\n\t\t\t\tcachemodel = this._objcache().get(objid),\n\t\t\t\tfetching_dfd = this._fetching_queue[objid],\n\t\t\t\thasmodel = cachemodel && fetching_dfd === undefined,\n\t\t\t\tthis_ = this;\n\n\t\t\t\tif (hasmodel) {\n\t\t\t\t\tconsole.log('returning cached ', objid);\n\t\t\t\t\td.resolve(cachemodel); return d.promise();\n\t\t\t\t}\n\n\t\t\t\t// check to see if already fetching, then we can tag along\n\t\t\t\tif (fetching_dfd) {\n\t\t\t\t\t// to fix a deadlock condition -\n\t\t\t\t\t// if we fetch someone who loops back to us\n\t\t\t\t\t// then we will never resolve with this code:\n\t\t\t\t\t//\n\t\t\t\t\t// fetching_dfd.then(d.resolve).fail(d.reject);\n\t\t\t\t\t// return d.promise();\n\t\t\t\t\t// --\n\t\t\t\t\t// therefore a fix:\n\t\t\t\t\td.resolve(cachemodel);\n\t\t\t\t\treturn d.promise();\n\t\t\t\t}\n\n\t\t\t\t// if not already fetching then we have to fetch\n\t\t\t\tthis._fetching_queue[objid] = d;\n\t\t\t\tvar model = this_._create_model_for_id(objid);\n\t\t\t\t// if the serve knows about it, then we fetch its definition\n\t\t\t\tconsole.log('objlist ', this._objlist());\n\n\t\t\t\t// old code ::\n\t\t\t\t// if (this._objlist().indexOf(objid) >= 0) {\n\t\t\t\t// \tconsole.log('object exists, going to fetch it ');\n\t\t\t\t// \tmodel.fetch().then(function() {\n\t\t\t\t// \t\td.resolve(model);\n\t\t\t\t// \t\tdelete this_._fetching_queue[objid];\n\t\t\t\t// \t}).fail(d.reject);\n\t\t\t\t// } else {\n\t\t\t\t// \tconsole.log('object doesnt exist, not going to fetch it ');\n\t\t\t\t// \t// otherwise it must be new!\n\t\t\t\t// \tmodel.is_new = true;\n\t\t\t\t// \td.resolve(model);\n\t\t\t\t// }\n\n\t\t\t\tconsole.log('trying to fetch ', objid);\n\t\t\t\tmodel.fetch().then(function() {\n\t\t\t\t\td.resolve(model);\n\t\t\t\t\tdelete this_._fetching_queue[objid];\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tconsole.log('failed.. declaring it new ', objid);\n\t\t\t\t\t// TODO check if 404'd\n\t\t\t\t\tconsole.log('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA err - didnt exist ? ', err);\n\t\t\t\t\tmodel.is_new = true;\n\t\t\t\t\td.resolve(model);\n\t\t\t\t\tdelete this_._fetching_queue[objid];\n\t\t\t\t});\n\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// ----------------------------------------------------\n\t\t\t_update_object_list:function(updated_obj_ids, added, deleted) {\n\t\t\t\tvar current, olds = this._objlist().slice(), this_ = this, news, died;\n\t\t\t\t// u.debug('_update_object_list +', added ? added.length : ' ', '-', deleted ? deleted.length : ' ');\n\t\t\t\t// u.debug('_update_object_list +', added || ' ', deleted || ' ');\n\t\t\t\tif (updated_obj_ids === undefined ) {\n\t\t\t\t\tcurrent = _(olds).chain().union(added).difference(deleted).value();\n\t\t\t\t\tnews = (added || []).slice(); died = (deleted || []).slice();\n\t\t\t\t} else {\n\t\t\t\t\tcurrent = updated_obj_ids.slice();\n\t\t\t\t\tnews = _(current).difference(olds);\n\t\t\t\t\tdied = _(olds).difference(current);\n\t\t\t\t}\n\t\t\t\t// u.debug('old objlist had ', olds.length, ' new has ', current.length, 'news > ', news);\n\t\t\t\tthis._set_objlist(current);\n\t\t\t\tnews.map(function(aid) {\tthis_.trigger('obj-add', aid);\t});\n\t\t\t\tdied.map(function(rid) {\n\t\t\t\t\tthis_.trigger('obj-remove', rid);\n\t\t\t\t\tthis_._objcache().remove(rid);\n\t\t\t\t});\n\t\t\t},\n\t\t\t_is_fetched: function() {\n\t\t\t\treturn this.id !== undefined;\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\t// all fetch really does is retrieve ids!\n\t\t\t\t// new client :: this now _only_ fetches object ids\n\t\t\t\t// return a list of models (each of type Object) to populate a GraphCollection\n\t\t\t\tvar d = u.deferred(), fd = u.deferred(), this_ = this;\n\t\t\t\tif (this._is_fetched()) {\n\t\t\t\t\t// Nope - don't do anything -- we just wait for websockets to update us.\n\t\t\t\t\tfd.resolve();\n\t\t\t\t} else {\n\t\t\t\t\t// otherwise we aren't fetched, so we just do it\n\t\t\t\t\tvar box = this.get_id();\n\t\t\t\t\tthis._ajax(\"GET\",[box,'get_object_ids'].join('/')).then(\n\t\t\t\t\t\tfunction(response){\n\t\t\t\t\t\t\tu.assert(response['@version'] !== undefined, 'no version provided');\n\t\t\t\t\t\t\tthis_.id = this_.get_id(); // sets so that _is_fetched later returns true\n\t\t\t\t\t\t\tthis_._set_version(response['@version']);\n\t\t\t\t\t\t\tthis_._update_object_list(response.ids);\n\t\t\t\t\t\t\tfd.resolve(this_);\n\t\t\t\t\t\t}).fail(fd.reject);\n\t\t\t\t}\n\t\t\t\tfd.then(function() {\n\t\t\t\t\tthis_.trigger('update-from-master', this_._get_version());\n\t\t\t\t\td.resolve(this_);\n\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// -----------------------------------------------\n\t\t\t_check_token_and_fetch : function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (this.get('token') === undefined) {\n\t\t\t\t\tvar d = u.deferred();\n\t\t\t\t\tthis.get_token()\n\t\t\t\t\t\t.then(function() { this_._fetch().then(d.resolve).fail(d.reject);\t})\n\t\t\t\t\t\t.fail(d.reject);\n\t\t\t\t\treturn d.promise();\n\t\t\t\t}\n\t\t\t\treturn this_._fetch();\n\t\t\t},\n\t\t\t_create_box:function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis.store._ajax('POST', 'admin/create_box', { name: this.get_id() } )\n\t\t\t\t\t.then(function() {\n\t\t\t\t\t\tthis_.fetch().then(function() { d.resolve(); }).fail(function(err) { d.reject(err); });\n\t\t\t\t\t}).fail(function(err) { d.reject(err); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tdelete_box:function(boxid) {\n\t\t\t\treturn this.store._ajax('POST','admin/delete_box', { name: boxid } );\n\t\t\t},\n\t\t\t// =============== :: UPDATE ::  ======================\n\t\t\tWHOLE_BOX: \"__UPDATE__WHOLE__BOX__\",\n\t\t\t_add_to_update_queue:function(ids_to_update) {\n\t\t\t\tvar this_ = this, uq = this._update_queue;\n\t\t\t\t// returns the deferreds\n\t\t\t\tids_to_update = ids_to_update === undefined ? [ this.WHOLE_BOX ] : ids_to_update;\n\t\t\t\treturn ids_to_update.map(function(id) {\n\t\t\t\t\tuq[id] = uq[id] || u.deferred();\n\t\t\t\t\treturn uq[id];\n\t\t\t\t});\n\t\t\t},\n\t\t\t_requeue_update:function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (!this._update_timeout) {\n\t\t\t\t\tthis._update_timeout = setTimeout(function() {\n\t\t\t\t\t\tdelete this_._update_timeout;\n\t\t\t\t\t\tthis_._flush_update_queue();\n\t\t\t\t\t}, 300);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_flush_update_queue:function() {\n\t\t\t\tvar this_ = this, uq = this._update_queue, ids_to_update = _(uq).keys();\n\t\t\t\tif (ids_to_update.length === 0) { return ; }\n\t\t\t\tif (this._updating || this._deleting) {\n\t\t\t\t\treturn this._requeue_update();\n\t\t\t\t}\n\n\t\t\t\tthis._update_queue = {};\n\t\t\t\tvar update_arguments = ids_to_update.indexOf(this.WHOLE_BOX) >= 0 ? undefined : ids_to_update;\n\t\t\t\tthis_._updating = true;\n\n\t\t\t\tthis_._do_update(update_arguments).then(function() {\n\t\t\t\t\tdelete this_._updating;\n\t\t\t\t\t// TODO: resolve all of our deferreds now and delete them\n\t\t\t\t\tids_to_update.map(function(id) { uq[id].resolve();\t\t});\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tdelete this_._updating;\n\t\t\t\t\tif (err.status === 409) {\n\t\t\t\t\t\t// add the defferds back in\n\t\t\t\t\t\t_(uq).map(function(d,id) {\n\t\t\t\t\t\t\tif (this_._update_queue[id]) {\n\t\t\t\t\t\t\t\t// someone's already added one back in! let's chain them\n\t\t\t\t\t\t\t\tu.debug('HEYYYYYYYYYYYYYYYYYYYYYY already added in - lets go');\n\t\t\t\t\t\t\t\tthis_._update_queue[id].then(uq[id].resolve).fail(uq[id].reject);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tu.debug('sneaking him back in - lets go');\n\t\t\t\t\t\t\t\tthis_._update_queue[id] = uq[id];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn this_._requeue_update();\n\t\t\t\t\t}\n\t\t\t\t\t// something bad happened, we'd better reject on those deferreds\n\t\t\t\t\tu.error('UPDATE error ', err);\n\t\t\t\t\tids_to_update.map(function(id) { uq[id].reject(err);});\n\t\t\t\t});\n\t\t\t},\n\t\t\t_do_update:function(ids) {\n\t\t\t\t// this actua\n\t\t\t\tconsole.log('box update >> ');\n\t\t\t\tvar d = u.deferred(), version = this.get('version') || 0, this_ = this,\n\t\t\t\tobjs = this._objcache().filter(function(x) { return ids === undefined || ids.indexOf(x.id) >= 0; }),\n\t\t\t\tobj_ids = objs.map(function(x) { return x.id; }),\n\t\t\t\tsobjs = objs.map(function(obj){ return serialize_obj(obj); });\n\t\t\t\tthis._ajax(\"PUT\",  this.get_id() + \"/update\", { version: escape(version), data : JSON.stringify(sobjs)  })\n\t\t\t\t\t.then(function(response) {\n\t\t\t\t\t\tthis_._set_version(response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._update_object_list(undefined, obj_ids, []); // update object list\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tupdate:function(original_ids) {\n\t\t\t\t// this is called by Backbone.save(),\n\t\t\t\tvar dfds = this._add_to_update_queue(original_ids);\n\t\t\t\tthis._flush_update_queue();\n\t\t\t\treturn dfds;\n\t\t\t},\n\t\t\t// =============== :: DELETE ::  ======================\n\t\t\t_add_to_delete_queue:function(ids) {\n\t\t\t\tvar this_ = this, dq = this._delete_queue;\n\t\t\t\treturn ids.map(function(id) {\n\t\t\t\t\tdq[id] = dq[id] || u.deferred();\n\t\t\t\t\treturn dq[id];\n\t\t\t\t});\n\t\t\t},\n\t\t\t_delete_models:function(ids) {\n\t\t\t\tvar dfds =  this._add_to_delete_queue(ids);\n\t\t\t\tthis._flush_delete_queue();\n\t\t\t\treturn dfds;\n\t\t\t},\n\t\t\t_requeue_delete:function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (!this._delete_timeout) {\n\t\t\t\t\tthis._delete_timeout = setTimeout(function() {\n\t\t\t\t\t\tdelete this_._delete_timeout;\n\t\t\t\t\t\tthis_._flush_delete_queue();\n\t\t\t\t\t}, 300);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_flush_delete_queue:function() {\n\t\t\t\tvar this_ = this, dq = this._delete_queue, delete_ids = _(dq).keys();\n\t\t\t\tif (delete_ids.length === 0) { return ; }\n\t\t\t\tif (this._deleting || this._updating) { return this._requeue_delete();  }\n\t\t\t\tthis_._deleting = true;\n\t\t\t\tthis_._do_delete(delete_ids).then(function() {\n\t\t\t\t\tdelete this_._deleting;\n\t\t\t\t\tdelete_ids.map(function(id) {\n\t\t\t\t\t\tdq[id].resolve(); delete dq[id];\n\t\t\t\t\t});\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tdelete this_._deleting;\n\t\t\t\t\tif (err.status === 409) { this_._requeue_delete();\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t_do_delete:function(m_ids) {\n\t\t\t\tvar version = this.get('version') || 0, d = u.deferred(), this_ = this;\n\t\t\t\tthis._ajax('DELETE', this.id+'/', { version:version, data: JSON.stringify(m_ids) })\n\t\t\t\t\t.then(function(response) {\n\t\t\t\t\t\tu.debug('DELETE response NEW version > ', response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._set_version(response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._update_object_list(undefined, [], m_ids); // update object list\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// =============== :: SYNC ::  ======================\n\t\t\tsync: function(method, box, options){\n\t\t\t\tswitch(method)\n\t\t\t\t{\n\t\t\t\tcase \"create\": return box._create_box();\n\t\t\t\tcase \"read\": return box._check_token_and_fetch();\n\t\t\t\tcase \"update\": return box.update()[0];  // save whole box?\n\t\t\t\tcase \"delete\": return this.delete_box(this.get_id()) // hook up to destroy\n\t\t\t\t}\n\t\t\t},\n\t\t\ttoString: function() { return 'box:' + this.get_id(); }\n\t\t});\n\n\t\tvar BoxCollection = Backbone.Collection.extend({ model: Box });\n\n\t\tvar Store =  Backbone.Model.extend({\n\t\t\tdefaults: {\n\t\t\t\tserver_host:DEFAULT_HOST,\n\t\t\t\tapp:\"--default-app-id--\"\n\t\t\t},\n\t\t\tajax_defaults : {\n\t\t\t\tjsonp: false, contentType: \"application/json\",\n\t\t\t\txhrFields: { withCredentials: true }\n\t\t\t},\n\n\t\t\t/// @opt <{}> attributes\n\t\t\t/// @opt <{}> options\n\t\t\t/// @constructor\n\t\t\tinitialize: function(attributes, options){\n\t\t\t\tthis.set({boxes : new BoxCollection([], {store: this})});\n\t\t\t},\n\n\t\t\t/// Check that the\n\t\t\tis_same_domain:function() {\n\t\t\t\treturn this.get('server_host').indexOf(document.location.host) >= 0 && (document.location.port === (this.get('server_port') || ''));\n\t\t\t},\n\t\t\tboxes:function() { return this.attributes.boxes;\t},\n\t\t\tget_box: function(boxid) {\n\t\t\t\tvar b = this.boxes().get(boxid) || this._create(boxid);\n\t\t\t\tif (!b._get_cached_token()) {\n\t\t\t\t\treturn b.get_token().pipe(function() {\n\t\t\t\t\t\treturn b.fetch();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn u.dresolve(b);\n\t\t\t},\n\n\n\t\t\t/// @arg <string|number> boxid: the id for the box\n\t\t\t///\n\t\t\t/// @then (<Box> the box)\n\t\t\t/// @fail\n\t\t\t///   (<{ code: 409 }> response) box already exists\n\t\t\t///   (<{ code: -1, error: error obj }> response) other error\n\t\t\t///\n\t\t\t/// Attempts to create a box with the given ID\n\t\t\tcreate_box: function (boxid) {\n\t\t\t\tu.debug('create box ', boxid);\n\t\t\t\tif (this.boxes().get(boxid)) {\n\t\t\t\t\treturn u.dreject({ code: 409, message: 'Box already exists: ' + boxid });\n\t\t\t\t}\n\t\t\t\tvar c = this._create(boxid), this_ = this;\n\t\t\t\tu.debug('creating ', boxid);\n\t\t\t\treturn c.save().pipe(function() { return this_.get_box(boxid); });\n\t\t\t},\n\t\t\tcheck_login:function() {\n\t\t\t\t// checks whether you can connect to the server and who is logged in.\n\t\t\t\t// returns a deferred that gets passed an argument\n\t\t\t\t// { code:200 (server is okay),  is_authenticated:true/false,  user:<username>  }\n\t\t\t\treturn this._ajax('GET', 'auth/whoami');\n\t\t\t},\n\t\t\t// todo: change to _\n\t\t\tget_info:function() { return this._ajax('GET', 'admin/info'); },\n\t\t\tlogin : function(username,password) {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tthis.set({username:username,password:password});\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis._ajax('POST', 'auth/login', { username: username, password: password })\n\t\t\t\t\t.then(function(l) { this_.trigger('login', username); d.resolve(l); })\n\t\t\t\t\t.fail(function(l) { d.reject(l); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\treconnect:function() {\n\t\t\t\treturn this.login(this.get('username'),this.get('password'));\n\t\t\t},\n\t\t\tlogout : function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis._ajax('POST', 'auth/logout')\n\t\t\t\t\t.then(function(l) { this_.trigger('logout'); d.resolve(l); })\n\t\t\t\t\t.fail(function(l) { d.reject(l); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_create:function(boxid) {\n\t\t\t\tvar b = new Box({}, {store: this});\n\t\t\t\tb.cid = boxid;\n\t\t\t\tthis.boxes().add(b);\n\t\t\t\treturn b;\n\t\t\t},\n\t\t\tget_box_list:function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tthis._ajax('GET','admin/list_boxes')\n\t\t\t\t\t.success(function(data) {d.resolve(data.list);})\n\t\t\t\t\t.fail(function(err) { d.reject(err); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\tthrow new Error('dont fetch a store - any more!');\n\t\t\t\t//\n\t\t\t\t// fetches list of boxes\n\t\t\t\t/* - do not do this\n\t\t\t\tvar this_ = this, d = u.deferred();\n\t\t\t\tthis._ajax('GET','admin/list_boxes')\n\t\t\t\t\t.success(function(data) {\n\t\t\t\t\t\tu.when(data.list.map(function(boxid) { return this_.get_box(boxid); })).then(function(boxes) {\n\t\t\t\t\t\t\t// console.log(\"boxes !! \", boxes);\n\t\t\t\t\t\t\tthis_.boxes().reset(boxes);\n\t\t\t\t\t\t\td.resolve(boxes);\n\t\t\t\t\t\t});\n\t\t\t\t\t}).error(function(e) { d.reject(e); });\n\t\t\t\treturn d.promise();\n\t\t\t\t*/\n\t\t\t},\n\t\t\t_ajax:function(method, path, data) {\n\t\t\t\t// now uses relative url scheme '//blah:port/path';\n\t\t\t\tvar url = ['/', this.get('server_host'), path].join('/');\n\t\t\t\tvar default_data = { app: this.get('app') };\n\t\t\t\tvar options = _(_(this.ajax_defaults).clone()).extend(\n\t\t\t\t\t{ url: url, method : method, crossDomain: !this.is_same_domain(), data: _(default_data).extend(data) }\n\t\t\t\t);\n\t\t\t\treturn $.ajax( options ); // returns a deferred\n\t\t\t},\n\t\t\tsync: function(method, model, options){\n\t\t\t\tswitch(method){\n\t\t\t\tcase \"create\": return u.error('store.create() : cannot create a store'); // TODO\n\t\t\t\tcase \"read\"  : return model._fetch();\n\t\t\t\tcase \"update\": return u.error('store.update() : cannot update a store'); // TODO\n\t\t\t\tcase \"delete\": return u.error('store.delete() : cannot delete a store'); // tODO\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tvar exports = {\n\t\t\tsafe_apply:utils.safe_apply,\n\t\t\tu : utils,\n\t\t\tStore:Store,\n\t\t\tObj: Obj,\n\t\t\tFile:File,\n\t\t\tBox: Box,\n\t\t\tstore: new Store(),\n\t\t\tloaded : utils.deferred()\n\t\t};\n\t\twindow.u = utils;\n\n\t\t// do not fetch boxes\n\t\texports.loaded.resolve(exports);\n\t\treturn exports;\n\n\t}).factory('backbone', function(client, utils) {\n\t\t// this manages backbone-angular mystification\n\t\tvar deregfns = [];\n\t\tvar deep_clone_obj = function(o) {\n\t\t\treturn utils.dict(_(o).map(function(v,k) { return [k, v.concat()]; }));\n\t\t};\n\t\tvar scope_bind = function($scope, name, model) {\n\t\t\tutils.assert(model instanceof Backbone.Model, \"tried to bind something that was not a model\");\n\t\t\twindow._m = model;\n\t\t\tvar clone = deep_clone_obj(_(model.attributes));\n\t\t\tutils.safe_apply($scope, function() { $scope[name] = clone;\t});\n\t\t\tvar findchanges = function(old,new_,fn) {\n\t\t\t\tvar changes = [];\n\t\t\t\t_(old).map(function(v,k) {\n\t\t\t\t\tif (v.length !== new_[k].length || _(v).filter(function(vi, i) { return vi != new_[k][i]; }).length) {\n\t\t\t\t\t\tutils.log('pushing changes ', k, new_[k]);\n\t\t\t\t\t\tchanges.push(k);\n\t\t\t\t\t\tif (fn) { fn(k,new_[k].concat()); }\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn changes;\n\t\t\t};\n\t\t\t// angular -> backbone\n\t\t\tvar dereg = $scope.$watch(name, function() {\n\t\t\t\t// do a quick diff --\n\t\t\t\t// first check to make sure that our brave model is still\n\t\t\t\tif ($scope[name] !== clone) { return true; }\n\t\t\t\tfindchanges(model.attributes, clone, function(k,v) {model.set(k,v); });\n\t\t\t}, true);\n\t\t\tderegfns.push([$scope,name,model,dereg]);\n\t\t\t// backbone -> angular\n\t\t\tmodel.on('change', function(data) {\n\t\t\t\tutils.safe_apply($scope, function() {\n\t\t\t\t\tfindchanges(clone, model.attributes, function(k,v) { clone[k] = v;\t});\n\t\t\t\t});\n\t\t\t},$scope);\n\t\t};\n\t\treturn {\n\t\t\tscope_bind: scope_bind,\n\t\t\tscope_unbind:function($scope,name) {\n\t\t\t\tderegfns.map(function(tuple) {\n\t\t\t\t\tvar scope = tuple[0],name = tuple[1],model = tuple[2],dereg = tuple[3];\n\t\t\t\t\tmodel.off('change', null, scope);\n\t\t\t\t\tdereg();\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t});\n","methods":[{"name":"initialize","args":[{"name":"attributes","moreInfo":false,"last":false},{"name":"options","moreInfo":false,"last":true}],"start":10310,"line":286,"description":"","result":"","hasArgs":true,"cls":"~2"},{"name":"get_or_create_file","args":[{"name":"fid","moreInfo":false,"last":true}],"start":11094,"line":305,"description":"<string> fid file id\n/// Tries to get a file with given id. If it doesn't exist, a file with that name is created.","result":"","hasArgs":true,"cls":"~2"},{"name":"set_up_websocket","args":[],"start":11301,"line":312,"description":"","result":"","cls":"~2"},{"name":"onmessage","args":[{"name":"evt","moreInfo":false,"last":true}],"start":11809,"line":327,"description":"","result":"","hasArgs":true,"cls":"~2"},{"name":"onopen","args":[],"start":12258,"line":339,"description":"","result":"","cls":"~2"},{"name":"onclose","args":[{"name":"evt","moreInfo":false,"last":true}],"start":12493,"line":347,"description":"","result":"","hasArgs":true,"cls":"~2"},{"name":"get_use_websockets","args":[],"start":12850,"line":361,"description":"","result":"","cls":"~2"},{"name":"get_cache_size","args":[{"name":"i","moreInfo":false,"last":true}],"start":12924,"line":362,"description":"","result":"","hasArgs":true,"cls":"~2"},{"name":"get_obj_ids","args":[],"start":12991,"line":363,"description":"","result":"","cls":"~2"},{"name":"get_token","args":[],"start":13536,"line":371,"description":"","result":"","cls":"~2"},{"name":"get_id","args":[],"start":14054,"line":384,"description":"","result":"","cls":"~2"},{"name":"put_file","args":[{"name":"id","moreInfo":false,"last":false},{"name":"filedata","moreInfo":false,"last":false},{"name":"contenttype","moreInfo":false,"last":true}],"start":14298,"line":389,"description":"","result":"","hasArgs":true,"cls":"~2"},{"name":"cb","args":[],"start":14777,"line":400,"description":"","result":"","cls":"~2"},{"name":"query","args":[{"name":"q","moreInfo":false,"last":true}],"start":15992,"line":428,"description":"","result":"","hasArgs":true,"cls":"~2"},{"name":"get_obj","args":[{"name":"objid","moreInfo":false,"last":true}],"start":20435,"line":521,"description":"","result":"","hasArgs":true,"cls":"~2"},{"name":"delete_box","args":[{"name":"boxid","moreInfo":false,"last":true}],"start":25367,"line":655,"description":"","result":"","hasArgs":true,"cls":"~2"},{"name":"update","args":[{"name":"original_ids","moreInfo":false,"last":true}],"start":28254,"line":729,"description":"","result":"","hasArgs":true,"cls":"~2"},{"name":"sync","args":[{"name":"method","moreInfo":false,"last":false},{"name":"box","moreInfo":false,"last":false},{"name":"options","moreInfo":false,"last":true}],"start":30190,"line":784,"description":"","result":"","hasArgs":true,"cls":"~2"},{"name":"toString","args":[],"start":30509,"line":793,"description":"","result":"","cls":"~2"}],"properties":[],"match":"Box = Backbone.Model.extend(","name":"Box","start":10189,"extend":"~classes~0","end":30581},{"data":"///\n/// @title INDX\n/// blah\n\n/*global $,_,document,window,console,escape,Backbone,exports,WebSocket */\n/*jslint vars:true, todo:true */\n/*\n\n  indx.js is the JS Client SDK for WebBox WebBox\n  which builds upon Backbone's Model architecture.\n\n  CURRENT TODOs:\n  \t- update only supports updating the entire box\n    - Box.fetch() retrieves _entire box contents_\n\t  ... which is a really bad idea.\n\n  @prerequisites:\n\tjquery 1.8.0 or higher\n\tbackbone.js 0.9.2 or higher\n\tunderscore.js 1.4.2 or higher\n\n  This file is part of INDX\n  Copyright 2012 Max Van Kleek, Daniel Alexander Smith\n  Copyright 2012 University of Southampton\n\n  WebBox is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  WebBox is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with Indx.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n\nangular\n\t.module('indx', ['ui'])\n\t.factory('client',function(utils) {\n\t\tvar u = utils; // to be filled in by dependency\n\t\t// set up our parameters for webbox -\n\t\t// default is that we're loading from an _app_ hosted within\n\t\t// indx.\n\t\tvar DEFAULT_HOST = document.location.host; // which may contain the port\n\t\tvar WS_MESSAGES_SEND = {\n\t\t\tauth: function(token) { return JSON.stringify({action:'auth', token:token}); },\n\t\t\tdiff: function(token) { return JSON.stringify({action:'diff', operation:\"start\"}); }\n\t\t};\n\t\tvar serialize_obj = function(obj) {\n\t\t\tvar uri = obj.id;\n\t\t\tvar out_obj = {};\n\t\t\t$.each(obj.attributes, function(pred, vals){\n\t\t\t\tif (pred[0] === \"_\" || pred[0] === \"@\"){\n\t\t\t\t\t// don't expand @id etc.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar obj_vals = [];\n\t\t\t\tif (!(vals instanceof Array)){\n\t\t\t\t\tvals = [vals];\n\t\t\t\t}\n\t\t\t\t$.each(vals, function(){\n\t\t\t\t\tvar val = this;\n\t\t\t\t\tif (val instanceof File) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.id, \"@type\":\"indx-file\", \"@language\":val.get('content-type')});\n\t\t\t\t\t} else if (val instanceof Obj) {\n\t\t\t\t\t\tobj_vals.push({\"@id\": val.id });\n\t\t\t\t\t} else if (typeof val === \"object\" && (val[\"@value\"] || val[\"@id\"])) {\n\t\t\t\t\t\tobj_vals.push(val); // fully expanded string, e.g. {\"@value\": \"foo\", \"@language\": \"en\" ... }\n\t\t\t\t\t} else if (typeof val === \"string\" || val instanceof String ){\n\t\t\t\t\t\tobj_vals.push({\"@value\": val});\n\t\t\t\t\t} else if (_.isDate(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toISOString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"});\n\t\t\t\t\t} else if (_.isNumber(val) && u.isInteger(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#integer\"});\n\t\t\t\t\t} else if (_.isNumber(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#float\"});\n\t\t\t\t\t} else if (_.isBoolean(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#boolean\"});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu.warn(\"Could not determine type of val \", pred, val);\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString()});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tout_obj[pred] = obj_vals;\n\t\t\t});\n\t\t\tout_obj['@id'] = uri;\n\t\t\treturn out_obj;\n\t\t};\n\n\t\tvar literal_deserializers = {\n\t\t\t'': function(o) { return o['@value']; },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#integer\": function(o) { return parseInt(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#float\": function(o) { return parseFloat(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#double\": function(o) { return parseFloat(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#boolean\": function(o) { return o['@value'].toLowerCase() === 'true'; },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#dateTime\": function(o) { return new Date(Date.parse(o['@value'])); },\n\t\t\t\"indx-file\": function(o,box) {\n\t\t\t\tvar f = box.get_or_create_file(o['@value']);\n\t\t\t\tf.set(\"content-type\", o['@language']);\n\t\t\t\treturn f;\n\t\t\t}\n\t\t};\n\t\tvar deserialize_literal = function(obj, box) {\n\t\t\treturn obj['@value'] !== undefined ? literal_deserializers[ obj['@type'] || '' ](obj, box) : obj;\n\t\t};\n\n\t\tvar deserialize_value = function(s_val, box) {\n\t\t\tvar vd = u.deferred();\n\t\t\t// it's an object, so return that\n\t\t\tif (s_val.hasOwnProperty(\"@id\")) {\n\t\t\t\t// object\n\t\t\t\tbox.get_obj(s_val[\"@id\"]).then(vd.resolve).fail(vd.reject);\n\t\t\t}\n\t\t\telse if (s_val.hasOwnProperty(\"@value\")) {\n\t\t\t\t// literal\n\t\t\t\tvd.resolve(deserialize_literal(s_val, box));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// don't know what it is!\n\t\t\t\tvd.reject('cannot unpack value ', s_val);\n\t\t\t}\n\t\t\treturn vd.promise();\n\t\t};\n\n\t\tvar File =  Backbone.Model.extend({\n\t\t\tidAttribute: \"@id\", // the URI attribute is '@id' in JSON-LD\n\t\t\tinitialize:function(attrs, options) {\n\t\t\t\tu.debug('options >> ', attrs, options );\n\t\t\t\tthis.box = options.box;\n\t\t\t},\n\t\t\tget_id:function() { return this.id;\t},\n\t\t\tget_url:function() {\n\t\t\t\tvar params = {\n\t\t\t\t\tid:this.get_id(),\n\t\t\t\t\tapp:this.box.store.get('app'),\n\t\t\t\t\ttoken:this.box.get('token'),\n\t\t\t\t\tbox:this.box.get_id()\n\t\t\t\t}, url = ['/', this.box.store.get('server_host'), this.box.id, 'files'].join('/') + '?' + $.param(params);\n\t\t\t\t// u.debug(\"IMAGE URL IS \", url, params);\n\t\t\t\treturn url;\n\t\t\t}\n\t\t});\n\n\n\t\t// MAP OF THIS MODUULE :::::::::::::: -----\n\t\t//\n\t\t// An Obj is a single instance, thing in Indx.\n\t\t//\n\t\t// A Box is a model that has an attribute called 'Objs'.\n\t\t// ...  which is a Backbone.Collection of Graph objects.\n\t\t//\n\t\t// A _Store_ represents a single Indx server, which has an\n\t\t//\t attribute called 'boxes' -\n\t\t// ... which is a collection of Box objects\n\t\tvar Obj =  Backbone.Model.extend({\n\t\t\tidAttribute: \"@id\", // the URI attribute is '@id' in JSON-LD\n\t\t\tinitialize:function(attrs, options) {\n\t\t\t\tthis.box = options.box;\n\t\t\t},\n\t\t\t_is_fetched: function() { return this._fetched || false; },\n\t\t\t_set_fetched : function() { this._fetched = true; },\n\t\t\tget_id:function() { return this.id;\t},\n\t\t\t_value_to_array:function(k,v) {\n\t\t\t\tif (k === '@id') { return v; }\n\t\t\t\tif (!_(v).isUndefined() && !_(v).isArray()) {\n\t\t\t\t\treturn [v];\n\t\t\t\t}\n\t\t\t\treturn v;\n\t\t\t},\n\t\t\t_all_values_to_arrays:function(o) {\n\t\t\t\tif (!_(o).isObject()) { utils.error(' not an object', o); return o; }\n\t\t\t\tvar this_ = this;\n\t\t\t\t// ?!?! this isn't doing anything (!!)\n\t\t\t\treturn u.dict(_(o).map(function(v,k) {\n\t\t\t\t\tvar val = this_._value_to_array(k,v);\n\t\t\t\t\tif (u.defined(val)) { return [k,val]; }\n\t\t\t\t\treturn undefined;\n\t\t\t\t}).filter(u.defined));\n\t\t\t},\n\t\t\tset:function(k,v,options) {\n\t\t\t\t// set is tricky because it can be called like\n\t\t\t\t// set('foo',123) or set({foo:123})\n\t\t\t\tif (typeof k === 'string') { v = this._value_to_array(k,v);\t}\n\t\t\t\telse {\tk = this._all_values_to_arrays(k);\t}\n\t\t\t\treturn Backbone.Model.prototype.set.apply(this,[k,v,options]);\n\t\t\t},\n\t\t\tdelete_properties:function(props, silent)  {\n\t\t\t\tvar this_ = this;\n\t\t\t\tprops.map(function(p) { this_.unset(p, silent ? {silent:true} : {}); });\n\t\t\t},\n\t\t\t_deserialise_and_set:function(s_obj, silent) {\n\t\t\t\t// returns a promise\n\t\t\t\tvar this_ = this;\n\t\t\t\tvar dfds = _(s_obj).map(function(vals, key) {\n\t\t\t\t\tvar kd = u.deferred();\n\t\t\t\t\tif (key.indexOf('@') === 0) { return; }\n\t\t\t\t\tvar val_dfds = vals.map(function(val) {\n\t\t\t\t\t\tvar vd = u.deferred();\n\t\t\t\t\t\t// it's an object, so return that\n\t\t\t\t\t\tif (val.hasOwnProperty(\"@id\")) {\n\t\t\t\t\t\t\t// object\n\t\t\t\t\t\t\tthis_.box.get_obj(val[\"@id\"]).then(vd.resolve).fail(vd.reject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (val.hasOwnProperty(\"@value\")) {\n\t\t\t\t\t\t\t// literal\n\t\t\t\t\t\t\tvd.resolve(deserialize_literal(val, this_.box));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// don't know what it is!\n\t\t\t\t\t\t\tvd.reject('cannot unpack value ', val);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn vd.promise();\n\t\t\t\t\t});\n\t\t\t\t\tu.when(val_dfds).then(function(obj_vals) {\n\t\t\t\t\t\t// only update keys that have changed\n\t\t\t\t\t\tvar prev_vals = this_.get(key);\n\t\t\t\t\t\tif ( prev_vals === undefined || obj_vals.length !== prev_vals.length ||\n\t\t\t\t\t\t\t _(obj_vals).difference(prev_vals).length > 0 ||\n\t\t\t\t\t\t\t _(prev_vals).difference(obj_vals).length > 0) {\n\t\t\t\t\t\t\tthis_.set(key, obj_vals, { silent : silent });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkd.resolve();\n\t\t\t\t\t}).fail(kd.reject);\n\t\t\t\t\treturn kd.promise();\n\t\t\t\t}).filter(u.defined);\n\t\t\t\treturn u.when(dfds);\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\tvar this_ = this, fd = u.deferred(), box = this.box.get_id();\n\t\t\t\tthis.box._ajax('GET', box, {'id':this.id}).then(function(response) {\n\t\t\t\t\tthis_._set_fetched(true);\n\t\t\t\t\tvar objdata = response.data;\n\t\t\t\t\tif (objdata['@version'] === undefined) {\n\t\t\t\t\t\t// then the server thinks we've been deleted, so let's just die.\n\t\t\t\t\t\treturn fd.reject(this_.id);\n\t\t\t\t\t\t// old code:\n\t\t\t\t\t\t// according to the server, we're dead.\n\t\t\t\t\t\t// console.log('zombie detected ', this_.id);\n\t\t\t\t\t\t// this_.cid = this_.id;\n\t\t\t\t\t\t// this_.unset({});\n\t\t\t\t\t\t// delete this_.id;\n\t\t\t\t\t\t// fd.resolve();\n\t\t\t\t\t\t// return;\n\t\t\t\t\t}\n\t\t\t\t\t// we are at current known version as far as we know\n\t\t\t\t\tvar obj_save_dfds = _(objdata).map(function(obj,uri) {\n\t\t\t\t\t\t// top level keys - corresponding to box level properties\n\t\t\t\t\t\tif (uri[0] === \"@\") { return; } // ignore \"@id\", \"@version\" etc\n\t\t\t\t\t\t// not one of those, so must be a\n\t\t\t\t\t\t// < uri > : { prop1 .. prop2 ... }\n\t\t\t\t\t\tu.assert(uri === this_.id, 'can only deserialise this object ');\n\t\t\t\t\t\treturn this_._deserialise_and_set(obj);\n\t\t\t\t\t});\n\t\t\t\t\tu.when(obj_save_dfds).then(function(){ fd.resolve(this_); }).fail(fd.reject);\n\t\t\t\t});\n\t\t\t\treturn fd.promise();\n\t\t\t},\n\t\t\tsync: function(method, model, options){\n\t\t\t\tswitch(method){\n\t\t\t\tcase \"create\": return u.assert(false, \"create is never used for Objs\");\n\t\t\t\tcase \"read\"  : return model._fetch();\n\t\t\t\tcase \"update\":\n\t\t\t\t\treturn  model.box.update([model.id])[0];\n\t\t\t\tcase \"delete\":\n\t\t\t\t\treturn this.box._delete_models([this.id])[0];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\n\t\t// Box =================================================\n\t\t// GraphCollection is the list of Objs in a Graph\n\t\tvar ObjCollection = Backbone.Collection.extend({ model: Obj }),\n\t\t\tFileCollection = Backbone.Collection.extend({ model: File });\n\n\t\t// new client: fetch is always lazy, only gets ids, and\n\t\t// lazily get objects as you go\n\t\tvar Box = Backbone.Model.extend({\n\t\t\tidAttribute:\"@id\",\n\t\t\tdefault_options: { use_websockets:true, ws_auto_reconnect:false\t},\n\t\t\tinitialize:function(attributes, options) {\n\t\t\t\tvar this_ = this;\n\t\t\t\tu.assert(options.store, \"no store provided\");\n\t\t\t\tthis.store = options.store;\n\t\t\t\tthis.set({objcache: new ObjCollection(), objlist: [], files : new FileCollection() });\n\t\t\t\tthis.options = _(this.default_options).chain().clone().extend(options || {}).value();\n\t\t\t\tthis.set_up_websocket();\n\t\t\t\tthis._update_queue = {};\n\t\t\t\tthis._delete_queue = {};\n\t\t\t\tthis._fetching_queue = {};\n\t\t\t\tthis.on('update-from-master', function() {\n\t\t\t\t\t// u.log(\"UPDATE FROM MASTER >> flushing \");\n\t\t\t\t\tthis_._flush_update_queue();\n\t\t\t\t\tthis_._flush_delete_queue();\n\t\t\t\t});\n\t\t\t},\n\t\t\t/// <string> fid file id\n\t\t\t/// Tries to get a file with given id. If it doesn't exist, a file with that name is created.\n\t\t\t/// @return <File> the file\n\t\t\tget_or_create_file:function(fid) {\n\t\t\t\tvar files = this.get('files');\n\t\t\t\tif (files.get(fid) === undefined) {\n\t\t\t\t\tfiles.add(new File({\"@id\": fid}, { box: this }));\n\t\t\t\t}\n\t\t\t\treturn files.get(fid);\n\t\t\t},\n\t\t\tset_up_websocket:function() {\n\t\t\t\tvar this_ = this, server_host = this.store.get('server_host');\n\t\t\t\tif (! this.get_use_websockets() ) { return; }\n\t\t\t\tthis.on('new-token', function(token) {\n\t\t\t\t\tvar ws = this_._ws;\n\t\t\t\t\tif (ws) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tws.close();\n\t\t\t\t\t\t\tdelete this_._ws;\n\t\t\t\t\t\t} catch(e) { u.error(); }\n\t\t\t\t\t}\n\t\t\t\t\tvar protocol = (document.location.protocol === 'https:') ? 'wss:/' : 'ws:/';\n\t\t\t\t\tvar ws_url = [protocol,server_host,'ws'].join('/');\n\t\t\t\t\tws = new WebSocket(ws_url);\n\t\t\t\t\tws.onmessage = function(evt) {\n\t\t\t\t\t\tu.debug('websocket :: incoming a message ', evt.data.toString().substring(0,190));\n\t\t\t\t\t\tvar pdata = JSON.parse(evt.data);\n\t\t\t\t\t\tif (pdata.action === 'diff') {\n\t\t\t\t\t\t\tthis_._diff_update(pdata.data)\n\t\t\t\t\t\t\t\t.then(function() {\n\t\t\t\t\t\t\t\t\tthis_.trigger('update-from-master', this_._get_version());\n\t\t\t\t\t\t\t\t}).fail(function(err) {\n\t\t\t\t\t\t\t\t\tu.error(err); /*  u.log('done diffing '); */\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tws.onopen = function() {\n\t\t\t\t\t\tvar data = WS_MESSAGES_SEND.auth(this_.get('token'));\n\t\t\t\t\t\tws.send(data);\n\t\t\t\t\t\tdata = WS_MESSAGES_SEND.diff();\n\t\t\t\t\t\tws.send(data);\n\t\t\t\t\t\tthis_._ws = ws;\n\t\t\t\t\t\tthis_.trigger('ws-connect');\n\t\t\t\t\t};\n\t\t\t\t\tws.onclose = function(evt) {\n\t\t\t\t\t\t// what do we do now?!\n\t\t\t\t\t\tu.error('websocket closed -- ');\n\t\t\t\t\t\t// TODO\n\t\t\t\t\t\tvar interval;\n\t\t\t\t\t\tinterval = setInterval(function() {\n\t\t\t\t\t\t\tthis_.store.reconnect().then(function() {\n\t\t\t\t\t\t\t\tthis_.get_token().then(function() {\n\t\t\t\t\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},1000);\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t},\n\t\t\tget_use_websockets:function() { return this.options.use_websockets; },\n\t\t\tget_cache_size:function(i) { return this._objcache().length; },\n\t\t\tget_obj_ids:function() { return this._objlist().slice(); },\n\t\t\t_objcache:function() { return this.attributes.objcache; },\n\t\t\t_objlist:function() { return this.attributes.objlist !== undefined ? this.attributes.objlist : []; },\n\t\t\t_set_objlist:function(ol) { return this.set({objlist:ol.slice()}); },\n\t\t\t_get_cached_token:function() { return this.get(\"token\"); },\n\t\t\t_set_token:function(token) { this.set(\"token\", token);\t},\n\t\t\t_set_version:function(v) { this.set(\"version\", v);\t},\n\t\t\t_get_version:function(v) { return this.get(\"version\"); },\n\t\t\tget_token:function() {\n\t\t\t\t// utils.debug('>> get_token ', ' id: ',this.id, ' cid: ',this.cid);\n\t\t\t\t// try { throw new Error(''); } catch(e) { console.error(e); }\n\t\t\t\tvar this_ = this, d = u.deferred();\n\t\t\t\tthis._ajax('POST', 'auth/get_token', { app: this.store.get('app') })\n\t\t\t\t\t.then(function(data) {\n\t\t\t\t\t\tconsole.log('setting token ', data.token);\n\t\t\t\t\t\tthis_._set_token( data.token );\n\t\t\t\t\t\tthis_.trigger('new-token', data.token);\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tget_id:function() { return this.id || this.cid;\t},\n\t\t\t_ajax:function(method, path, data) {\n\t\t\t\tdata = _(_(data||{}).clone()).extend({box: this.id || this.cid, token:this.get('token')});\n\t\t\t\treturn this.store._ajax(method, path, data);\n\t\t\t},\n\t\t\tput_file:function(id,filedata,contenttype) {\n\t\t\t\t// creates a File object and hands it back in the resolve\n\t\t\t\tcontenttype = contenttype || filedata.type;\n\t\t\t\tvar d = u.deferred(), this_ = this, newFile = this.get_or_create_file(id);\n\t\t\t\tnewFile.set({\"content-type\": contenttype});\n\t\t\t\tthis._do_put_file(id,filedata,contenttype).then(function(){\n\t\t\t\t\tu.debug('image put success ');\n\t\t\t\t\td.resolve(newFile);\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tif (err.status === 409) {\n\t\t\t\t\t\tvar cb = function() {\n\t\t\t\t\t\t\tthis_.off('update-from-master', cb, newFile);\n\t\t\t\t\t\t\tthis_._put_file(id, filedata, contenttype).then(d.resolve).fail(d.reject);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis_.on('update-from-master', cb, newFile);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu.error('error putting, dammit ', err);\n\t\t\t\t\t\td.reject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_do_put_file:function(id,file,contenttype) {\n\t\t\t\t// now uses relative url scheme '//blah:port/path';\n\t\t\t\t// all files must be PUT into boxname/files\n\t\t\t\t// here the parameters are get encoded\n\t\t\t\t// // 'http://' + this.store.get('server_host') + \"/\" +  boxid + \"/\" + 'files',\n\t\t\t\tvar boxid = this.id || this.cid,\n\t\t\t\tbase_url = ['/', this.store.get('server_host'), boxid, 'files'].join('/'),\n\t\t\t\toptions = { app: this.store.get('app'), id: id, token:this.get('token'),  box: boxid, version: this._get_version() },\n\t\t\t\toption_params = $.param(options),\n\t\t\t\turl = base_url+\"?\"+option_params,\n\t\t\t\td = u.deferred();\n\t\t\t\tconsole.log(\"PUTTING FILE \", url);\n\t\t\t\tvar ajax_args  = _(_(this.store.ajax_defaults).clone()).extend(\n\t\t\t\t\t{ url: url, method : 'PUT', crossDomain:false, data:file, contentType: contenttype, processData:false }\n\t\t\t\t);\n\t\t\t\treturn $.ajax( ajax_args );\n\t\t\t},\n\t\t\tquery: function(q){\n\t\t\t\t// @TODO ::::::::::::::::::::::::::\n\t\t\t\tu.NotImplementedYet();\n\t\t\t\t// var d = u.deferred();\n\t\t\t\t// this._ajax(this, \"/query\", \"GET\", {\"q\": JSON.stringify(q)})\n\t\t\t\t// \t.then(function(data){\n\t\t\t\t// \t\tconsole.debug(\"query results:\",data);\n\t\t\t\t// \t}).fail(function(data) {\n\t\t\t\t// \t\tconsole.debug(\"fail query\");\n\t\t\t\t// \t});\n\t\t\t\t// return d.promise();\n\t\t\t},\n\t\t\t_diff_update:function(response) {\n\t\t\t\tvar d = u.deferred(), this_ = this, latest_version = response['@to_version'],\n\t\t\t\tadded_ids  = _(response.data.added).keys(),\n\t\t\t\tchanged_ids = _(response.data.changed).keys(),\n\t\t\t\tdeleted_ids = _(response.data.deleted).keys(),\n\t\t\t\tchanged_objs = response.data.changed;\n\n\t\t\t\tu.assert(latest_version !== undefined, 'latest version not provided');\n\t\t\t\tu.assert(added_ids !== undefined, 'added_ids not provided');\n\t\t\t\tu.assert(changed_ids !== undefined, 'changed not provided');\n\t\t\t\tu.assert(deleted_ids !== undefined, 'deleted _ids not provided');\n\n\t\t\t\tif (latest_version <= this_._get_version()) {\n\t\t\t\t\tu.debug('asked to diff update, but already up to date, so just relax!', latest_version, this_._get_version());\n\t\t\t\t\treturn d.resolve();\n\t\t\t\t}\n\t\t\t\tu.debug('setting latest version >> ', latest_version, added_ids, changed_ids, deleted_ids);\n\t\t\t\tthis_._set_version(latest_version);\n\t\t\t\tthis_._update_object_list(undefined, added_ids, deleted_ids);\n\t\t\t\tvar change_dfds = _(changed_objs).map(function(obj, uri) {\n\t\t\t\t\tu.debug(' checking to see if in --- ', uri, this_._objcache().get(uri));\n\t\t\t\t\tu.debug('obj >> ', obj);\n\t\t\t\t\tvar cached_obj = this_._objcache().get(uri), cdfd = u.deferred();\n\t\t\t\t\tif (cached_obj) {\n\t\t\t\t\t\t// { prop : [ {sval1 - @type:\"\"}, {sval2 - @type} ... ]\n\t\t\t\t\t\tvar changed_properties = [];\n\t\t\t\t\t\t// console.log(\"obj deleted \", obj.deleted);\n\t\t\t\t\t\tvar deleted_propval_dfds = _(obj.deleted).map(function(vs, k) {\n\t\t\t\t\t\t\tchanged_properties = _(changed_properties).union([k]);\n\t\t\t\t\t\t\tvar dd = u.deferred();\n\t\t\t\t\t\t\tu.when(vs.map(function(v) {\treturn deserialize_value(v, this_);\t})).then(function(values) {\n\t\t\t\t\t\t\t\tvar new_vals = _(cached_obj.get(k) || []).difference(values);\n\t\t\t\t\t\t\t\t// console.log(\"DESERIALISED deleted values \", values, \" - \", \" new_vals \", new_vals);\n\t\t\t\t\t\t\t\t// window._values = values; window._newvals = new_vals;\n\t\t\t\t\t\t\t\tcached_obj.set(k,new_vals);\n\t\t\t\t\t\t\t\t// semantics - if a property has no value then we delete it\n\t\t\t\t\t\t\t\tif (new_vals.length === 0) { cached_obj.unset(k); }\n\t\t\t\t\t\t\t\tdd.resolve();\n\t\t\t\t\t\t\t}).fail(dd.reject);\n\t\t\t\t\t\t\treturn dd.promise();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tvar added_propval_dfds = _(obj.added).map(function(vs, k) {\n\t\t\t\t\t\t\tchanged_properties = _(changed_properties).union([k]);\n\t\t\t\t\t\t\tvar dd = u.deferred();\n\t\t\t\t\t\t\tu.when(vs.map(function(v) {\treturn deserialize_value(v, this_);\t})).then(function(values) {\n\t\t\t\t\t\t\t\tvar new_vals = (cached_obj.get(k) || []).concat(values);\n\t\t\t\t\t\t\t\tcached_obj.set(k,new_vals);\n\t\t\t\t\t\t\t\tdd.resolve();\n\t\t\t\t\t\t\t}).fail(dd.reject);\n\t\t\t\t\t\t\treturn dd.promise();\n\t\t\t\t\t\t});\n                        var replaced_propval_dfs = _(obj.replaced).map(function(vs, k) {\n                            console.debug(\"Processing replaced property\");\n                            changed_properties = _(changed_properties).union([k]);\n                            var dd = u.deferred();\n                            u.when(vs.map(function(v) { return deserialize_value(v, this_); })).then(function(values) {\n                                var new_vals = values; // this is the difference from added - just replace (by DS)\n                                cached_obj.set(k,new_vals);\n                                dd.resolve();\n                            }).fail(dd.reject);\n                            return dd.promise();\n                        });\n                        u.when(added_propval_dfds.concat(deleted_propval_dfds).concat(replaced_propval_dfs)).then(function() {\n\t\t\t\t\t\t\t// u.debug(\"triggering changed properties \", changed_properties);\n\t\t\t\t\t\t\tchanged_properties.map(function(k) {\n\t\t\t\t\t\t\t\tcached_obj.trigger('change:'+k, (cached_obj.get(k) || []).slice());\n\t\t\t\t\t\t\t\tu.debug(\"trigger! change:\"+k);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcdfd.resolve(cached_obj);\n\t\t\t\t\t\t}).fail(cdfd.reject);\n\t\t\t\t\t\treturn cdfd.promise();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tu.when(change_dfds).then(d.resolve).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_create_model_for_id: function(obj_id){\n\t\t\t\tvar model = new Obj({\"@id\":obj_id}, {box:this});\n\t\t\t\tthis._objcache().add(model);\n\t\t\t\treturn model;\n\t\t\t},\n\t\t\tget_obj:function(objid) {\n\t\t\t\t// get_obj always returns a promise\n\t\t\t\tu.assert(typeof objid === 'string' || typeof objid === 'number', \"objid has to be a number or string\");\n\t\t\t\tvar d = u.deferred(),\n\t\t\t\tcachemodel = this._objcache().get(objid),\n\t\t\t\tfetching_dfd = this._fetching_queue[objid],\n\t\t\t\thasmodel = cachemodel && fetching_dfd === undefined,\n\t\t\t\tthis_ = this;\n\n\t\t\t\tif (hasmodel) {\n\t\t\t\t\tconsole.log('returning cached ', objid);\n\t\t\t\t\td.resolve(cachemodel); return d.promise();\n\t\t\t\t}\n\n\t\t\t\t// check to see if already fetching, then we can tag along\n\t\t\t\tif (fetching_dfd) {\n\t\t\t\t\t// to fix a deadlock condition -\n\t\t\t\t\t// if we fetch someone who loops back to us\n\t\t\t\t\t// then we will never resolve with this code:\n\t\t\t\t\t//\n\t\t\t\t\t// fetching_dfd.then(d.resolve).fail(d.reject);\n\t\t\t\t\t// return d.promise();\n\t\t\t\t\t// --\n\t\t\t\t\t// therefore a fix:\n\t\t\t\t\td.resolve(cachemodel);\n\t\t\t\t\treturn d.promise();\n\t\t\t\t}\n\n\t\t\t\t// if not already fetching then we have to fetch\n\t\t\t\tthis._fetching_queue[objid] = d;\n\t\t\t\tvar model = this_._create_model_for_id(objid);\n\t\t\t\t// if the serve knows about it, then we fetch its definition\n\t\t\t\tconsole.log('objlist ', this._objlist());\n\n\t\t\t\t// old code ::\n\t\t\t\t// if (this._objlist().indexOf(objid) >= 0) {\n\t\t\t\t// \tconsole.log('object exists, going to fetch it ');\n\t\t\t\t// \tmodel.fetch().then(function() {\n\t\t\t\t// \t\td.resolve(model);\n\t\t\t\t// \t\tdelete this_._fetching_queue[objid];\n\t\t\t\t// \t}).fail(d.reject);\n\t\t\t\t// } else {\n\t\t\t\t// \tconsole.log('object doesnt exist, not going to fetch it ');\n\t\t\t\t// \t// otherwise it must be new!\n\t\t\t\t// \tmodel.is_new = true;\n\t\t\t\t// \td.resolve(model);\n\t\t\t\t// }\n\n\t\t\t\tconsole.log('trying to fetch ', objid);\n\t\t\t\tmodel.fetch().then(function() {\n\t\t\t\t\td.resolve(model);\n\t\t\t\t\tdelete this_._fetching_queue[objid];\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tconsole.log('failed.. declaring it new ', objid);\n\t\t\t\t\t// TODO check if 404'd\n\t\t\t\t\tconsole.log('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA err - didnt exist ? ', err);\n\t\t\t\t\tmodel.is_new = true;\n\t\t\t\t\td.resolve(model);\n\t\t\t\t\tdelete this_._fetching_queue[objid];\n\t\t\t\t});\n\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// ----------------------------------------------------\n\t\t\t_update_object_list:function(updated_obj_ids, added, deleted) {\n\t\t\t\tvar current, olds = this._objlist().slice(), this_ = this, news, died;\n\t\t\t\t// u.debug('_update_object_list +', added ? added.length : ' ', '-', deleted ? deleted.length : ' ');\n\t\t\t\t// u.debug('_update_object_list +', added || ' ', deleted || ' ');\n\t\t\t\tif (updated_obj_ids === undefined ) {\n\t\t\t\t\tcurrent = _(olds).chain().union(added).difference(deleted).value();\n\t\t\t\t\tnews = (added || []).slice(); died = (deleted || []).slice();\n\t\t\t\t} else {\n\t\t\t\t\tcurrent = updated_obj_ids.slice();\n\t\t\t\t\tnews = _(current).difference(olds);\n\t\t\t\t\tdied = _(olds).difference(current);\n\t\t\t\t}\n\t\t\t\t// u.debug('old objlist had ', olds.length, ' new has ', current.length, 'news > ', news);\n\t\t\t\tthis._set_objlist(current);\n\t\t\t\tnews.map(function(aid) {\tthis_.trigger('obj-add', aid);\t});\n\t\t\t\tdied.map(function(rid) {\n\t\t\t\t\tthis_.trigger('obj-remove', rid);\n\t\t\t\t\tthis_._objcache().remove(rid);\n\t\t\t\t});\n\t\t\t},\n\t\t\t_is_fetched: function() {\n\t\t\t\treturn this.id !== undefined;\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\t// all fetch really does is retrieve ids!\n\t\t\t\t// new client :: this now _only_ fetches object ids\n\t\t\t\t// return a list of models (each of type Object) to populate a GraphCollection\n\t\t\t\tvar d = u.deferred(), fd = u.deferred(), this_ = this;\n\t\t\t\tif (this._is_fetched()) {\n\t\t\t\t\t// Nope - don't do anything -- we just wait for websockets to update us.\n\t\t\t\t\tfd.resolve();\n\t\t\t\t} else {\n\t\t\t\t\t// otherwise we aren't fetched, so we just do it\n\t\t\t\t\tvar box = this.get_id();\n\t\t\t\t\tthis._ajax(\"GET\",[box,'get_object_ids'].join('/')).then(\n\t\t\t\t\t\tfunction(response){\n\t\t\t\t\t\t\tu.assert(response['@version'] !== undefined, 'no version provided');\n\t\t\t\t\t\t\tthis_.id = this_.get_id(); // sets so that _is_fetched later returns true\n\t\t\t\t\t\t\tthis_._set_version(response['@version']);\n\t\t\t\t\t\t\tthis_._update_object_list(response.ids);\n\t\t\t\t\t\t\tfd.resolve(this_);\n\t\t\t\t\t\t}).fail(fd.reject);\n\t\t\t\t}\n\t\t\t\tfd.then(function() {\n\t\t\t\t\tthis_.trigger('update-from-master', this_._get_version());\n\t\t\t\t\td.resolve(this_);\n\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// -----------------------------------------------\n\t\t\t_check_token_and_fetch : function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (this.get('token') === undefined) {\n\t\t\t\t\tvar d = u.deferred();\n\t\t\t\t\tthis.get_token()\n\t\t\t\t\t\t.then(function() { this_._fetch().then(d.resolve).fail(d.reject);\t})\n\t\t\t\t\t\t.fail(d.reject);\n\t\t\t\t\treturn d.promise();\n\t\t\t\t}\n\t\t\t\treturn this_._fetch();\n\t\t\t},\n\t\t\t_create_box:function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis.store._ajax('POST', 'admin/create_box', { name: this.get_id() } )\n\t\t\t\t\t.then(function() {\n\t\t\t\t\t\tthis_.fetch().then(function() { d.resolve(); }).fail(function(err) { d.reject(err); });\n\t\t\t\t\t}).fail(function(err) { d.reject(err); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tdelete_box:function(boxid) {\n\t\t\t\treturn this.store._ajax('POST','admin/delete_box', { name: boxid } );\n\t\t\t},\n\t\t\t// =============== :: UPDATE ::  ======================\n\t\t\tWHOLE_BOX: \"__UPDATE__WHOLE__BOX__\",\n\t\t\t_add_to_update_queue:function(ids_to_update) {\n\t\t\t\tvar this_ = this, uq = this._update_queue;\n\t\t\t\t// returns the deferreds\n\t\t\t\tids_to_update = ids_to_update === undefined ? [ this.WHOLE_BOX ] : ids_to_update;\n\t\t\t\treturn ids_to_update.map(function(id) {\n\t\t\t\t\tuq[id] = uq[id] || u.deferred();\n\t\t\t\t\treturn uq[id];\n\t\t\t\t});\n\t\t\t},\n\t\t\t_requeue_update:function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (!this._update_timeout) {\n\t\t\t\t\tthis._update_timeout = setTimeout(function() {\n\t\t\t\t\t\tdelete this_._update_timeout;\n\t\t\t\t\t\tthis_._flush_update_queue();\n\t\t\t\t\t}, 300);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_flush_update_queue:function() {\n\t\t\t\tvar this_ = this, uq = this._update_queue, ids_to_update = _(uq).keys();\n\t\t\t\tif (ids_to_update.length === 0) { return ; }\n\t\t\t\tif (this._updating || this._deleting) {\n\t\t\t\t\treturn this._requeue_update();\n\t\t\t\t}\n\n\t\t\t\tthis._update_queue = {};\n\t\t\t\tvar update_arguments = ids_to_update.indexOf(this.WHOLE_BOX) >= 0 ? undefined : ids_to_update;\n\t\t\t\tthis_._updating = true;\n\n\t\t\t\tthis_._do_update(update_arguments).then(function() {\n\t\t\t\t\tdelete this_._updating;\n\t\t\t\t\t// TODO: resolve all of our deferreds now and delete them\n\t\t\t\t\tids_to_update.map(function(id) { uq[id].resolve();\t\t});\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tdelete this_._updating;\n\t\t\t\t\tif (err.status === 409) {\n\t\t\t\t\t\t// add the defferds back in\n\t\t\t\t\t\t_(uq).map(function(d,id) {\n\t\t\t\t\t\t\tif (this_._update_queue[id]) {\n\t\t\t\t\t\t\t\t// someone's already added one back in! let's chain them\n\t\t\t\t\t\t\t\tu.debug('HEYYYYYYYYYYYYYYYYYYYYYY already added in - lets go');\n\t\t\t\t\t\t\t\tthis_._update_queue[id].then(uq[id].resolve).fail(uq[id].reject);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tu.debug('sneaking him back in - lets go');\n\t\t\t\t\t\t\t\tthis_._update_queue[id] = uq[id];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn this_._requeue_update();\n\t\t\t\t\t}\n\t\t\t\t\t// something bad happened, we'd better reject on those deferreds\n\t\t\t\t\tu.error('UPDATE error ', err);\n\t\t\t\t\tids_to_update.map(function(id) { uq[id].reject(err);});\n\t\t\t\t});\n\t\t\t},\n\t\t\t_do_update:function(ids) {\n\t\t\t\t// this actua\n\t\t\t\tconsole.log('box update >> ');\n\t\t\t\tvar d = u.deferred(), version = this.get('version') || 0, this_ = this,\n\t\t\t\tobjs = this._objcache().filter(function(x) { return ids === undefined || ids.indexOf(x.id) >= 0; }),\n\t\t\t\tobj_ids = objs.map(function(x) { return x.id; }),\n\t\t\t\tsobjs = objs.map(function(obj){ return serialize_obj(obj); });\n\t\t\t\tthis._ajax(\"PUT\",  this.get_id() + \"/update\", { version: escape(version), data : JSON.stringify(sobjs)  })\n\t\t\t\t\t.then(function(response) {\n\t\t\t\t\t\tthis_._set_version(response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._update_object_list(undefined, obj_ids, []); // update object list\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tupdate:function(original_ids) {\n\t\t\t\t// this is called by Backbone.save(),\n\t\t\t\tvar dfds = this._add_to_update_queue(original_ids);\n\t\t\t\tthis._flush_update_queue();\n\t\t\t\treturn dfds;\n\t\t\t},\n\t\t\t// =============== :: DELETE ::  ======================\n\t\t\t_add_to_delete_queue:function(ids) {\n\t\t\t\tvar this_ = this, dq = this._delete_queue;\n\t\t\t\treturn ids.map(function(id) {\n\t\t\t\t\tdq[id] = dq[id] || u.deferred();\n\t\t\t\t\treturn dq[id];\n\t\t\t\t});\n\t\t\t},\n\t\t\t_delete_models:function(ids) {\n\t\t\t\tvar dfds =  this._add_to_delete_queue(ids);\n\t\t\t\tthis._flush_delete_queue();\n\t\t\t\treturn dfds;\n\t\t\t},\n\t\t\t_requeue_delete:function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (!this._delete_timeout) {\n\t\t\t\t\tthis._delete_timeout = setTimeout(function() {\n\t\t\t\t\t\tdelete this_._delete_timeout;\n\t\t\t\t\t\tthis_._flush_delete_queue();\n\t\t\t\t\t}, 300);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_flush_delete_queue:function() {\n\t\t\t\tvar this_ = this, dq = this._delete_queue, delete_ids = _(dq).keys();\n\t\t\t\tif (delete_ids.length === 0) { return ; }\n\t\t\t\tif (this._deleting || this._updating) { return this._requeue_delete();  }\n\t\t\t\tthis_._deleting = true;\n\t\t\t\tthis_._do_delete(delete_ids).then(function() {\n\t\t\t\t\tdelete this_._deleting;\n\t\t\t\t\tdelete_ids.map(function(id) {\n\t\t\t\t\t\tdq[id].resolve(); delete dq[id];\n\t\t\t\t\t});\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tdelete this_._deleting;\n\t\t\t\t\tif (err.status === 409) { this_._requeue_delete();\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t_do_delete:function(m_ids) {\n\t\t\t\tvar version = this.get('version') || 0, d = u.deferred(), this_ = this;\n\t\t\t\tthis._ajax('DELETE', this.id+'/', { version:version, data: JSON.stringify(m_ids) })\n\t\t\t\t\t.then(function(response) {\n\t\t\t\t\t\tu.debug('DELETE response NEW version > ', response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._set_version(response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._update_object_list(undefined, [], m_ids); // update object list\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// =============== :: SYNC ::  ======================\n\t\t\tsync: function(method, box, options){\n\t\t\t\tswitch(method)\n\t\t\t\t{\n\t\t\t\tcase \"create\": return box._create_box();\n\t\t\t\tcase \"read\": return box._check_token_and_fetch();\n\t\t\t\tcase \"update\": return box.update()[0];  // save whole box?\n\t\t\t\tcase \"delete\": return this.delete_box(this.get_id()) // hook up to destroy\n\t\t\t\t}\n\t\t\t},\n\t\t\ttoString: function() { return 'box:' + this.get_id(); }\n\t\t});\n\n\t\tvar BoxCollection = Backbone.Collection.extend({ model: Box });\n\n\t\tvar Store =  Backbone.Model.extend({\n\t\t\tdefaults: {\n\t\t\t\tserver_host:DEFAULT_HOST,\n\t\t\t\tapp:\"--default-app-id--\"\n\t\t\t},\n\t\t\tajax_defaults : {\n\t\t\t\tjsonp: false, contentType: \"application/json\",\n\t\t\t\txhrFields: { withCredentials: true }\n\t\t\t},\n\n\t\t\t/// @opt <{}> attributes\n\t\t\t/// @opt <{}> options\n\t\t\t/// @constructor\n\t\t\tinitialize: function(attributes, options){\n\t\t\t\tthis.set({boxes : new BoxCollection([], {store: this})});\n\t\t\t},\n\n\t\t\t/// Check that the\n\t\t\tis_same_domain:function() {\n\t\t\t\treturn this.get('server_host').indexOf(document.location.host) >= 0 && (document.location.port === (this.get('server_port') || ''));\n\t\t\t},\n\t\t\tboxes:function() { return this.attributes.boxes;\t},\n\t\t\tget_box: function(boxid) {\n\t\t\t\tvar b = this.boxes().get(boxid) || this._create(boxid);\n\t\t\t\tif (!b._get_cached_token()) {\n\t\t\t\t\treturn b.get_token().pipe(function() {\n\t\t\t\t\t\treturn b.fetch();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn u.dresolve(b);\n\t\t\t},\n\n\n\t\t\t/// @arg <string|number> boxid: the id for the box\n\t\t\t///\n\t\t\t/// @then (<Box> the box)\n\t\t\t/// @fail\n\t\t\t///   (<{ code: 409 }> response) box already exists\n\t\t\t///   (<{ code: -1, error: error obj }> response) other error\n\t\t\t///\n\t\t\t/// Attempts to create a box with the given ID\n\t\t\tcreate_box: function (boxid) {\n\t\t\t\tu.debug('create box ', boxid);\n\t\t\t\tif (this.boxes().get(boxid)) {\n\t\t\t\t\treturn u.dreject({ code: 409, message: 'Box already exists: ' + boxid });\n\t\t\t\t}\n\t\t\t\tvar c = this._create(boxid), this_ = this;\n\t\t\t\tu.debug('creating ', boxid);\n\t\t\t\treturn c.save().pipe(function() { return this_.get_box(boxid); });\n\t\t\t},\n\t\t\tcheck_login:function() {\n\t\t\t\t// checks whether you can connect to the server and who is logged in.\n\t\t\t\t// returns a deferred that gets passed an argument\n\t\t\t\t// { code:200 (server is okay),  is_authenticated:true/false,  user:<username>  }\n\t\t\t\treturn this._ajax('GET', 'auth/whoami');\n\t\t\t},\n\t\t\t// todo: change to _\n\t\t\tget_info:function() { return this._ajax('GET', 'admin/info'); },\n\t\t\tlogin : function(username,password) {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tthis.set({username:username,password:password});\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis._ajax('POST', 'auth/login', { username: username, password: password })\n\t\t\t\t\t.then(function(l) { this_.trigger('login', username); d.resolve(l); })\n\t\t\t\t\t.fail(function(l) { d.reject(l); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\treconnect:function() {\n\t\t\t\treturn this.login(this.get('username'),this.get('password'));\n\t\t\t},\n\t\t\tlogout : function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis._ajax('POST', 'auth/logout')\n\t\t\t\t\t.then(function(l) { this_.trigger('logout'); d.resolve(l); })\n\t\t\t\t\t.fail(function(l) { d.reject(l); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_create:function(boxid) {\n\t\t\t\tvar b = new Box({}, {store: this});\n\t\t\t\tb.cid = boxid;\n\t\t\t\tthis.boxes().add(b);\n\t\t\t\treturn b;\n\t\t\t},\n\t\t\tget_box_list:function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tthis._ajax('GET','admin/list_boxes')\n\t\t\t\t\t.success(function(data) {d.resolve(data.list);})\n\t\t\t\t\t.fail(function(err) { d.reject(err); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\tthrow new Error('dont fetch a store - any more!');\n\t\t\t\t//\n\t\t\t\t// fetches list of boxes\n\t\t\t\t/* - do not do this\n\t\t\t\tvar this_ = this, d = u.deferred();\n\t\t\t\tthis._ajax('GET','admin/list_boxes')\n\t\t\t\t\t.success(function(data) {\n\t\t\t\t\t\tu.when(data.list.map(function(boxid) { return this_.get_box(boxid); })).then(function(boxes) {\n\t\t\t\t\t\t\t// console.log(\"boxes !! \", boxes);\n\t\t\t\t\t\t\tthis_.boxes().reset(boxes);\n\t\t\t\t\t\t\td.resolve(boxes);\n\t\t\t\t\t\t});\n\t\t\t\t\t}).error(function(e) { d.reject(e); });\n\t\t\t\treturn d.promise();\n\t\t\t\t*/\n\t\t\t},\n\t\t\t_ajax:function(method, path, data) {\n\t\t\t\t// now uses relative url scheme '//blah:port/path';\n\t\t\t\tvar url = ['/', this.get('server_host'), path].join('/');\n\t\t\t\tvar default_data = { app: this.get('app') };\n\t\t\t\tvar options = _(_(this.ajax_defaults).clone()).extend(\n\t\t\t\t\t{ url: url, method : method, crossDomain: !this.is_same_domain(), data: _(default_data).extend(data) }\n\t\t\t\t);\n\t\t\t\treturn $.ajax( options ); // returns a deferred\n\t\t\t},\n\t\t\tsync: function(method, model, options){\n\t\t\t\tswitch(method){\n\t\t\t\tcase \"create\": return u.error('store.create() : cannot create a store'); // TODO\n\t\t\t\tcase \"read\"  : return model._fetch();\n\t\t\t\tcase \"update\": return u.error('store.update() : cannot update a store'); // TODO\n\t\t\t\tcase \"delete\": return u.error('store.delete() : cannot delete a store'); // tODO\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tvar exports = {\n\t\t\tsafe_apply:utils.safe_apply,\n\t\t\tu : utils,\n\t\t\tStore:Store,\n\t\t\tObj: Obj,\n\t\t\tFile:File,\n\t\t\tBox: Box,\n\t\t\tstore: new Store(),\n\t\t\tloaded : utils.deferred()\n\t\t};\n\t\twindow.u = utils;\n\n\t\t// do not fetch boxes\n\t\texports.loaded.resolve(exports);\n\t\treturn exports;\n\n\t}).factory('backbone', function(client, utils) {\n\t\t// this manages backbone-angular mystification\n\t\tvar deregfns = [];\n\t\tvar deep_clone_obj = function(o) {\n\t\t\treturn utils.dict(_(o).map(function(v,k) { return [k, v.concat()]; }));\n\t\t};\n\t\tvar scope_bind = function($scope, name, model) {\n\t\t\tutils.assert(model instanceof Backbone.Model, \"tried to bind something that was not a model\");\n\t\t\twindow._m = model;\n\t\t\tvar clone = deep_clone_obj(_(model.attributes));\n\t\t\tutils.safe_apply($scope, function() { $scope[name] = clone;\t});\n\t\t\tvar findchanges = function(old,new_,fn) {\n\t\t\t\tvar changes = [];\n\t\t\t\t_(old).map(function(v,k) {\n\t\t\t\t\tif (v.length !== new_[k].length || _(v).filter(function(vi, i) { return vi != new_[k][i]; }).length) {\n\t\t\t\t\t\tutils.log('pushing changes ', k, new_[k]);\n\t\t\t\t\t\tchanges.push(k);\n\t\t\t\t\t\tif (fn) { fn(k,new_[k].concat()); }\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn changes;\n\t\t\t};\n\t\t\t// angular -> backbone\n\t\t\tvar dereg = $scope.$watch(name, function() {\n\t\t\t\t// do a quick diff --\n\t\t\t\t// first check to make sure that our brave model is still\n\t\t\t\tif ($scope[name] !== clone) { return true; }\n\t\t\t\tfindchanges(model.attributes, clone, function(k,v) {model.set(k,v); });\n\t\t\t}, true);\n\t\t\tderegfns.push([$scope,name,model,dereg]);\n\t\t\t// backbone -> angular\n\t\t\tmodel.on('change', function(data) {\n\t\t\t\tutils.safe_apply($scope, function() {\n\t\t\t\t\tfindchanges(clone, model.attributes, function(k,v) { clone[k] = v;\t});\n\t\t\t\t});\n\t\t\t},$scope);\n\t\t};\n\t\treturn {\n\t\t\tscope_bind: scope_bind,\n\t\t\tscope_unbind:function($scope,name) {\n\t\t\t\tderegfns.map(function(tuple) {\n\t\t\t\t\tvar scope = tuple[0],name = tuple[1],model = tuple[2],dereg = tuple[3];\n\t\t\t\t\tmodel.off('change', null, scope);\n\t\t\t\t\tdereg();\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t});\n","methods":[{"name":"initialize","args":[{"mode":{"optional":true},"types":[{"type":"{}","last":true}],"name":"options","comment":"","moreInfo":true,"last":false,"hasTypes":true},{"mode":{"optional":true},"types":[{"type":"{}","last":true}],"name":"attributes","comment":"","moreInfo":true,"last":true,"hasTypes":true}],"start":30954,"line":811,"description":"","result":"","hasArgs":true,"cls":"~3"},{"name":"is_same_domain","args":[],"start":31091,"line":816,"description":"","result":"","cls":"~3"},{"name":"boxes","args":[],"start":31265,"line":819,"description":"","result":"","cls":"~3"},{"name":"get_box","args":[{"name":"boxid","moreInfo":false,"last":true}],"start":31320,"line":820,"description":"","result":"","hasArgs":true,"cls":"~3"},{"name":"create_box","args":[{"mode":{"mandatory":true},"types":[{"type":"number","last":false},{"type":"string","last":true}],"name":"boxid","comment":"the id for the box","moreInfo":true,"last":true,"hasTypes":true}],"start":31841,"line":839,"description":"","result":{"async":{"then":{"comment":"","args":[{"type":[{"type":"Box"}],"comment":"the box"}]},"fail":{"cases":[{"args":[{"type":[{"type":"{ code: -1, error: error obj }"}],"comment":"response"}],"comment":"other error"},{"args":[{"type":[{"type":"{ code: 409 }"}],"comment":"response"}],"comment":"box already exists"}]}}},"hasArgs":true,"cls":"~3"},{"name":"check_login","args":[],"start":32187,"line":848,"description":"","result":"","cls":"~3"},{"name":"get_info","args":[],"start":32505,"line":855,"description":"","result":"","cls":"~3"},{"name":"login","args":[{"name":"username","moreInfo":false,"last":false},{"name":"password","moreInfo":false,"last":true}],"start":32573,"line":856,"description":"","result":"","hasArgs":true,"cls":"~3"},{"name":"reconnect","args":[],"start":32944,"line":865,"description":"","result":"","cls":"~3"},{"name":"logout","args":[],"start":33042,"line":868,"description":"","result":"","cls":"~3"},{"name":"get_box_list","args":[],"start":33425,"line":882,"description":"","result":"","cls":"~3"},{"name":"sync","args":[{"name":"method","moreInfo":false,"last":false},{"name":"model","moreInfo":false,"last":false},{"name":"options","moreInfo":false,"last":true}],"start":34636,"line":915,"description":"","result":"","hasArgs":true,"cls":"~3"},{"name":"deep_clone_obj","args":[{"name":"o","moreInfo":false,"last":true}],"start":35415,"line":944,"description":"","result":"","hasArgs":true,"cls":"~3"},{"name":"scope_bind","args":[{"name":"$scope","moreInfo":false,"last":false},{"name":"name","moreInfo":false,"last":false},{"name":"model","moreInfo":false,"last":true}],"start":35532,"line":947,"description":"","result":"","hasArgs":true,"cls":"~3"},{"name":"findchanges","args":[{"name":"old","moreInfo":false,"last":false},{"name":"new_","moreInfo":false,"last":false},{"name":"fn","moreInfo":false,"last":true}],"start":35823,"line":952,"description":"","result":"","hasArgs":true,"cls":"~3"},{"name":"scope_unbind","args":[{"name":"$scope","moreInfo":false,"last":false},{"name":"name","moreInfo":false,"last":true}],"start":36770,"line":979,"description":"","result":"","hasArgs":true,"cls":"~3"}],"properties":[],"match":"Store =  Backbone.Model.extend(","name":"Store","start":30649,"extend":"~classes~0","end":36998},{"data":"///\n/// @title INDX\n/// blah\n\n/*global $,_,document,window,console,escape,Backbone,exports,WebSocket */\n/*jslint vars:true, todo:true */\n/*\n\n  indx.js is the JS Client SDK for WebBox WebBox\n  which builds upon Backbone's Model architecture.\n\n  CURRENT TODOs:\n  \t- update only supports updating the entire box\n    - Box.fetch() retrieves _entire box contents_\n\t  ... which is a really bad idea.\n\n  @prerequisites:\n\tjquery 1.8.0 or higher\n\tbackbone.js 0.9.2 or higher\n\tunderscore.js 1.4.2 or higher\n\n  This file is part of INDX\n  Copyright 2012 Max Van Kleek, Daniel Alexander Smith\n  Copyright 2012 University of Southampton\n\n  WebBox is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  WebBox is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with Indx.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n\nangular\n\t.module('indx', ['ui'])\n\t.factory('client',function(utils) {\n\t\tvar u = utils; // to be filled in by dependency\n\t\t// set up our parameters for webbox -\n\t\t// default is that we're loading from an _app_ hosted within\n\t\t// indx.\n\t\tvar DEFAULT_HOST = document.location.host; // which may contain the port\n\t\tvar WS_MESSAGES_SEND = {\n\t\t\tauth: function(token) { return JSON.stringify({action:'auth', token:token}); },\n\t\t\tdiff: function(token) { return JSON.stringify({action:'diff', operation:\"start\"}); }\n\t\t};\n\t\tvar serialize_obj = function(obj) {\n\t\t\tvar uri = obj.id;\n\t\t\tvar out_obj = {};\n\t\t\t$.each(obj.attributes, function(pred, vals){\n\t\t\t\tif (pred[0] === \"_\" || pred[0] === \"@\"){\n\t\t\t\t\t// don't expand @id etc.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar obj_vals = [];\n\t\t\t\tif (!(vals instanceof Array)){\n\t\t\t\t\tvals = [vals];\n\t\t\t\t}\n\t\t\t\t$.each(vals, function(){\n\t\t\t\t\tvar val = this;\n\t\t\t\t\tif (val instanceof File) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.id, \"@type\":\"indx-file\", \"@language\":val.get('content-type')});\n\t\t\t\t\t} else if (val instanceof Obj) {\n\t\t\t\t\t\tobj_vals.push({\"@id\": val.id });\n\t\t\t\t\t} else if (typeof val === \"object\" && (val[\"@value\"] || val[\"@id\"])) {\n\t\t\t\t\t\tobj_vals.push(val); // fully expanded string, e.g. {\"@value\": \"foo\", \"@language\": \"en\" ... }\n\t\t\t\t\t} else if (typeof val === \"string\" || val instanceof String ){\n\t\t\t\t\t\tobj_vals.push({\"@value\": val});\n\t\t\t\t\t} else if (_.isDate(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toISOString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"});\n\t\t\t\t\t} else if (_.isNumber(val) && u.isInteger(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#integer\"});\n\t\t\t\t\t} else if (_.isNumber(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#float\"});\n\t\t\t\t\t} else if (_.isBoolean(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#boolean\"});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu.warn(\"Could not determine type of val \", pred, val);\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString()});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tout_obj[pred] = obj_vals;\n\t\t\t});\n\t\t\tout_obj['@id'] = uri;\n\t\t\treturn out_obj;\n\t\t};\n\n\t\tvar literal_deserializers = {\n\t\t\t'': function(o) { return o['@value']; },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#integer\": function(o) { return parseInt(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#float\": function(o) { return parseFloat(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#double\": function(o) { return parseFloat(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#boolean\": function(o) { return o['@value'].toLowerCase() === 'true'; },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#dateTime\": function(o) { return new Date(Date.parse(o['@value'])); },\n\t\t\t\"indx-file\": function(o,box) {\n\t\t\t\tvar f = box.get_or_create_file(o['@value']);\n\t\t\t\tf.set(\"content-type\", o['@language']);\n\t\t\t\treturn f;\n\t\t\t}\n\t\t};\n\t\tvar deserialize_literal = function(obj, box) {\n\t\t\treturn obj['@value'] !== undefined ? literal_deserializers[ obj['@type'] || '' ](obj, box) : obj;\n\t\t};\n\n\t\tvar deserialize_value = function(s_val, box) {\n\t\t\tvar vd = u.deferred();\n\t\t\t// it's an object, so return that\n\t\t\tif (s_val.hasOwnProperty(\"@id\")) {\n\t\t\t\t// object\n\t\t\t\tbox.get_obj(s_val[\"@id\"]).then(vd.resolve).fail(vd.reject);\n\t\t\t}\n\t\t\telse if (s_val.hasOwnProperty(\"@value\")) {\n\t\t\t\t// literal\n\t\t\t\tvd.resolve(deserialize_literal(s_val, box));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// don't know what it is!\n\t\t\t\tvd.reject('cannot unpack value ', s_val);\n\t\t\t}\n\t\t\treturn vd.promise();\n\t\t};\n\n\t\tvar File =  Backbone.Model.extend({\n\t\t\tidAttribute: \"@id\", // the URI attribute is '@id' in JSON-LD\n\t\t\tinitialize:function(attrs, options) {\n\t\t\t\tu.debug('options >> ', attrs, options );\n\t\t\t\tthis.box = options.box;\n\t\t\t},\n\t\t\tget_id:function() { return this.id;\t},\n\t\t\tget_url:function() {\n\t\t\t\tvar params = {\n\t\t\t\t\tid:this.get_id(),\n\t\t\t\t\tapp:this.box.store.get('app'),\n\t\t\t\t\ttoken:this.box.get('token'),\n\t\t\t\t\tbox:this.box.get_id()\n\t\t\t\t}, url = ['/', this.box.store.get('server_host'), this.box.id, 'files'].join('/') + '?' + $.param(params);\n\t\t\t\t// u.debug(\"IMAGE URL IS \", url, params);\n\t\t\t\treturn url;\n\t\t\t}\n\t\t});\n\n\n\t\t// MAP OF THIS MODUULE :::::::::::::: -----\n\t\t//\n\t\t// An Obj is a single instance, thing in Indx.\n\t\t//\n\t\t// A Box is a model that has an attribute called 'Objs'.\n\t\t// ...  which is a Backbone.Collection of Graph objects.\n\t\t//\n\t\t// A _Store_ represents a single Indx server, which has an\n\t\t//\t attribute called 'boxes' -\n\t\t// ... which is a collection of Box objects\n\t\tvar Obj =  Backbone.Model.extend({\n\t\t\tidAttribute: \"@id\", // the URI attribute is '@id' in JSON-LD\n\t\t\tinitialize:function(attrs, options) {\n\t\t\t\tthis.box = options.box;\n\t\t\t},\n\t\t\t_is_fetched: function() { return this._fetched || false; },\n\t\t\t_set_fetched : function() { this._fetched = true; },\n\t\t\tget_id:function() { return this.id;\t},\n\t\t\t_value_to_array:function(k,v) {\n\t\t\t\tif (k === '@id') { return v; }\n\t\t\t\tif (!_(v).isUndefined() && !_(v).isArray()) {\n\t\t\t\t\treturn [v];\n\t\t\t\t}\n\t\t\t\treturn v;\n\t\t\t},\n\t\t\t_all_values_to_arrays:function(o) {\n\t\t\t\tif (!_(o).isObject()) { utils.error(' not an object', o); return o; }\n\t\t\t\tvar this_ = this;\n\t\t\t\t// ?!?! this isn't doing anything (!!)\n\t\t\t\treturn u.dict(_(o).map(function(v,k) {\n\t\t\t\t\tvar val = this_._value_to_array(k,v);\n\t\t\t\t\tif (u.defined(val)) { return [k,val]; }\n\t\t\t\t\treturn undefined;\n\t\t\t\t}).filter(u.defined));\n\t\t\t},\n\t\t\tset:function(k,v,options) {\n\t\t\t\t// set is tricky because it can be called like\n\t\t\t\t// set('foo',123) or set({foo:123})\n\t\t\t\tif (typeof k === 'string') { v = this._value_to_array(k,v);\t}\n\t\t\t\telse {\tk = this._all_values_to_arrays(k);\t}\n\t\t\t\treturn Backbone.Model.prototype.set.apply(this,[k,v,options]);\n\t\t\t},\n\t\t\tdelete_properties:function(props, silent)  {\n\t\t\t\tvar this_ = this;\n\t\t\t\tprops.map(function(p) { this_.unset(p, silent ? {silent:true} : {}); });\n\t\t\t},\n\t\t\t_deserialise_and_set:function(s_obj, silent) {\n\t\t\t\t// returns a promise\n\t\t\t\tvar this_ = this;\n\t\t\t\tvar dfds = _(s_obj).map(function(vals, key) {\n\t\t\t\t\tvar kd = u.deferred();\n\t\t\t\t\tif (key.indexOf('@') === 0) { return; }\n\t\t\t\t\tvar val_dfds = vals.map(function(val) {\n\t\t\t\t\t\tvar vd = u.deferred();\n\t\t\t\t\t\t// it's an object, so return that\n\t\t\t\t\t\tif (val.hasOwnProperty(\"@id\")) {\n\t\t\t\t\t\t\t// object\n\t\t\t\t\t\t\tthis_.box.get_obj(val[\"@id\"]).then(vd.resolve).fail(vd.reject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (val.hasOwnProperty(\"@value\")) {\n\t\t\t\t\t\t\t// literal\n\t\t\t\t\t\t\tvd.resolve(deserialize_literal(val, this_.box));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// don't know what it is!\n\t\t\t\t\t\t\tvd.reject('cannot unpack value ', val);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn vd.promise();\n\t\t\t\t\t});\n\t\t\t\t\tu.when(val_dfds).then(function(obj_vals) {\n\t\t\t\t\t\t// only update keys that have changed\n\t\t\t\t\t\tvar prev_vals = this_.get(key);\n\t\t\t\t\t\tif ( prev_vals === undefined || obj_vals.length !== prev_vals.length ||\n\t\t\t\t\t\t\t _(obj_vals).difference(prev_vals).length > 0 ||\n\t\t\t\t\t\t\t _(prev_vals).difference(obj_vals).length > 0) {\n\t\t\t\t\t\t\tthis_.set(key, obj_vals, { silent : silent });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkd.resolve();\n\t\t\t\t\t}).fail(kd.reject);\n\t\t\t\t\treturn kd.promise();\n\t\t\t\t}).filter(u.defined);\n\t\t\t\treturn u.when(dfds);\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\tvar this_ = this, fd = u.deferred(), box = this.box.get_id();\n\t\t\t\tthis.box._ajax('GET', box, {'id':this.id}).then(function(response) {\n\t\t\t\t\tthis_._set_fetched(true);\n\t\t\t\t\tvar objdata = response.data;\n\t\t\t\t\tif (objdata['@version'] === undefined) {\n\t\t\t\t\t\t// then the server thinks we've been deleted, so let's just die.\n\t\t\t\t\t\treturn fd.reject(this_.id);\n\t\t\t\t\t\t// old code:\n\t\t\t\t\t\t// according to the server, we're dead.\n\t\t\t\t\t\t// console.log('zombie detected ', this_.id);\n\t\t\t\t\t\t// this_.cid = this_.id;\n\t\t\t\t\t\t// this_.unset({});\n\t\t\t\t\t\t// delete this_.id;\n\t\t\t\t\t\t// fd.resolve();\n\t\t\t\t\t\t// return;\n\t\t\t\t\t}\n\t\t\t\t\t// we are at current known version as far as we know\n\t\t\t\t\tvar obj_save_dfds = _(objdata).map(function(obj,uri) {\n\t\t\t\t\t\t// top level keys - corresponding to box level properties\n\t\t\t\t\t\tif (uri[0] === \"@\") { return; } // ignore \"@id\", \"@version\" etc\n\t\t\t\t\t\t// not one of those, so must be a\n\t\t\t\t\t\t// < uri > : { prop1 .. prop2 ... }\n\t\t\t\t\t\tu.assert(uri === this_.id, 'can only deserialise this object ');\n\t\t\t\t\t\treturn this_._deserialise_and_set(obj);\n\t\t\t\t\t});\n\t\t\t\t\tu.when(obj_save_dfds).then(function(){ fd.resolve(this_); }).fail(fd.reject);\n\t\t\t\t});\n\t\t\t\treturn fd.promise();\n\t\t\t},\n\t\t\tsync: function(method, model, options){\n\t\t\t\tswitch(method){\n\t\t\t\tcase \"create\": return u.assert(false, \"create is never used for Objs\");\n\t\t\t\tcase \"read\"  : return model._fetch();\n\t\t\t\tcase \"update\":\n\t\t\t\t\treturn  model.box.update([model.id])[0];\n\t\t\t\tcase \"delete\":\n\t\t\t\t\treturn this.box._delete_models([this.id])[0];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\n\t\t// Box =================================================\n\t\t// GraphCollection is the list of Objs in a Graph\n\t\tvar ObjCollection = Backbone.Collection.extend({ model: Obj }),\n\t\t\tFileCollection = Backbone.Collection.extend({ model: File });\n\n\t\t// new client: fetch is always lazy, only gets ids, and\n\t\t// lazily get objects as you go\n\t\tvar Box = Backbone.Model.extend({\n\t\t\tidAttribute:\"@id\",\n\t\t\tdefault_options: { use_websockets:true, ws_auto_reconnect:false\t},\n\t\t\tinitialize:function(attributes, options) {\n\t\t\t\tvar this_ = this;\n\t\t\t\tu.assert(options.store, \"no store provided\");\n\t\t\t\tthis.store = options.store;\n\t\t\t\tthis.set({objcache: new ObjCollection(), objlist: [], files : new FileCollection() });\n\t\t\t\tthis.options = _(this.default_options).chain().clone().extend(options || {}).value();\n\t\t\t\tthis.set_up_websocket();\n\t\t\t\tthis._update_queue = {};\n\t\t\t\tthis._delete_queue = {};\n\t\t\t\tthis._fetching_queue = {};\n\t\t\t\tthis.on('update-from-master', function() {\n\t\t\t\t\t// u.log(\"UPDATE FROM MASTER >> flushing \");\n\t\t\t\t\tthis_._flush_update_queue();\n\t\t\t\t\tthis_._flush_delete_queue();\n\t\t\t\t});\n\t\t\t},\n\t\t\t/// <string> fid file id\n\t\t\t/// Tries to get a file with given id. If it doesn't exist, a file with that name is created.\n\t\t\t/// @return <File> the file\n\t\t\tget_or_create_file:function(fid) {\n\t\t\t\tvar files = this.get('files');\n\t\t\t\tif (files.get(fid) === undefined) {\n\t\t\t\t\tfiles.add(new File({\"@id\": fid}, { box: this }));\n\t\t\t\t}\n\t\t\t\treturn files.get(fid);\n\t\t\t},\n\t\t\tset_up_websocket:function() {\n\t\t\t\tvar this_ = this, server_host = this.store.get('server_host');\n\t\t\t\tif (! this.get_use_websockets() ) { return; }\n\t\t\t\tthis.on('new-token', function(token) {\n\t\t\t\t\tvar ws = this_._ws;\n\t\t\t\t\tif (ws) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tws.close();\n\t\t\t\t\t\t\tdelete this_._ws;\n\t\t\t\t\t\t} catch(e) { u.error(); }\n\t\t\t\t\t}\n\t\t\t\t\tvar protocol = (document.location.protocol === 'https:') ? 'wss:/' : 'ws:/';\n\t\t\t\t\tvar ws_url = [protocol,server_host,'ws'].join('/');\n\t\t\t\t\tws = new WebSocket(ws_url);\n\t\t\t\t\tws.onmessage = function(evt) {\n\t\t\t\t\t\tu.debug('websocket :: incoming a message ', evt.data.toString().substring(0,190));\n\t\t\t\t\t\tvar pdata = JSON.parse(evt.data);\n\t\t\t\t\t\tif (pdata.action === 'diff') {\n\t\t\t\t\t\t\tthis_._diff_update(pdata.data)\n\t\t\t\t\t\t\t\t.then(function() {\n\t\t\t\t\t\t\t\t\tthis_.trigger('update-from-master', this_._get_version());\n\t\t\t\t\t\t\t\t}).fail(function(err) {\n\t\t\t\t\t\t\t\t\tu.error(err); /*  u.log('done diffing '); */\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tws.onopen = function() {\n\t\t\t\t\t\tvar data = WS_MESSAGES_SEND.auth(this_.get('token'));\n\t\t\t\t\t\tws.send(data);\n\t\t\t\t\t\tdata = WS_MESSAGES_SEND.diff();\n\t\t\t\t\t\tws.send(data);\n\t\t\t\t\t\tthis_._ws = ws;\n\t\t\t\t\t\tthis_.trigger('ws-connect');\n\t\t\t\t\t};\n\t\t\t\t\tws.onclose = function(evt) {\n\t\t\t\t\t\t// what do we do now?!\n\t\t\t\t\t\tu.error('websocket closed -- ');\n\t\t\t\t\t\t// TODO\n\t\t\t\t\t\tvar interval;\n\t\t\t\t\t\tinterval = setInterval(function() {\n\t\t\t\t\t\t\tthis_.store.reconnect().then(function() {\n\t\t\t\t\t\t\t\tthis_.get_token().then(function() {\n\t\t\t\t\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},1000);\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t},\n\t\t\tget_use_websockets:function() { return this.options.use_websockets; },\n\t\t\tget_cache_size:function(i) { return this._objcache().length; },\n\t\t\tget_obj_ids:function() { return this._objlist().slice(); },\n\t\t\t_objcache:function() { return this.attributes.objcache; },\n\t\t\t_objlist:function() { return this.attributes.objlist !== undefined ? this.attributes.objlist : []; },\n\t\t\t_set_objlist:function(ol) { return this.set({objlist:ol.slice()}); },\n\t\t\t_get_cached_token:function() { return this.get(\"token\"); },\n\t\t\t_set_token:function(token) { this.set(\"token\", token);\t},\n\t\t\t_set_version:function(v) { this.set(\"version\", v);\t},\n\t\t\t_get_version:function(v) { return this.get(\"version\"); },\n\t\t\tget_token:function() {\n\t\t\t\t// utils.debug('>> get_token ', ' id: ',this.id, ' cid: ',this.cid);\n\t\t\t\t// try { throw new Error(''); } catch(e) { console.error(e); }\n\t\t\t\tvar this_ = this, d = u.deferred();\n\t\t\t\tthis._ajax('POST', 'auth/get_token', { app: this.store.get('app') })\n\t\t\t\t\t.then(function(data) {\n\t\t\t\t\t\tconsole.log('setting token ', data.token);\n\t\t\t\t\t\tthis_._set_token( data.token );\n\t\t\t\t\t\tthis_.trigger('new-token', data.token);\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tget_id:function() { return this.id || this.cid;\t},\n\t\t\t_ajax:function(method, path, data) {\n\t\t\t\tdata = _(_(data||{}).clone()).extend({box: this.id || this.cid, token:this.get('token')});\n\t\t\t\treturn this.store._ajax(method, path, data);\n\t\t\t},\n\t\t\tput_file:function(id,filedata,contenttype) {\n\t\t\t\t// creates a File object and hands it back in the resolve\n\t\t\t\tcontenttype = contenttype || filedata.type;\n\t\t\t\tvar d = u.deferred(), this_ = this, newFile = this.get_or_create_file(id);\n\t\t\t\tnewFile.set({\"content-type\": contenttype});\n\t\t\t\tthis._do_put_file(id,filedata,contenttype).then(function(){\n\t\t\t\t\tu.debug('image put success ');\n\t\t\t\t\td.resolve(newFile);\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tif (err.status === 409) {\n\t\t\t\t\t\tvar cb = function() {\n\t\t\t\t\t\t\tthis_.off('update-from-master', cb, newFile);\n\t\t\t\t\t\t\tthis_._put_file(id, filedata, contenttype).then(d.resolve).fail(d.reject);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis_.on('update-from-master', cb, newFile);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu.error('error putting, dammit ', err);\n\t\t\t\t\t\td.reject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_do_put_file:function(id,file,contenttype) {\n\t\t\t\t// now uses relative url scheme '//blah:port/path';\n\t\t\t\t// all files must be PUT into boxname/files\n\t\t\t\t// here the parameters are get encoded\n\t\t\t\t// // 'http://' + this.store.get('server_host') + \"/\" +  boxid + \"/\" + 'files',\n\t\t\t\tvar boxid = this.id || this.cid,\n\t\t\t\tbase_url = ['/', this.store.get('server_host'), boxid, 'files'].join('/'),\n\t\t\t\toptions = { app: this.store.get('app'), id: id, token:this.get('token'),  box: boxid, version: this._get_version() },\n\t\t\t\toption_params = $.param(options),\n\t\t\t\turl = base_url+\"?\"+option_params,\n\t\t\t\td = u.deferred();\n\t\t\t\tconsole.log(\"PUTTING FILE \", url);\n\t\t\t\tvar ajax_args  = _(_(this.store.ajax_defaults).clone()).extend(\n\t\t\t\t\t{ url: url, method : 'PUT', crossDomain:false, data:file, contentType: contenttype, processData:false }\n\t\t\t\t);\n\t\t\t\treturn $.ajax( ajax_args );\n\t\t\t},\n\t\t\tquery: function(q){\n\t\t\t\t// @TODO ::::::::::::::::::::::::::\n\t\t\t\tu.NotImplementedYet();\n\t\t\t\t// var d = u.deferred();\n\t\t\t\t// this._ajax(this, \"/query\", \"GET\", {\"q\": JSON.stringify(q)})\n\t\t\t\t// \t.then(function(data){\n\t\t\t\t// \t\tconsole.debug(\"query results:\",data);\n\t\t\t\t// \t}).fail(function(data) {\n\t\t\t\t// \t\tconsole.debug(\"fail query\");\n\t\t\t\t// \t});\n\t\t\t\t// return d.promise();\n\t\t\t},\n\t\t\t_diff_update:function(response) {\n\t\t\t\tvar d = u.deferred(), this_ = this, latest_version = response['@to_version'],\n\t\t\t\tadded_ids  = _(response.data.added).keys(),\n\t\t\t\tchanged_ids = _(response.data.changed).keys(),\n\t\t\t\tdeleted_ids = _(response.data.deleted).keys(),\n\t\t\t\tchanged_objs = response.data.changed;\n\n\t\t\t\tu.assert(latest_version !== undefined, 'latest version not provided');\n\t\t\t\tu.assert(added_ids !== undefined, 'added_ids not provided');\n\t\t\t\tu.assert(changed_ids !== undefined, 'changed not provided');\n\t\t\t\tu.assert(deleted_ids !== undefined, 'deleted _ids not provided');\n\n\t\t\t\tif (latest_version <= this_._get_version()) {\n\t\t\t\t\tu.debug('asked to diff update, but already up to date, so just relax!', latest_version, this_._get_version());\n\t\t\t\t\treturn d.resolve();\n\t\t\t\t}\n\t\t\t\tu.debug('setting latest version >> ', latest_version, added_ids, changed_ids, deleted_ids);\n\t\t\t\tthis_._set_version(latest_version);\n\t\t\t\tthis_._update_object_list(undefined, added_ids, deleted_ids);\n\t\t\t\tvar change_dfds = _(changed_objs).map(function(obj, uri) {\n\t\t\t\t\tu.debug(' checking to see if in --- ', uri, this_._objcache().get(uri));\n\t\t\t\t\tu.debug('obj >> ', obj);\n\t\t\t\t\tvar cached_obj = this_._objcache().get(uri), cdfd = u.deferred();\n\t\t\t\t\tif (cached_obj) {\n\t\t\t\t\t\t// { prop : [ {sval1 - @type:\"\"}, {sval2 - @type} ... ]\n\t\t\t\t\t\tvar changed_properties = [];\n\t\t\t\t\t\t// console.log(\"obj deleted \", obj.deleted);\n\t\t\t\t\t\tvar deleted_propval_dfds = _(obj.deleted).map(function(vs, k) {\n\t\t\t\t\t\t\tchanged_properties = _(changed_properties).union([k]);\n\t\t\t\t\t\t\tvar dd = u.deferred();\n\t\t\t\t\t\t\tu.when(vs.map(function(v) {\treturn deserialize_value(v, this_);\t})).then(function(values) {\n\t\t\t\t\t\t\t\tvar new_vals = _(cached_obj.get(k) || []).difference(values);\n\t\t\t\t\t\t\t\t// console.log(\"DESERIALISED deleted values \", values, \" - \", \" new_vals \", new_vals);\n\t\t\t\t\t\t\t\t// window._values = values; window._newvals = new_vals;\n\t\t\t\t\t\t\t\tcached_obj.set(k,new_vals);\n\t\t\t\t\t\t\t\t// semantics - if a property has no value then we delete it\n\t\t\t\t\t\t\t\tif (new_vals.length === 0) { cached_obj.unset(k); }\n\t\t\t\t\t\t\t\tdd.resolve();\n\t\t\t\t\t\t\t}).fail(dd.reject);\n\t\t\t\t\t\t\treturn dd.promise();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tvar added_propval_dfds = _(obj.added).map(function(vs, k) {\n\t\t\t\t\t\t\tchanged_properties = _(changed_properties).union([k]);\n\t\t\t\t\t\t\tvar dd = u.deferred();\n\t\t\t\t\t\t\tu.when(vs.map(function(v) {\treturn deserialize_value(v, this_);\t})).then(function(values) {\n\t\t\t\t\t\t\t\tvar new_vals = (cached_obj.get(k) || []).concat(values);\n\t\t\t\t\t\t\t\tcached_obj.set(k,new_vals);\n\t\t\t\t\t\t\t\tdd.resolve();\n\t\t\t\t\t\t\t}).fail(dd.reject);\n\t\t\t\t\t\t\treturn dd.promise();\n\t\t\t\t\t\t});\n                        var replaced_propval_dfs = _(obj.replaced).map(function(vs, k) {\n                            console.debug(\"Processing replaced property\");\n                            changed_properties = _(changed_properties).union([k]);\n                            var dd = u.deferred();\n                            u.when(vs.map(function(v) { return deserialize_value(v, this_); })).then(function(values) {\n                                var new_vals = values; // this is the difference from added - just replace (by DS)\n                                cached_obj.set(k,new_vals);\n                                dd.resolve();\n                            }).fail(dd.reject);\n                            return dd.promise();\n                        });\n                        u.when(added_propval_dfds.concat(deleted_propval_dfds).concat(replaced_propval_dfs)).then(function() {\n\t\t\t\t\t\t\t// u.debug(\"triggering changed properties \", changed_properties);\n\t\t\t\t\t\t\tchanged_properties.map(function(k) {\n\t\t\t\t\t\t\t\tcached_obj.trigger('change:'+k, (cached_obj.get(k) || []).slice());\n\t\t\t\t\t\t\t\tu.debug(\"trigger! change:\"+k);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcdfd.resolve(cached_obj);\n\t\t\t\t\t\t}).fail(cdfd.reject);\n\t\t\t\t\t\treturn cdfd.promise();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tu.when(change_dfds).then(d.resolve).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_create_model_for_id: function(obj_id){\n\t\t\t\tvar model = new Obj({\"@id\":obj_id}, {box:this});\n\t\t\t\tthis._objcache().add(model);\n\t\t\t\treturn model;\n\t\t\t},\n\t\t\tget_obj:function(objid) {\n\t\t\t\t// get_obj always returns a promise\n\t\t\t\tu.assert(typeof objid === 'string' || typeof objid === 'number', \"objid has to be a number or string\");\n\t\t\t\tvar d = u.deferred(),\n\t\t\t\tcachemodel = this._objcache().get(objid),\n\t\t\t\tfetching_dfd = this._fetching_queue[objid],\n\t\t\t\thasmodel = cachemodel && fetching_dfd === undefined,\n\t\t\t\tthis_ = this;\n\n\t\t\t\tif (hasmodel) {\n\t\t\t\t\tconsole.log('returning cached ', objid);\n\t\t\t\t\td.resolve(cachemodel); return d.promise();\n\t\t\t\t}\n\n\t\t\t\t// check to see if already fetching, then we can tag along\n\t\t\t\tif (fetching_dfd) {\n\t\t\t\t\t// to fix a deadlock condition -\n\t\t\t\t\t// if we fetch someone who loops back to us\n\t\t\t\t\t// then we will never resolve with this code:\n\t\t\t\t\t//\n\t\t\t\t\t// fetching_dfd.then(d.resolve).fail(d.reject);\n\t\t\t\t\t// return d.promise();\n\t\t\t\t\t// --\n\t\t\t\t\t// therefore a fix:\n\t\t\t\t\td.resolve(cachemodel);\n\t\t\t\t\treturn d.promise();\n\t\t\t\t}\n\n\t\t\t\t// if not already fetching then we have to fetch\n\t\t\t\tthis._fetching_queue[objid] = d;\n\t\t\t\tvar model = this_._create_model_for_id(objid);\n\t\t\t\t// if the serve knows about it, then we fetch its definition\n\t\t\t\tconsole.log('objlist ', this._objlist());\n\n\t\t\t\t// old code ::\n\t\t\t\t// if (this._objlist().indexOf(objid) >= 0) {\n\t\t\t\t// \tconsole.log('object exists, going to fetch it ');\n\t\t\t\t// \tmodel.fetch().then(function() {\n\t\t\t\t// \t\td.resolve(model);\n\t\t\t\t// \t\tdelete this_._fetching_queue[objid];\n\t\t\t\t// \t}).fail(d.reject);\n\t\t\t\t// } else {\n\t\t\t\t// \tconsole.log('object doesnt exist, not going to fetch it ');\n\t\t\t\t// \t// otherwise it must be new!\n\t\t\t\t// \tmodel.is_new = true;\n\t\t\t\t// \td.resolve(model);\n\t\t\t\t// }\n\n\t\t\t\tconsole.log('trying to fetch ', objid);\n\t\t\t\tmodel.fetch().then(function() {\n\t\t\t\t\td.resolve(model);\n\t\t\t\t\tdelete this_._fetching_queue[objid];\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tconsole.log('failed.. declaring it new ', objid);\n\t\t\t\t\t// TODO check if 404'd\n\t\t\t\t\tconsole.log('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA err - didnt exist ? ', err);\n\t\t\t\t\tmodel.is_new = true;\n\t\t\t\t\td.resolve(model);\n\t\t\t\t\tdelete this_._fetching_queue[objid];\n\t\t\t\t});\n\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// ----------------------------------------------------\n\t\t\t_update_object_list:function(updated_obj_ids, added, deleted) {\n\t\t\t\tvar current, olds = this._objlist().slice(), this_ = this, news, died;\n\t\t\t\t// u.debug('_update_object_list +', added ? added.length : ' ', '-', deleted ? deleted.length : ' ');\n\t\t\t\t// u.debug('_update_object_list +', added || ' ', deleted || ' ');\n\t\t\t\tif (updated_obj_ids === undefined ) {\n\t\t\t\t\tcurrent = _(olds).chain().union(added).difference(deleted).value();\n\t\t\t\t\tnews = (added || []).slice(); died = (deleted || []).slice();\n\t\t\t\t} else {\n\t\t\t\t\tcurrent = updated_obj_ids.slice();\n\t\t\t\t\tnews = _(current).difference(olds);\n\t\t\t\t\tdied = _(olds).difference(current);\n\t\t\t\t}\n\t\t\t\t// u.debug('old objlist had ', olds.length, ' new has ', current.length, 'news > ', news);\n\t\t\t\tthis._set_objlist(current);\n\t\t\t\tnews.map(function(aid) {\tthis_.trigger('obj-add', aid);\t});\n\t\t\t\tdied.map(function(rid) {\n\t\t\t\t\tthis_.trigger('obj-remove', rid);\n\t\t\t\t\tthis_._objcache().remove(rid);\n\t\t\t\t});\n\t\t\t},\n\t\t\t_is_fetched: function() {\n\t\t\t\treturn this.id !== undefined;\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\t// all fetch really does is retrieve ids!\n\t\t\t\t// new client :: this now _only_ fetches object ids\n\t\t\t\t// return a list of models (each of type Object) to populate a GraphCollection\n\t\t\t\tvar d = u.deferred(), fd = u.deferred(), this_ = this;\n\t\t\t\tif (this._is_fetched()) {\n\t\t\t\t\t// Nope - don't do anything -- we just wait for websockets to update us.\n\t\t\t\t\tfd.resolve();\n\t\t\t\t} else {\n\t\t\t\t\t// otherwise we aren't fetched, so we just do it\n\t\t\t\t\tvar box = this.get_id();\n\t\t\t\t\tthis._ajax(\"GET\",[box,'get_object_ids'].join('/')).then(\n\t\t\t\t\t\tfunction(response){\n\t\t\t\t\t\t\tu.assert(response['@version'] !== undefined, 'no version provided');\n\t\t\t\t\t\t\tthis_.id = this_.get_id(); // sets so that _is_fetched later returns true\n\t\t\t\t\t\t\tthis_._set_version(response['@version']);\n\t\t\t\t\t\t\tthis_._update_object_list(response.ids);\n\t\t\t\t\t\t\tfd.resolve(this_);\n\t\t\t\t\t\t}).fail(fd.reject);\n\t\t\t\t}\n\t\t\t\tfd.then(function() {\n\t\t\t\t\tthis_.trigger('update-from-master', this_._get_version());\n\t\t\t\t\td.resolve(this_);\n\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// -----------------------------------------------\n\t\t\t_check_token_and_fetch : function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (this.get('token') === undefined) {\n\t\t\t\t\tvar d = u.deferred();\n\t\t\t\t\tthis.get_token()\n\t\t\t\t\t\t.then(function() { this_._fetch().then(d.resolve).fail(d.reject);\t})\n\t\t\t\t\t\t.fail(d.reject);\n\t\t\t\t\treturn d.promise();\n\t\t\t\t}\n\t\t\t\treturn this_._fetch();\n\t\t\t},\n\t\t\t_create_box:function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis.store._ajax('POST', 'admin/create_box', { name: this.get_id() } )\n\t\t\t\t\t.then(function() {\n\t\t\t\t\t\tthis_.fetch().then(function() { d.resolve(); }).fail(function(err) { d.reject(err); });\n\t\t\t\t\t}).fail(function(err) { d.reject(err); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tdelete_box:function(boxid) {\n\t\t\t\treturn this.store._ajax('POST','admin/delete_box', { name: boxid } );\n\t\t\t},\n\t\t\t// =============== :: UPDATE ::  ======================\n\t\t\tWHOLE_BOX: \"__UPDATE__WHOLE__BOX__\",\n\t\t\t_add_to_update_queue:function(ids_to_update) {\n\t\t\t\tvar this_ = this, uq = this._update_queue;\n\t\t\t\t// returns the deferreds\n\t\t\t\tids_to_update = ids_to_update === undefined ? [ this.WHOLE_BOX ] : ids_to_update;\n\t\t\t\treturn ids_to_update.map(function(id) {\n\t\t\t\t\tuq[id] = uq[id] || u.deferred();\n\t\t\t\t\treturn uq[id];\n\t\t\t\t});\n\t\t\t},\n\t\t\t_requeue_update:function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (!this._update_timeout) {\n\t\t\t\t\tthis._update_timeout = setTimeout(function() {\n\t\t\t\t\t\tdelete this_._update_timeout;\n\t\t\t\t\t\tthis_._flush_update_queue();\n\t\t\t\t\t}, 300);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_flush_update_queue:function() {\n\t\t\t\tvar this_ = this, uq = this._update_queue, ids_to_update = _(uq).keys();\n\t\t\t\tif (ids_to_update.length === 0) { return ; }\n\t\t\t\tif (this._updating || this._deleting) {\n\t\t\t\t\treturn this._requeue_update();\n\t\t\t\t}\n\n\t\t\t\tthis._update_queue = {};\n\t\t\t\tvar update_arguments = ids_to_update.indexOf(this.WHOLE_BOX) >= 0 ? undefined : ids_to_update;\n\t\t\t\tthis_._updating = true;\n\n\t\t\t\tthis_._do_update(update_arguments).then(function() {\n\t\t\t\t\tdelete this_._updating;\n\t\t\t\t\t// TODO: resolve all of our deferreds now and delete them\n\t\t\t\t\tids_to_update.map(function(id) { uq[id].resolve();\t\t});\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tdelete this_._updating;\n\t\t\t\t\tif (err.status === 409) {\n\t\t\t\t\t\t// add the defferds back in\n\t\t\t\t\t\t_(uq).map(function(d,id) {\n\t\t\t\t\t\t\tif (this_._update_queue[id]) {\n\t\t\t\t\t\t\t\t// someone's already added one back in! let's chain them\n\t\t\t\t\t\t\t\tu.debug('HEYYYYYYYYYYYYYYYYYYYYYY already added in - lets go');\n\t\t\t\t\t\t\t\tthis_._update_queue[id].then(uq[id].resolve).fail(uq[id].reject);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tu.debug('sneaking him back in - lets go');\n\t\t\t\t\t\t\t\tthis_._update_queue[id] = uq[id];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn this_._requeue_update();\n\t\t\t\t\t}\n\t\t\t\t\t// something bad happened, we'd better reject on those deferreds\n\t\t\t\t\tu.error('UPDATE error ', err);\n\t\t\t\t\tids_to_update.map(function(id) { uq[id].reject(err);});\n\t\t\t\t});\n\t\t\t},\n\t\t\t_do_update:function(ids) {\n\t\t\t\t// this actua\n\t\t\t\tconsole.log('box update >> ');\n\t\t\t\tvar d = u.deferred(), version = this.get('version') || 0, this_ = this,\n\t\t\t\tobjs = this._objcache().filter(function(x) { return ids === undefined || ids.indexOf(x.id) >= 0; }),\n\t\t\t\tobj_ids = objs.map(function(x) { return x.id; }),\n\t\t\t\tsobjs = objs.map(function(obj){ return serialize_obj(obj); });\n\t\t\t\tthis._ajax(\"PUT\",  this.get_id() + \"/update\", { version: escape(version), data : JSON.stringify(sobjs)  })\n\t\t\t\t\t.then(function(response) {\n\t\t\t\t\t\tthis_._set_version(response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._update_object_list(undefined, obj_ids, []); // update object list\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tupdate:function(original_ids) {\n\t\t\t\t// this is called by Backbone.save(),\n\t\t\t\tvar dfds = this._add_to_update_queue(original_ids);\n\t\t\t\tthis._flush_update_queue();\n\t\t\t\treturn dfds;\n\t\t\t},\n\t\t\t// =============== :: DELETE ::  ======================\n\t\t\t_add_to_delete_queue:function(ids) {\n\t\t\t\tvar this_ = this, dq = this._delete_queue;\n\t\t\t\treturn ids.map(function(id) {\n\t\t\t\t\tdq[id] = dq[id] || u.deferred();\n\t\t\t\t\treturn dq[id];\n\t\t\t\t});\n\t\t\t},\n\t\t\t_delete_models:function(ids) {\n\t\t\t\tvar dfds =  this._add_to_delete_queue(ids);\n\t\t\t\tthis._flush_delete_queue();\n\t\t\t\treturn dfds;\n\t\t\t},\n\t\t\t_requeue_delete:function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (!this._delete_timeout) {\n\t\t\t\t\tthis._delete_timeout = setTimeout(function() {\n\t\t\t\t\t\tdelete this_._delete_timeout;\n\t\t\t\t\t\tthis_._flush_delete_queue();\n\t\t\t\t\t}, 300);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_flush_delete_queue:function() {\n\t\t\t\tvar this_ = this, dq = this._delete_queue, delete_ids = _(dq).keys();\n\t\t\t\tif (delete_ids.length === 0) { return ; }\n\t\t\t\tif (this._deleting || this._updating) { return this._requeue_delete();  }\n\t\t\t\tthis_._deleting = true;\n\t\t\t\tthis_._do_delete(delete_ids).then(function() {\n\t\t\t\t\tdelete this_._deleting;\n\t\t\t\t\tdelete_ids.map(function(id) {\n\t\t\t\t\t\tdq[id].resolve(); delete dq[id];\n\t\t\t\t\t});\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tdelete this_._deleting;\n\t\t\t\t\tif (err.status === 409) { this_._requeue_delete();\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t_do_delete:function(m_ids) {\n\t\t\t\tvar version = this.get('version') || 0, d = u.deferred(), this_ = this;\n\t\t\t\tthis._ajax('DELETE', this.id+'/', { version:version, data: JSON.stringify(m_ids) })\n\t\t\t\t\t.then(function(response) {\n\t\t\t\t\t\tu.debug('DELETE response NEW version > ', response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._set_version(response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._update_object_list(undefined, [], m_ids); // update object list\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// =============== :: SYNC ::  ======================\n\t\t\tsync: function(method, box, options){\n\t\t\t\tswitch(method)\n\t\t\t\t{\n\t\t\t\tcase \"create\": return box._create_box();\n\t\t\t\tcase \"read\": return box._check_token_and_fetch();\n\t\t\t\tcase \"update\": return box.update()[0];  // save whole box?\n\t\t\t\tcase \"delete\": return this.delete_box(this.get_id()) // hook up to destroy\n\t\t\t\t}\n\t\t\t},\n\t\t\ttoString: function() { return 'box:' + this.get_id(); }\n\t\t});\n\n\t\tvar BoxCollection = Backbone.Collection.extend({ model: Box });\n\n\t\tvar Store =  Backbone.Model.extend({\n\t\t\tdefaults: {\n\t\t\t\tserver_host:DEFAULT_HOST,\n\t\t\t\tapp:\"--default-app-id--\"\n\t\t\t},\n\t\t\tajax_defaults : {\n\t\t\t\tjsonp: false, contentType: \"application/json\",\n\t\t\t\txhrFields: { withCredentials: true }\n\t\t\t},\n\n\t\t\t/// @opt <{}> attributes\n\t\t\t/// @opt <{}> options\n\t\t\t/// @constructor\n\t\t\tinitialize: function(attributes, options){\n\t\t\t\tthis.set({boxes : new BoxCollection([], {store: this})});\n\t\t\t},\n\n\t\t\t/// Check that the\n\t\t\tis_same_domain:function() {\n\t\t\t\treturn this.get('server_host').indexOf(document.location.host) >= 0 && (document.location.port === (this.get('server_port') || ''));\n\t\t\t},\n\t\t\tboxes:function() { return this.attributes.boxes;\t},\n\t\t\tget_box: function(boxid) {\n\t\t\t\tvar b = this.boxes().get(boxid) || this._create(boxid);\n\t\t\t\tif (!b._get_cached_token()) {\n\t\t\t\t\treturn b.get_token().pipe(function() {\n\t\t\t\t\t\treturn b.fetch();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn u.dresolve(b);\n\t\t\t},\n\n\n\t\t\t/// @arg <string|number> boxid: the id for the box\n\t\t\t///\n\t\t\t/// @then (<Box> the box)\n\t\t\t/// @fail\n\t\t\t///   (<{ code: 409 }> response) box already exists\n\t\t\t///   (<{ code: -1, error: error obj }> response) other error\n\t\t\t///\n\t\t\t/// Attempts to create a box with the given ID\n\t\t\tcreate_box: function (boxid) {\n\t\t\t\tu.debug('create box ', boxid);\n\t\t\t\tif (this.boxes().get(boxid)) {\n\t\t\t\t\treturn u.dreject({ code: 409, message: 'Box already exists: ' + boxid });\n\t\t\t\t}\n\t\t\t\tvar c = this._create(boxid), this_ = this;\n\t\t\t\tu.debug('creating ', boxid);\n\t\t\t\treturn c.save().pipe(function() { return this_.get_box(boxid); });\n\t\t\t},\n\t\t\tcheck_login:function() {\n\t\t\t\t// checks whether you can connect to the server and who is logged in.\n\t\t\t\t// returns a deferred that gets passed an argument\n\t\t\t\t// { code:200 (server is okay),  is_authenticated:true/false,  user:<username>  }\n\t\t\t\treturn this._ajax('GET', 'auth/whoami');\n\t\t\t},\n\t\t\t// todo: change to _\n\t\t\tget_info:function() { return this._ajax('GET', 'admin/info'); },\n\t\t\tlogin : function(username,password) {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tthis.set({username:username,password:password});\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis._ajax('POST', 'auth/login', { username: username, password: password })\n\t\t\t\t\t.then(function(l) { this_.trigger('login', username); d.resolve(l); })\n\t\t\t\t\t.fail(function(l) { d.reject(l); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\treconnect:function() {\n\t\t\t\treturn this.login(this.get('username'),this.get('password'));\n\t\t\t},\n\t\t\tlogout : function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis._ajax('POST', 'auth/logout')\n\t\t\t\t\t.then(function(l) { this_.trigger('logout'); d.resolve(l); })\n\t\t\t\t\t.fail(function(l) { d.reject(l); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_create:function(boxid) {\n\t\t\t\tvar b = new Box({}, {store: this});\n\t\t\t\tb.cid = boxid;\n\t\t\t\tthis.boxes().add(b);\n\t\t\t\treturn b;\n\t\t\t},\n\t\t\tget_box_list:function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tthis._ajax('GET','admin/list_boxes')\n\t\t\t\t\t.success(function(data) {d.resolve(data.list);})\n\t\t\t\t\t.fail(function(err) { d.reject(err); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\tthrow new Error('dont fetch a store - any more!');\n\t\t\t\t//\n\t\t\t\t// fetches list of boxes\n\t\t\t\t/* - do not do this\n\t\t\t\tvar this_ = this, d = u.deferred();\n\t\t\t\tthis._ajax('GET','admin/list_boxes')\n\t\t\t\t\t.success(function(data) {\n\t\t\t\t\t\tu.when(data.list.map(function(boxid) { return this_.get_box(boxid); })).then(function(boxes) {\n\t\t\t\t\t\t\t// console.log(\"boxes !! \", boxes);\n\t\t\t\t\t\t\tthis_.boxes().reset(boxes);\n\t\t\t\t\t\t\td.resolve(boxes);\n\t\t\t\t\t\t});\n\t\t\t\t\t}).error(function(e) { d.reject(e); });\n\t\t\t\treturn d.promise();\n\t\t\t\t*/\n\t\t\t},\n\t\t\t_ajax:function(method, path, data) {\n\t\t\t\t// now uses relative url scheme '//blah:port/path';\n\t\t\t\tvar url = ['/', this.get('server_host'), path].join('/');\n\t\t\t\tvar default_data = { app: this.get('app') };\n\t\t\t\tvar options = _(_(this.ajax_defaults).clone()).extend(\n\t\t\t\t\t{ url: url, method : method, crossDomain: !this.is_same_domain(), data: _(default_data).extend(data) }\n\t\t\t\t);\n\t\t\t\treturn $.ajax( options ); // returns a deferred\n\t\t\t},\n\t\t\tsync: function(method, model, options){\n\t\t\t\tswitch(method){\n\t\t\t\tcase \"create\": return u.error('store.create() : cannot create a store'); // TODO\n\t\t\t\tcase \"read\"  : return model._fetch();\n\t\t\t\tcase \"update\": return u.error('store.update() : cannot update a store'); // TODO\n\t\t\t\tcase \"delete\": return u.error('store.delete() : cannot delete a store'); // tODO\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tvar exports = {\n\t\t\tsafe_apply:utils.safe_apply,\n\t\t\tu : utils,\n\t\t\tStore:Store,\n\t\t\tObj: Obj,\n\t\t\tFile:File,\n\t\t\tBox: Box,\n\t\t\tstore: new Store(),\n\t\t\tloaded : utils.deferred()\n\t\t};\n\t\twindow.u = utils;\n\n\t\t// do not fetch boxes\n\t\texports.loaded.resolve(exports);\n\t\treturn exports;\n\n\t}).factory('backbone', function(client, utils) {\n\t\t// this manages backbone-angular mystification\n\t\tvar deregfns = [];\n\t\tvar deep_clone_obj = function(o) {\n\t\t\treturn utils.dict(_(o).map(function(v,k) { return [k, v.concat()]; }));\n\t\t};\n\t\tvar scope_bind = function($scope, name, model) {\n\t\t\tutils.assert(model instanceof Backbone.Model, \"tried to bind something that was not a model\");\n\t\t\twindow._m = model;\n\t\t\tvar clone = deep_clone_obj(_(model.attributes));\n\t\t\tutils.safe_apply($scope, function() { $scope[name] = clone;\t});\n\t\t\tvar findchanges = function(old,new_,fn) {\n\t\t\t\tvar changes = [];\n\t\t\t\t_(old).map(function(v,k) {\n\t\t\t\t\tif (v.length !== new_[k].length || _(v).filter(function(vi, i) { return vi != new_[k][i]; }).length) {\n\t\t\t\t\t\tutils.log('pushing changes ', k, new_[k]);\n\t\t\t\t\t\tchanges.push(k);\n\t\t\t\t\t\tif (fn) { fn(k,new_[k].concat()); }\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn changes;\n\t\t\t};\n\t\t\t// angular -> backbone\n\t\t\tvar dereg = $scope.$watch(name, function() {\n\t\t\t\t// do a quick diff --\n\t\t\t\t// first check to make sure that our brave model is still\n\t\t\t\tif ($scope[name] !== clone) { return true; }\n\t\t\t\tfindchanges(model.attributes, clone, function(k,v) {model.set(k,v); });\n\t\t\t}, true);\n\t\t\tderegfns.push([$scope,name,model,dereg]);\n\t\t\t// backbone -> angular\n\t\t\tmodel.on('change', function(data) {\n\t\t\t\tutils.safe_apply($scope, function() {\n\t\t\t\t\tfindchanges(clone, model.attributes, function(k,v) { clone[k] = v;\t});\n\t\t\t\t});\n\t\t\t},$scope);\n\t\t};\n\t\treturn {\n\t\t\tscope_bind: scope_bind,\n\t\t\tscope_unbind:function($scope,name) {\n\t\t\t\tderegfns.map(function(tuple) {\n\t\t\t\t\tvar scope = tuple[0],name = tuple[1],model = tuple[2],dereg = tuple[3];\n\t\t\t\t\tmodel.off('change', null, scope);\n\t\t\t\t\tdereg();\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t});\n","methods":[],"properties":[],"match":"ObjCollection = Backbone.Collection.extend(","name":"ObjCollection","start":9965,"extend":"~1","end":10027},{"data":"///\n/// @title INDX\n/// blah\n\n/*global $,_,document,window,console,escape,Backbone,exports,WebSocket */\n/*jslint vars:true, todo:true */\n/*\n\n  indx.js is the JS Client SDK for WebBox WebBox\n  which builds upon Backbone's Model architecture.\n\n  CURRENT TODOs:\n  \t- update only supports updating the entire box\n    - Box.fetch() retrieves _entire box contents_\n\t  ... which is a really bad idea.\n\n  @prerequisites:\n\tjquery 1.8.0 or higher\n\tbackbone.js 0.9.2 or higher\n\tunderscore.js 1.4.2 or higher\n\n  This file is part of INDX\n  Copyright 2012 Max Van Kleek, Daniel Alexander Smith\n  Copyright 2012 University of Southampton\n\n  WebBox is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  WebBox is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with Indx.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n\nangular\n\t.module('indx', ['ui'])\n\t.factory('client',function(utils) {\n\t\tvar u = utils; // to be filled in by dependency\n\t\t// set up our parameters for webbox -\n\t\t// default is that we're loading from an _app_ hosted within\n\t\t// indx.\n\t\tvar DEFAULT_HOST = document.location.host; // which may contain the port\n\t\tvar WS_MESSAGES_SEND = {\n\t\t\tauth: function(token) { return JSON.stringify({action:'auth', token:token}); },\n\t\t\tdiff: function(token) { return JSON.stringify({action:'diff', operation:\"start\"}); }\n\t\t};\n\t\tvar serialize_obj = function(obj) {\n\t\t\tvar uri = obj.id;\n\t\t\tvar out_obj = {};\n\t\t\t$.each(obj.attributes, function(pred, vals){\n\t\t\t\tif (pred[0] === \"_\" || pred[0] === \"@\"){\n\t\t\t\t\t// don't expand @id etc.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar obj_vals = [];\n\t\t\t\tif (!(vals instanceof Array)){\n\t\t\t\t\tvals = [vals];\n\t\t\t\t}\n\t\t\t\t$.each(vals, function(){\n\t\t\t\t\tvar val = this;\n\t\t\t\t\tif (val instanceof File) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.id, \"@type\":\"indx-file\", \"@language\":val.get('content-type')});\n\t\t\t\t\t} else if (val instanceof Obj) {\n\t\t\t\t\t\tobj_vals.push({\"@id\": val.id });\n\t\t\t\t\t} else if (typeof val === \"object\" && (val[\"@value\"] || val[\"@id\"])) {\n\t\t\t\t\t\tobj_vals.push(val); // fully expanded string, e.g. {\"@value\": \"foo\", \"@language\": \"en\" ... }\n\t\t\t\t\t} else if (typeof val === \"string\" || val instanceof String ){\n\t\t\t\t\t\tobj_vals.push({\"@value\": val});\n\t\t\t\t\t} else if (_.isDate(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toISOString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"});\n\t\t\t\t\t} else if (_.isNumber(val) && u.isInteger(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#integer\"});\n\t\t\t\t\t} else if (_.isNumber(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#float\"});\n\t\t\t\t\t} else if (_.isBoolean(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#boolean\"});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu.warn(\"Could not determine type of val \", pred, val);\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString()});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tout_obj[pred] = obj_vals;\n\t\t\t});\n\t\t\tout_obj['@id'] = uri;\n\t\t\treturn out_obj;\n\t\t};\n\n\t\tvar literal_deserializers = {\n\t\t\t'': function(o) { return o['@value']; },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#integer\": function(o) { return parseInt(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#float\": function(o) { return parseFloat(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#double\": function(o) { return parseFloat(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#boolean\": function(o) { return o['@value'].toLowerCase() === 'true'; },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#dateTime\": function(o) { return new Date(Date.parse(o['@value'])); },\n\t\t\t\"indx-file\": function(o,box) {\n\t\t\t\tvar f = box.get_or_create_file(o['@value']);\n\t\t\t\tf.set(\"content-type\", o['@language']);\n\t\t\t\treturn f;\n\t\t\t}\n\t\t};\n\t\tvar deserialize_literal = function(obj, box) {\n\t\t\treturn obj['@value'] !== undefined ? literal_deserializers[ obj['@type'] || '' ](obj, box) : obj;\n\t\t};\n\n\t\tvar deserialize_value = function(s_val, box) {\n\t\t\tvar vd = u.deferred();\n\t\t\t// it's an object, so return that\n\t\t\tif (s_val.hasOwnProperty(\"@id\")) {\n\t\t\t\t// object\n\t\t\t\tbox.get_obj(s_val[\"@id\"]).then(vd.resolve).fail(vd.reject);\n\t\t\t}\n\t\t\telse if (s_val.hasOwnProperty(\"@value\")) {\n\t\t\t\t// literal\n\t\t\t\tvd.resolve(deserialize_literal(s_val, box));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// don't know what it is!\n\t\t\t\tvd.reject('cannot unpack value ', s_val);\n\t\t\t}\n\t\t\treturn vd.promise();\n\t\t};\n\n\t\tvar File =  Backbone.Model.extend({\n\t\t\tidAttribute: \"@id\", // the URI attribute is '@id' in JSON-LD\n\t\t\tinitialize:function(attrs, options) {\n\t\t\t\tu.debug('options >> ', attrs, options );\n\t\t\t\tthis.box = options.box;\n\t\t\t},\n\t\t\tget_id:function() { return this.id;\t},\n\t\t\tget_url:function() {\n\t\t\t\tvar params = {\n\t\t\t\t\tid:this.get_id(),\n\t\t\t\t\tapp:this.box.store.get('app'),\n\t\t\t\t\ttoken:this.box.get('token'),\n\t\t\t\t\tbox:this.box.get_id()\n\t\t\t\t}, url = ['/', this.box.store.get('server_host'), this.box.id, 'files'].join('/') + '?' + $.param(params);\n\t\t\t\t// u.debug(\"IMAGE URL IS \", url, params);\n\t\t\t\treturn url;\n\t\t\t}\n\t\t});\n\n\n\t\t// MAP OF THIS MODUULE :::::::::::::: -----\n\t\t//\n\t\t// An Obj is a single instance, thing in Indx.\n\t\t//\n\t\t// A Box is a model that has an attribute called 'Objs'.\n\t\t// ...  which is a Backbone.Collection of Graph objects.\n\t\t//\n\t\t// A _Store_ represents a single Indx server, which has an\n\t\t//\t attribute called 'boxes' -\n\t\t// ... which is a collection of Box objects\n\t\tvar Obj =  Backbone.Model.extend({\n\t\t\tidAttribute: \"@id\", // the URI attribute is '@id' in JSON-LD\n\t\t\tinitialize:function(attrs, options) {\n\t\t\t\tthis.box = options.box;\n\t\t\t},\n\t\t\t_is_fetched: function() { return this._fetched || false; },\n\t\t\t_set_fetched : function() { this._fetched = true; },\n\t\t\tget_id:function() { return this.id;\t},\n\t\t\t_value_to_array:function(k,v) {\n\t\t\t\tif (k === '@id') { return v; }\n\t\t\t\tif (!_(v).isUndefined() && !_(v).isArray()) {\n\t\t\t\t\treturn [v];\n\t\t\t\t}\n\t\t\t\treturn v;\n\t\t\t},\n\t\t\t_all_values_to_arrays:function(o) {\n\t\t\t\tif (!_(o).isObject()) { utils.error(' not an object', o); return o; }\n\t\t\t\tvar this_ = this;\n\t\t\t\t// ?!?! this isn't doing anything (!!)\n\t\t\t\treturn u.dict(_(o).map(function(v,k) {\n\t\t\t\t\tvar val = this_._value_to_array(k,v);\n\t\t\t\t\tif (u.defined(val)) { return [k,val]; }\n\t\t\t\t\treturn undefined;\n\t\t\t\t}).filter(u.defined));\n\t\t\t},\n\t\t\tset:function(k,v,options) {\n\t\t\t\t// set is tricky because it can be called like\n\t\t\t\t// set('foo',123) or set({foo:123})\n\t\t\t\tif (typeof k === 'string') { v = this._value_to_array(k,v);\t}\n\t\t\t\telse {\tk = this._all_values_to_arrays(k);\t}\n\t\t\t\treturn Backbone.Model.prototype.set.apply(this,[k,v,options]);\n\t\t\t},\n\t\t\tdelete_properties:function(props, silent)  {\n\t\t\t\tvar this_ = this;\n\t\t\t\tprops.map(function(p) { this_.unset(p, silent ? {silent:true} : {}); });\n\t\t\t},\n\t\t\t_deserialise_and_set:function(s_obj, silent) {\n\t\t\t\t// returns a promise\n\t\t\t\tvar this_ = this;\n\t\t\t\tvar dfds = _(s_obj).map(function(vals, key) {\n\t\t\t\t\tvar kd = u.deferred();\n\t\t\t\t\tif (key.indexOf('@') === 0) { return; }\n\t\t\t\t\tvar val_dfds = vals.map(function(val) {\n\t\t\t\t\t\tvar vd = u.deferred();\n\t\t\t\t\t\t// it's an object, so return that\n\t\t\t\t\t\tif (val.hasOwnProperty(\"@id\")) {\n\t\t\t\t\t\t\t// object\n\t\t\t\t\t\t\tthis_.box.get_obj(val[\"@id\"]).then(vd.resolve).fail(vd.reject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (val.hasOwnProperty(\"@value\")) {\n\t\t\t\t\t\t\t// literal\n\t\t\t\t\t\t\tvd.resolve(deserialize_literal(val, this_.box));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// don't know what it is!\n\t\t\t\t\t\t\tvd.reject('cannot unpack value ', val);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn vd.promise();\n\t\t\t\t\t});\n\t\t\t\t\tu.when(val_dfds).then(function(obj_vals) {\n\t\t\t\t\t\t// only update keys that have changed\n\t\t\t\t\t\tvar prev_vals = this_.get(key);\n\t\t\t\t\t\tif ( prev_vals === undefined || obj_vals.length !== prev_vals.length ||\n\t\t\t\t\t\t\t _(obj_vals).difference(prev_vals).length > 0 ||\n\t\t\t\t\t\t\t _(prev_vals).difference(obj_vals).length > 0) {\n\t\t\t\t\t\t\tthis_.set(key, obj_vals, { silent : silent });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkd.resolve();\n\t\t\t\t\t}).fail(kd.reject);\n\t\t\t\t\treturn kd.promise();\n\t\t\t\t}).filter(u.defined);\n\t\t\t\treturn u.when(dfds);\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\tvar this_ = this, fd = u.deferred(), box = this.box.get_id();\n\t\t\t\tthis.box._ajax('GET', box, {'id':this.id}).then(function(response) {\n\t\t\t\t\tthis_._set_fetched(true);\n\t\t\t\t\tvar objdata = response.data;\n\t\t\t\t\tif (objdata['@version'] === undefined) {\n\t\t\t\t\t\t// then the server thinks we've been deleted, so let's just die.\n\t\t\t\t\t\treturn fd.reject(this_.id);\n\t\t\t\t\t\t// old code:\n\t\t\t\t\t\t// according to the server, we're dead.\n\t\t\t\t\t\t// console.log('zombie detected ', this_.id);\n\t\t\t\t\t\t// this_.cid = this_.id;\n\t\t\t\t\t\t// this_.unset({});\n\t\t\t\t\t\t// delete this_.id;\n\t\t\t\t\t\t// fd.resolve();\n\t\t\t\t\t\t// return;\n\t\t\t\t\t}\n\t\t\t\t\t// we are at current known version as far as we know\n\t\t\t\t\tvar obj_save_dfds = _(objdata).map(function(obj,uri) {\n\t\t\t\t\t\t// top level keys - corresponding to box level properties\n\t\t\t\t\t\tif (uri[0] === \"@\") { return; } // ignore \"@id\", \"@version\" etc\n\t\t\t\t\t\t// not one of those, so must be a\n\t\t\t\t\t\t// < uri > : { prop1 .. prop2 ... }\n\t\t\t\t\t\tu.assert(uri === this_.id, 'can only deserialise this object ');\n\t\t\t\t\t\treturn this_._deserialise_and_set(obj);\n\t\t\t\t\t});\n\t\t\t\t\tu.when(obj_save_dfds).then(function(){ fd.resolve(this_); }).fail(fd.reject);\n\t\t\t\t});\n\t\t\t\treturn fd.promise();\n\t\t\t},\n\t\t\tsync: function(method, model, options){\n\t\t\t\tswitch(method){\n\t\t\t\tcase \"create\": return u.assert(false, \"create is never used for Objs\");\n\t\t\t\tcase \"read\"  : return model._fetch();\n\t\t\t\tcase \"update\":\n\t\t\t\t\treturn  model.box.update([model.id])[0];\n\t\t\t\tcase \"delete\":\n\t\t\t\t\treturn this.box._delete_models([this.id])[0];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\n\t\t// Box =================================================\n\t\t// GraphCollection is the list of Objs in a Graph\n\t\tvar ObjCollection = Backbone.Collection.extend({ model: Obj }),\n\t\t\tFileCollection = Backbone.Collection.extend({ model: File });\n\n\t\t// new client: fetch is always lazy, only gets ids, and\n\t\t// lazily get objects as you go\n\t\tvar Box = Backbone.Model.extend({\n\t\t\tidAttribute:\"@id\",\n\t\t\tdefault_options: { use_websockets:true, ws_auto_reconnect:false\t},\n\t\t\tinitialize:function(attributes, options) {\n\t\t\t\tvar this_ = this;\n\t\t\t\tu.assert(options.store, \"no store provided\");\n\t\t\t\tthis.store = options.store;\n\t\t\t\tthis.set({objcache: new ObjCollection(), objlist: [], files : new FileCollection() });\n\t\t\t\tthis.options = _(this.default_options).chain().clone().extend(options || {}).value();\n\t\t\t\tthis.set_up_websocket();\n\t\t\t\tthis._update_queue = {};\n\t\t\t\tthis._delete_queue = {};\n\t\t\t\tthis._fetching_queue = {};\n\t\t\t\tthis.on('update-from-master', function() {\n\t\t\t\t\t// u.log(\"UPDATE FROM MASTER >> flushing \");\n\t\t\t\t\tthis_._flush_update_queue();\n\t\t\t\t\tthis_._flush_delete_queue();\n\t\t\t\t});\n\t\t\t},\n\t\t\t/// <string> fid file id\n\t\t\t/// Tries to get a file with given id. If it doesn't exist, a file with that name is created.\n\t\t\t/// @return <File> the file\n\t\t\tget_or_create_file:function(fid) {\n\t\t\t\tvar files = this.get('files');\n\t\t\t\tif (files.get(fid) === undefined) {\n\t\t\t\t\tfiles.add(new File({\"@id\": fid}, { box: this }));\n\t\t\t\t}\n\t\t\t\treturn files.get(fid);\n\t\t\t},\n\t\t\tset_up_websocket:function() {\n\t\t\t\tvar this_ = this, server_host = this.store.get('server_host');\n\t\t\t\tif (! this.get_use_websockets() ) { return; }\n\t\t\t\tthis.on('new-token', function(token) {\n\t\t\t\t\tvar ws = this_._ws;\n\t\t\t\t\tif (ws) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tws.close();\n\t\t\t\t\t\t\tdelete this_._ws;\n\t\t\t\t\t\t} catch(e) { u.error(); }\n\t\t\t\t\t}\n\t\t\t\t\tvar protocol = (document.location.protocol === 'https:') ? 'wss:/' : 'ws:/';\n\t\t\t\t\tvar ws_url = [protocol,server_host,'ws'].join('/');\n\t\t\t\t\tws = new WebSocket(ws_url);\n\t\t\t\t\tws.onmessage = function(evt) {\n\t\t\t\t\t\tu.debug('websocket :: incoming a message ', evt.data.toString().substring(0,190));\n\t\t\t\t\t\tvar pdata = JSON.parse(evt.data);\n\t\t\t\t\t\tif (pdata.action === 'diff') {\n\t\t\t\t\t\t\tthis_._diff_update(pdata.data)\n\t\t\t\t\t\t\t\t.then(function() {\n\t\t\t\t\t\t\t\t\tthis_.trigger('update-from-master', this_._get_version());\n\t\t\t\t\t\t\t\t}).fail(function(err) {\n\t\t\t\t\t\t\t\t\tu.error(err); /*  u.log('done diffing '); */\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tws.onopen = function() {\n\t\t\t\t\t\tvar data = WS_MESSAGES_SEND.auth(this_.get('token'));\n\t\t\t\t\t\tws.send(data);\n\t\t\t\t\t\tdata = WS_MESSAGES_SEND.diff();\n\t\t\t\t\t\tws.send(data);\n\t\t\t\t\t\tthis_._ws = ws;\n\t\t\t\t\t\tthis_.trigger('ws-connect');\n\t\t\t\t\t};\n\t\t\t\t\tws.onclose = function(evt) {\n\t\t\t\t\t\t// what do we do now?!\n\t\t\t\t\t\tu.error('websocket closed -- ');\n\t\t\t\t\t\t// TODO\n\t\t\t\t\t\tvar interval;\n\t\t\t\t\t\tinterval = setInterval(function() {\n\t\t\t\t\t\t\tthis_.store.reconnect().then(function() {\n\t\t\t\t\t\t\t\tthis_.get_token().then(function() {\n\t\t\t\t\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},1000);\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t},\n\t\t\tget_use_websockets:function() { return this.options.use_websockets; },\n\t\t\tget_cache_size:function(i) { return this._objcache().length; },\n\t\t\tget_obj_ids:function() { return this._objlist().slice(); },\n\t\t\t_objcache:function() { return this.attributes.objcache; },\n\t\t\t_objlist:function() { return this.attributes.objlist !== undefined ? this.attributes.objlist : []; },\n\t\t\t_set_objlist:function(ol) { return this.set({objlist:ol.slice()}); },\n\t\t\t_get_cached_token:function() { return this.get(\"token\"); },\n\t\t\t_set_token:function(token) { this.set(\"token\", token);\t},\n\t\t\t_set_version:function(v) { this.set(\"version\", v);\t},\n\t\t\t_get_version:function(v) { return this.get(\"version\"); },\n\t\t\tget_token:function() {\n\t\t\t\t// utils.debug('>> get_token ', ' id: ',this.id, ' cid: ',this.cid);\n\t\t\t\t// try { throw new Error(''); } catch(e) { console.error(e); }\n\t\t\t\tvar this_ = this, d = u.deferred();\n\t\t\t\tthis._ajax('POST', 'auth/get_token', { app: this.store.get('app') })\n\t\t\t\t\t.then(function(data) {\n\t\t\t\t\t\tconsole.log('setting token ', data.token);\n\t\t\t\t\t\tthis_._set_token( data.token );\n\t\t\t\t\t\tthis_.trigger('new-token', data.token);\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tget_id:function() { return this.id || this.cid;\t},\n\t\t\t_ajax:function(method, path, data) {\n\t\t\t\tdata = _(_(data||{}).clone()).extend({box: this.id || this.cid, token:this.get('token')});\n\t\t\t\treturn this.store._ajax(method, path, data);\n\t\t\t},\n\t\t\tput_file:function(id,filedata,contenttype) {\n\t\t\t\t// creates a File object and hands it back in the resolve\n\t\t\t\tcontenttype = contenttype || filedata.type;\n\t\t\t\tvar d = u.deferred(), this_ = this, newFile = this.get_or_create_file(id);\n\t\t\t\tnewFile.set({\"content-type\": contenttype});\n\t\t\t\tthis._do_put_file(id,filedata,contenttype).then(function(){\n\t\t\t\t\tu.debug('image put success ');\n\t\t\t\t\td.resolve(newFile);\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tif (err.status === 409) {\n\t\t\t\t\t\tvar cb = function() {\n\t\t\t\t\t\t\tthis_.off('update-from-master', cb, newFile);\n\t\t\t\t\t\t\tthis_._put_file(id, filedata, contenttype).then(d.resolve).fail(d.reject);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis_.on('update-from-master', cb, newFile);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu.error('error putting, dammit ', err);\n\t\t\t\t\t\td.reject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_do_put_file:function(id,file,contenttype) {\n\t\t\t\t// now uses relative url scheme '//blah:port/path';\n\t\t\t\t// all files must be PUT into boxname/files\n\t\t\t\t// here the parameters are get encoded\n\t\t\t\t// // 'http://' + this.store.get('server_host') + \"/\" +  boxid + \"/\" + 'files',\n\t\t\t\tvar boxid = this.id || this.cid,\n\t\t\t\tbase_url = ['/', this.store.get('server_host'), boxid, 'files'].join('/'),\n\t\t\t\toptions = { app: this.store.get('app'), id: id, token:this.get('token'),  box: boxid, version: this._get_version() },\n\t\t\t\toption_params = $.param(options),\n\t\t\t\turl = base_url+\"?\"+option_params,\n\t\t\t\td = u.deferred();\n\t\t\t\tconsole.log(\"PUTTING FILE \", url);\n\t\t\t\tvar ajax_args  = _(_(this.store.ajax_defaults).clone()).extend(\n\t\t\t\t\t{ url: url, method : 'PUT', crossDomain:false, data:file, contentType: contenttype, processData:false }\n\t\t\t\t);\n\t\t\t\treturn $.ajax( ajax_args );\n\t\t\t},\n\t\t\tquery: function(q){\n\t\t\t\t// @TODO ::::::::::::::::::::::::::\n\t\t\t\tu.NotImplementedYet();\n\t\t\t\t// var d = u.deferred();\n\t\t\t\t// this._ajax(this, \"/query\", \"GET\", {\"q\": JSON.stringify(q)})\n\t\t\t\t// \t.then(function(data){\n\t\t\t\t// \t\tconsole.debug(\"query results:\",data);\n\t\t\t\t// \t}).fail(function(data) {\n\t\t\t\t// \t\tconsole.debug(\"fail query\");\n\t\t\t\t// \t});\n\t\t\t\t// return d.promise();\n\t\t\t},\n\t\t\t_diff_update:function(response) {\n\t\t\t\tvar d = u.deferred(), this_ = this, latest_version = response['@to_version'],\n\t\t\t\tadded_ids  = _(response.data.added).keys(),\n\t\t\t\tchanged_ids = _(response.data.changed).keys(),\n\t\t\t\tdeleted_ids = _(response.data.deleted).keys(),\n\t\t\t\tchanged_objs = response.data.changed;\n\n\t\t\t\tu.assert(latest_version !== undefined, 'latest version not provided');\n\t\t\t\tu.assert(added_ids !== undefined, 'added_ids not provided');\n\t\t\t\tu.assert(changed_ids !== undefined, 'changed not provided');\n\t\t\t\tu.assert(deleted_ids !== undefined, 'deleted _ids not provided');\n\n\t\t\t\tif (latest_version <= this_._get_version()) {\n\t\t\t\t\tu.debug('asked to diff update, but already up to date, so just relax!', latest_version, this_._get_version());\n\t\t\t\t\treturn d.resolve();\n\t\t\t\t}\n\t\t\t\tu.debug('setting latest version >> ', latest_version, added_ids, changed_ids, deleted_ids);\n\t\t\t\tthis_._set_version(latest_version);\n\t\t\t\tthis_._update_object_list(undefined, added_ids, deleted_ids);\n\t\t\t\tvar change_dfds = _(changed_objs).map(function(obj, uri) {\n\t\t\t\t\tu.debug(' checking to see if in --- ', uri, this_._objcache().get(uri));\n\t\t\t\t\tu.debug('obj >> ', obj);\n\t\t\t\t\tvar cached_obj = this_._objcache().get(uri), cdfd = u.deferred();\n\t\t\t\t\tif (cached_obj) {\n\t\t\t\t\t\t// { prop : [ {sval1 - @type:\"\"}, {sval2 - @type} ... ]\n\t\t\t\t\t\tvar changed_properties = [];\n\t\t\t\t\t\t// console.log(\"obj deleted \", obj.deleted);\n\t\t\t\t\t\tvar deleted_propval_dfds = _(obj.deleted).map(function(vs, k) {\n\t\t\t\t\t\t\tchanged_properties = _(changed_properties).union([k]);\n\t\t\t\t\t\t\tvar dd = u.deferred();\n\t\t\t\t\t\t\tu.when(vs.map(function(v) {\treturn deserialize_value(v, this_);\t})).then(function(values) {\n\t\t\t\t\t\t\t\tvar new_vals = _(cached_obj.get(k) || []).difference(values);\n\t\t\t\t\t\t\t\t// console.log(\"DESERIALISED deleted values \", values, \" - \", \" new_vals \", new_vals);\n\t\t\t\t\t\t\t\t// window._values = values; window._newvals = new_vals;\n\t\t\t\t\t\t\t\tcached_obj.set(k,new_vals);\n\t\t\t\t\t\t\t\t// semantics - if a property has no value then we delete it\n\t\t\t\t\t\t\t\tif (new_vals.length === 0) { cached_obj.unset(k); }\n\t\t\t\t\t\t\t\tdd.resolve();\n\t\t\t\t\t\t\t}).fail(dd.reject);\n\t\t\t\t\t\t\treturn dd.promise();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tvar added_propval_dfds = _(obj.added).map(function(vs, k) {\n\t\t\t\t\t\t\tchanged_properties = _(changed_properties).union([k]);\n\t\t\t\t\t\t\tvar dd = u.deferred();\n\t\t\t\t\t\t\tu.when(vs.map(function(v) {\treturn deserialize_value(v, this_);\t})).then(function(values) {\n\t\t\t\t\t\t\t\tvar new_vals = (cached_obj.get(k) || []).concat(values);\n\t\t\t\t\t\t\t\tcached_obj.set(k,new_vals);\n\t\t\t\t\t\t\t\tdd.resolve();\n\t\t\t\t\t\t\t}).fail(dd.reject);\n\t\t\t\t\t\t\treturn dd.promise();\n\t\t\t\t\t\t});\n                        var replaced_propval_dfs = _(obj.replaced).map(function(vs, k) {\n                            console.debug(\"Processing replaced property\");\n                            changed_properties = _(changed_properties).union([k]);\n                            var dd = u.deferred();\n                            u.when(vs.map(function(v) { return deserialize_value(v, this_); })).then(function(values) {\n                                var new_vals = values; // this is the difference from added - just replace (by DS)\n                                cached_obj.set(k,new_vals);\n                                dd.resolve();\n                            }).fail(dd.reject);\n                            return dd.promise();\n                        });\n                        u.when(added_propval_dfds.concat(deleted_propval_dfds).concat(replaced_propval_dfs)).then(function() {\n\t\t\t\t\t\t\t// u.debug(\"triggering changed properties \", changed_properties);\n\t\t\t\t\t\t\tchanged_properties.map(function(k) {\n\t\t\t\t\t\t\t\tcached_obj.trigger('change:'+k, (cached_obj.get(k) || []).slice());\n\t\t\t\t\t\t\t\tu.debug(\"trigger! change:\"+k);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcdfd.resolve(cached_obj);\n\t\t\t\t\t\t}).fail(cdfd.reject);\n\t\t\t\t\t\treturn cdfd.promise();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tu.when(change_dfds).then(d.resolve).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_create_model_for_id: function(obj_id){\n\t\t\t\tvar model = new Obj({\"@id\":obj_id}, {box:this});\n\t\t\t\tthis._objcache().add(model);\n\t\t\t\treturn model;\n\t\t\t},\n\t\t\tget_obj:function(objid) {\n\t\t\t\t// get_obj always returns a promise\n\t\t\t\tu.assert(typeof objid === 'string' || typeof objid === 'number', \"objid has to be a number or string\");\n\t\t\t\tvar d = u.deferred(),\n\t\t\t\tcachemodel = this._objcache().get(objid),\n\t\t\t\tfetching_dfd = this._fetching_queue[objid],\n\t\t\t\thasmodel = cachemodel && fetching_dfd === undefined,\n\t\t\t\tthis_ = this;\n\n\t\t\t\tif (hasmodel) {\n\t\t\t\t\tconsole.log('returning cached ', objid);\n\t\t\t\t\td.resolve(cachemodel); return d.promise();\n\t\t\t\t}\n\n\t\t\t\t// check to see if already fetching, then we can tag along\n\t\t\t\tif (fetching_dfd) {\n\t\t\t\t\t// to fix a deadlock condition -\n\t\t\t\t\t// if we fetch someone who loops back to us\n\t\t\t\t\t// then we will never resolve with this code:\n\t\t\t\t\t//\n\t\t\t\t\t// fetching_dfd.then(d.resolve).fail(d.reject);\n\t\t\t\t\t// return d.promise();\n\t\t\t\t\t// --\n\t\t\t\t\t// therefore a fix:\n\t\t\t\t\td.resolve(cachemodel);\n\t\t\t\t\treturn d.promise();\n\t\t\t\t}\n\n\t\t\t\t// if not already fetching then we have to fetch\n\t\t\t\tthis._fetching_queue[objid] = d;\n\t\t\t\tvar model = this_._create_model_for_id(objid);\n\t\t\t\t// if the serve knows about it, then we fetch its definition\n\t\t\t\tconsole.log('objlist ', this._objlist());\n\n\t\t\t\t// old code ::\n\t\t\t\t// if (this._objlist().indexOf(objid) >= 0) {\n\t\t\t\t// \tconsole.log('object exists, going to fetch it ');\n\t\t\t\t// \tmodel.fetch().then(function() {\n\t\t\t\t// \t\td.resolve(model);\n\t\t\t\t// \t\tdelete this_._fetching_queue[objid];\n\t\t\t\t// \t}).fail(d.reject);\n\t\t\t\t// } else {\n\t\t\t\t// \tconsole.log('object doesnt exist, not going to fetch it ');\n\t\t\t\t// \t// otherwise it must be new!\n\t\t\t\t// \tmodel.is_new = true;\n\t\t\t\t// \td.resolve(model);\n\t\t\t\t// }\n\n\t\t\t\tconsole.log('trying to fetch ', objid);\n\t\t\t\tmodel.fetch().then(function() {\n\t\t\t\t\td.resolve(model);\n\t\t\t\t\tdelete this_._fetching_queue[objid];\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tconsole.log('failed.. declaring it new ', objid);\n\t\t\t\t\t// TODO check if 404'd\n\t\t\t\t\tconsole.log('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA err - didnt exist ? ', err);\n\t\t\t\t\tmodel.is_new = true;\n\t\t\t\t\td.resolve(model);\n\t\t\t\t\tdelete this_._fetching_queue[objid];\n\t\t\t\t});\n\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// ----------------------------------------------------\n\t\t\t_update_object_list:function(updated_obj_ids, added, deleted) {\n\t\t\t\tvar current, olds = this._objlist().slice(), this_ = this, news, died;\n\t\t\t\t// u.debug('_update_object_list +', added ? added.length : ' ', '-', deleted ? deleted.length : ' ');\n\t\t\t\t// u.debug('_update_object_list +', added || ' ', deleted || ' ');\n\t\t\t\tif (updated_obj_ids === undefined ) {\n\t\t\t\t\tcurrent = _(olds).chain().union(added).difference(deleted).value();\n\t\t\t\t\tnews = (added || []).slice(); died = (deleted || []).slice();\n\t\t\t\t} else {\n\t\t\t\t\tcurrent = updated_obj_ids.slice();\n\t\t\t\t\tnews = _(current).difference(olds);\n\t\t\t\t\tdied = _(olds).difference(current);\n\t\t\t\t}\n\t\t\t\t// u.debug('old objlist had ', olds.length, ' new has ', current.length, 'news > ', news);\n\t\t\t\tthis._set_objlist(current);\n\t\t\t\tnews.map(function(aid) {\tthis_.trigger('obj-add', aid);\t});\n\t\t\t\tdied.map(function(rid) {\n\t\t\t\t\tthis_.trigger('obj-remove', rid);\n\t\t\t\t\tthis_._objcache().remove(rid);\n\t\t\t\t});\n\t\t\t},\n\t\t\t_is_fetched: function() {\n\t\t\t\treturn this.id !== undefined;\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\t// all fetch really does is retrieve ids!\n\t\t\t\t// new client :: this now _only_ fetches object ids\n\t\t\t\t// return a list of models (each of type Object) to populate a GraphCollection\n\t\t\t\tvar d = u.deferred(), fd = u.deferred(), this_ = this;\n\t\t\t\tif (this._is_fetched()) {\n\t\t\t\t\t// Nope - don't do anything -- we just wait for websockets to update us.\n\t\t\t\t\tfd.resolve();\n\t\t\t\t} else {\n\t\t\t\t\t// otherwise we aren't fetched, so we just do it\n\t\t\t\t\tvar box = this.get_id();\n\t\t\t\t\tthis._ajax(\"GET\",[box,'get_object_ids'].join('/')).then(\n\t\t\t\t\t\tfunction(response){\n\t\t\t\t\t\t\tu.assert(response['@version'] !== undefined, 'no version provided');\n\t\t\t\t\t\t\tthis_.id = this_.get_id(); // sets so that _is_fetched later returns true\n\t\t\t\t\t\t\tthis_._set_version(response['@version']);\n\t\t\t\t\t\t\tthis_._update_object_list(response.ids);\n\t\t\t\t\t\t\tfd.resolve(this_);\n\t\t\t\t\t\t}).fail(fd.reject);\n\t\t\t\t}\n\t\t\t\tfd.then(function() {\n\t\t\t\t\tthis_.trigger('update-from-master', this_._get_version());\n\t\t\t\t\td.resolve(this_);\n\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// -----------------------------------------------\n\t\t\t_check_token_and_fetch : function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (this.get('token') === undefined) {\n\t\t\t\t\tvar d = u.deferred();\n\t\t\t\t\tthis.get_token()\n\t\t\t\t\t\t.then(function() { this_._fetch().then(d.resolve).fail(d.reject);\t})\n\t\t\t\t\t\t.fail(d.reject);\n\t\t\t\t\treturn d.promise();\n\t\t\t\t}\n\t\t\t\treturn this_._fetch();\n\t\t\t},\n\t\t\t_create_box:function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis.store._ajax('POST', 'admin/create_box', { name: this.get_id() } )\n\t\t\t\t\t.then(function() {\n\t\t\t\t\t\tthis_.fetch().then(function() { d.resolve(); }).fail(function(err) { d.reject(err); });\n\t\t\t\t\t}).fail(function(err) { d.reject(err); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tdelete_box:function(boxid) {\n\t\t\t\treturn this.store._ajax('POST','admin/delete_box', { name: boxid } );\n\t\t\t},\n\t\t\t// =============== :: UPDATE ::  ======================\n\t\t\tWHOLE_BOX: \"__UPDATE__WHOLE__BOX__\",\n\t\t\t_add_to_update_queue:function(ids_to_update) {\n\t\t\t\tvar this_ = this, uq = this._update_queue;\n\t\t\t\t// returns the deferreds\n\t\t\t\tids_to_update = ids_to_update === undefined ? [ this.WHOLE_BOX ] : ids_to_update;\n\t\t\t\treturn ids_to_update.map(function(id) {\n\t\t\t\t\tuq[id] = uq[id] || u.deferred();\n\t\t\t\t\treturn uq[id];\n\t\t\t\t});\n\t\t\t},\n\t\t\t_requeue_update:function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (!this._update_timeout) {\n\t\t\t\t\tthis._update_timeout = setTimeout(function() {\n\t\t\t\t\t\tdelete this_._update_timeout;\n\t\t\t\t\t\tthis_._flush_update_queue();\n\t\t\t\t\t}, 300);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_flush_update_queue:function() {\n\t\t\t\tvar this_ = this, uq = this._update_queue, ids_to_update = _(uq).keys();\n\t\t\t\tif (ids_to_update.length === 0) { return ; }\n\t\t\t\tif (this._updating || this._deleting) {\n\t\t\t\t\treturn this._requeue_update();\n\t\t\t\t}\n\n\t\t\t\tthis._update_queue = {};\n\t\t\t\tvar update_arguments = ids_to_update.indexOf(this.WHOLE_BOX) >= 0 ? undefined : ids_to_update;\n\t\t\t\tthis_._updating = true;\n\n\t\t\t\tthis_._do_update(update_arguments).then(function() {\n\t\t\t\t\tdelete this_._updating;\n\t\t\t\t\t// TODO: resolve all of our deferreds now and delete them\n\t\t\t\t\tids_to_update.map(function(id) { uq[id].resolve();\t\t});\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tdelete this_._updating;\n\t\t\t\t\tif (err.status === 409) {\n\t\t\t\t\t\t// add the defferds back in\n\t\t\t\t\t\t_(uq).map(function(d,id) {\n\t\t\t\t\t\t\tif (this_._update_queue[id]) {\n\t\t\t\t\t\t\t\t// someone's already added one back in! let's chain them\n\t\t\t\t\t\t\t\tu.debug('HEYYYYYYYYYYYYYYYYYYYYYY already added in - lets go');\n\t\t\t\t\t\t\t\tthis_._update_queue[id].then(uq[id].resolve).fail(uq[id].reject);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tu.debug('sneaking him back in - lets go');\n\t\t\t\t\t\t\t\tthis_._update_queue[id] = uq[id];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn this_._requeue_update();\n\t\t\t\t\t}\n\t\t\t\t\t// something bad happened, we'd better reject on those deferreds\n\t\t\t\t\tu.error('UPDATE error ', err);\n\t\t\t\t\tids_to_update.map(function(id) { uq[id].reject(err);});\n\t\t\t\t});\n\t\t\t},\n\t\t\t_do_update:function(ids) {\n\t\t\t\t// this actua\n\t\t\t\tconsole.log('box update >> ');\n\t\t\t\tvar d = u.deferred(), version = this.get('version') || 0, this_ = this,\n\t\t\t\tobjs = this._objcache().filter(function(x) { return ids === undefined || ids.indexOf(x.id) >= 0; }),\n\t\t\t\tobj_ids = objs.map(function(x) { return x.id; }),\n\t\t\t\tsobjs = objs.map(function(obj){ return serialize_obj(obj); });\n\t\t\t\tthis._ajax(\"PUT\",  this.get_id() + \"/update\", { version: escape(version), data : JSON.stringify(sobjs)  })\n\t\t\t\t\t.then(function(response) {\n\t\t\t\t\t\tthis_._set_version(response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._update_object_list(undefined, obj_ids, []); // update object list\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tupdate:function(original_ids) {\n\t\t\t\t// this is called by Backbone.save(),\n\t\t\t\tvar dfds = this._add_to_update_queue(original_ids);\n\t\t\t\tthis._flush_update_queue();\n\t\t\t\treturn dfds;\n\t\t\t},\n\t\t\t// =============== :: DELETE ::  ======================\n\t\t\t_add_to_delete_queue:function(ids) {\n\t\t\t\tvar this_ = this, dq = this._delete_queue;\n\t\t\t\treturn ids.map(function(id) {\n\t\t\t\t\tdq[id] = dq[id] || u.deferred();\n\t\t\t\t\treturn dq[id];\n\t\t\t\t});\n\t\t\t},\n\t\t\t_delete_models:function(ids) {\n\t\t\t\tvar dfds =  this._add_to_delete_queue(ids);\n\t\t\t\tthis._flush_delete_queue();\n\t\t\t\treturn dfds;\n\t\t\t},\n\t\t\t_requeue_delete:function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (!this._delete_timeout) {\n\t\t\t\t\tthis._delete_timeout = setTimeout(function() {\n\t\t\t\t\t\tdelete this_._delete_timeout;\n\t\t\t\t\t\tthis_._flush_delete_queue();\n\t\t\t\t\t}, 300);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_flush_delete_queue:function() {\n\t\t\t\tvar this_ = this, dq = this._delete_queue, delete_ids = _(dq).keys();\n\t\t\t\tif (delete_ids.length === 0) { return ; }\n\t\t\t\tif (this._deleting || this._updating) { return this._requeue_delete();  }\n\t\t\t\tthis_._deleting = true;\n\t\t\t\tthis_._do_delete(delete_ids).then(function() {\n\t\t\t\t\tdelete this_._deleting;\n\t\t\t\t\tdelete_ids.map(function(id) {\n\t\t\t\t\t\tdq[id].resolve(); delete dq[id];\n\t\t\t\t\t});\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tdelete this_._deleting;\n\t\t\t\t\tif (err.status === 409) { this_._requeue_delete();\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t_do_delete:function(m_ids) {\n\t\t\t\tvar version = this.get('version') || 0, d = u.deferred(), this_ = this;\n\t\t\t\tthis._ajax('DELETE', this.id+'/', { version:version, data: JSON.stringify(m_ids) })\n\t\t\t\t\t.then(function(response) {\n\t\t\t\t\t\tu.debug('DELETE response NEW version > ', response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._set_version(response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._update_object_list(undefined, [], m_ids); // update object list\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// =============== :: SYNC ::  ======================\n\t\t\tsync: function(method, box, options){\n\t\t\t\tswitch(method)\n\t\t\t\t{\n\t\t\t\tcase \"create\": return box._create_box();\n\t\t\t\tcase \"read\": return box._check_token_and_fetch();\n\t\t\t\tcase \"update\": return box.update()[0];  // save whole box?\n\t\t\t\tcase \"delete\": return this.delete_box(this.get_id()) // hook up to destroy\n\t\t\t\t}\n\t\t\t},\n\t\t\ttoString: function() { return 'box:' + this.get_id(); }\n\t\t});\n\n\t\tvar BoxCollection = Backbone.Collection.extend({ model: Box });\n\n\t\tvar Store =  Backbone.Model.extend({\n\t\t\tdefaults: {\n\t\t\t\tserver_host:DEFAULT_HOST,\n\t\t\t\tapp:\"--default-app-id--\"\n\t\t\t},\n\t\t\tajax_defaults : {\n\t\t\t\tjsonp: false, contentType: \"application/json\",\n\t\t\t\txhrFields: { withCredentials: true }\n\t\t\t},\n\n\t\t\t/// @opt <{}> attributes\n\t\t\t/// @opt <{}> options\n\t\t\t/// @constructor\n\t\t\tinitialize: function(attributes, options){\n\t\t\t\tthis.set({boxes : new BoxCollection([], {store: this})});\n\t\t\t},\n\n\t\t\t/// Check that the\n\t\t\tis_same_domain:function() {\n\t\t\t\treturn this.get('server_host').indexOf(document.location.host) >= 0 && (document.location.port === (this.get('server_port') || ''));\n\t\t\t},\n\t\t\tboxes:function() { return this.attributes.boxes;\t},\n\t\t\tget_box: function(boxid) {\n\t\t\t\tvar b = this.boxes().get(boxid) || this._create(boxid);\n\t\t\t\tif (!b._get_cached_token()) {\n\t\t\t\t\treturn b.get_token().pipe(function() {\n\t\t\t\t\t\treturn b.fetch();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn u.dresolve(b);\n\t\t\t},\n\n\n\t\t\t/// @arg <string|number> boxid: the id for the box\n\t\t\t///\n\t\t\t/// @then (<Box> the box)\n\t\t\t/// @fail\n\t\t\t///   (<{ code: 409 }> response) box already exists\n\t\t\t///   (<{ code: -1, error: error obj }> response) other error\n\t\t\t///\n\t\t\t/// Attempts to create a box with the given ID\n\t\t\tcreate_box: function (boxid) {\n\t\t\t\tu.debug('create box ', boxid);\n\t\t\t\tif (this.boxes().get(boxid)) {\n\t\t\t\t\treturn u.dreject({ code: 409, message: 'Box already exists: ' + boxid });\n\t\t\t\t}\n\t\t\t\tvar c = this._create(boxid), this_ = this;\n\t\t\t\tu.debug('creating ', boxid);\n\t\t\t\treturn c.save().pipe(function() { return this_.get_box(boxid); });\n\t\t\t},\n\t\t\tcheck_login:function() {\n\t\t\t\t// checks whether you can connect to the server and who is logged in.\n\t\t\t\t// returns a deferred that gets passed an argument\n\t\t\t\t// { code:200 (server is okay),  is_authenticated:true/false,  user:<username>  }\n\t\t\t\treturn this._ajax('GET', 'auth/whoami');\n\t\t\t},\n\t\t\t// todo: change to _\n\t\t\tget_info:function() { return this._ajax('GET', 'admin/info'); },\n\t\t\tlogin : function(username,password) {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tthis.set({username:username,password:password});\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis._ajax('POST', 'auth/login', { username: username, password: password })\n\t\t\t\t\t.then(function(l) { this_.trigger('login', username); d.resolve(l); })\n\t\t\t\t\t.fail(function(l) { d.reject(l); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\treconnect:function() {\n\t\t\t\treturn this.login(this.get('username'),this.get('password'));\n\t\t\t},\n\t\t\tlogout : function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis._ajax('POST', 'auth/logout')\n\t\t\t\t\t.then(function(l) { this_.trigger('logout'); d.resolve(l); })\n\t\t\t\t\t.fail(function(l) { d.reject(l); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_create:function(boxid) {\n\t\t\t\tvar b = new Box({}, {store: this});\n\t\t\t\tb.cid = boxid;\n\t\t\t\tthis.boxes().add(b);\n\t\t\t\treturn b;\n\t\t\t},\n\t\t\tget_box_list:function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tthis._ajax('GET','admin/list_boxes')\n\t\t\t\t\t.success(function(data) {d.resolve(data.list);})\n\t\t\t\t\t.fail(function(err) { d.reject(err); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\tthrow new Error('dont fetch a store - any more!');\n\t\t\t\t//\n\t\t\t\t// fetches list of boxes\n\t\t\t\t/* - do not do this\n\t\t\t\tvar this_ = this, d = u.deferred();\n\t\t\t\tthis._ajax('GET','admin/list_boxes')\n\t\t\t\t\t.success(function(data) {\n\t\t\t\t\t\tu.when(data.list.map(function(boxid) { return this_.get_box(boxid); })).then(function(boxes) {\n\t\t\t\t\t\t\t// console.log(\"boxes !! \", boxes);\n\t\t\t\t\t\t\tthis_.boxes().reset(boxes);\n\t\t\t\t\t\t\td.resolve(boxes);\n\t\t\t\t\t\t});\n\t\t\t\t\t}).error(function(e) { d.reject(e); });\n\t\t\t\treturn d.promise();\n\t\t\t\t*/\n\t\t\t},\n\t\t\t_ajax:function(method, path, data) {\n\t\t\t\t// now uses relative url scheme '//blah:port/path';\n\t\t\t\tvar url = ['/', this.get('server_host'), path].join('/');\n\t\t\t\tvar default_data = { app: this.get('app') };\n\t\t\t\tvar options = _(_(this.ajax_defaults).clone()).extend(\n\t\t\t\t\t{ url: url, method : method, crossDomain: !this.is_same_domain(), data: _(default_data).extend(data) }\n\t\t\t\t);\n\t\t\t\treturn $.ajax( options ); // returns a deferred\n\t\t\t},\n\t\t\tsync: function(method, model, options){\n\t\t\t\tswitch(method){\n\t\t\t\tcase \"create\": return u.error('store.create() : cannot create a store'); // TODO\n\t\t\t\tcase \"read\"  : return model._fetch();\n\t\t\t\tcase \"update\": return u.error('store.update() : cannot update a store'); // TODO\n\t\t\t\tcase \"delete\": return u.error('store.delete() : cannot delete a store'); // tODO\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tvar exports = {\n\t\t\tsafe_apply:utils.safe_apply,\n\t\t\tu : utils,\n\t\t\tStore:Store,\n\t\t\tObj: Obj,\n\t\t\tFile:File,\n\t\t\tBox: Box,\n\t\t\tstore: new Store(),\n\t\t\tloaded : utils.deferred()\n\t\t};\n\t\twindow.u = utils;\n\n\t\t// do not fetch boxes\n\t\texports.loaded.resolve(exports);\n\t\treturn exports;\n\n\t}).factory('backbone', function(client, utils) {\n\t\t// this manages backbone-angular mystification\n\t\tvar deregfns = [];\n\t\tvar deep_clone_obj = function(o) {\n\t\t\treturn utils.dict(_(o).map(function(v,k) { return [k, v.concat()]; }));\n\t\t};\n\t\tvar scope_bind = function($scope, name, model) {\n\t\t\tutils.assert(model instanceof Backbone.Model, \"tried to bind something that was not a model\");\n\t\t\twindow._m = model;\n\t\t\tvar clone = deep_clone_obj(_(model.attributes));\n\t\t\tutils.safe_apply($scope, function() { $scope[name] = clone;\t});\n\t\t\tvar findchanges = function(old,new_,fn) {\n\t\t\t\tvar changes = [];\n\t\t\t\t_(old).map(function(v,k) {\n\t\t\t\t\tif (v.length !== new_[k].length || _(v).filter(function(vi, i) { return vi != new_[k][i]; }).length) {\n\t\t\t\t\t\tutils.log('pushing changes ', k, new_[k]);\n\t\t\t\t\t\tchanges.push(k);\n\t\t\t\t\t\tif (fn) { fn(k,new_[k].concat()); }\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn changes;\n\t\t\t};\n\t\t\t// angular -> backbone\n\t\t\tvar dereg = $scope.$watch(name, function() {\n\t\t\t\t// do a quick diff --\n\t\t\t\t// first check to make sure that our brave model is still\n\t\t\t\tif ($scope[name] !== clone) { return true; }\n\t\t\t\tfindchanges(model.attributes, clone, function(k,v) {model.set(k,v); });\n\t\t\t}, true);\n\t\t\tderegfns.push([$scope,name,model,dereg]);\n\t\t\t// backbone -> angular\n\t\t\tmodel.on('change', function(data) {\n\t\t\t\tutils.safe_apply($scope, function() {\n\t\t\t\t\tfindchanges(clone, model.attributes, function(k,v) { clone[k] = v;\t});\n\t\t\t\t});\n\t\t\t},$scope);\n\t\t};\n\t\treturn {\n\t\t\tscope_bind: scope_bind,\n\t\t\tscope_unbind:function($scope,name) {\n\t\t\t\tderegfns.map(function(tuple) {\n\t\t\t\t\tvar scope = tuple[0],name = tuple[1],model = tuple[2],dereg = tuple[3];\n\t\t\t\t\tmodel.off('change', null, scope);\n\t\t\t\t\tdereg();\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t});\n","methods":[],"properties":[],"match":"FileCollection = Backbone.Collection.extend(","name":"FileCollection","start":10028,"extend":"~1","end":10188},{"data":"///\n/// @title INDX\n/// blah\n\n/*global $,_,document,window,console,escape,Backbone,exports,WebSocket */\n/*jslint vars:true, todo:true */\n/*\n\n  indx.js is the JS Client SDK for WebBox WebBox\n  which builds upon Backbone's Model architecture.\n\n  CURRENT TODOs:\n  \t- update only supports updating the entire box\n    - Box.fetch() retrieves _entire box contents_\n\t  ... which is a really bad idea.\n\n  @prerequisites:\n\tjquery 1.8.0 or higher\n\tbackbone.js 0.9.2 or higher\n\tunderscore.js 1.4.2 or higher\n\n  This file is part of INDX\n  Copyright 2012 Max Van Kleek, Daniel Alexander Smith\n  Copyright 2012 University of Southampton\n\n  WebBox is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  WebBox is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with Indx.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n\nangular\n\t.module('indx', ['ui'])\n\t.factory('client',function(utils) {\n\t\tvar u = utils; // to be filled in by dependency\n\t\t// set up our parameters for webbox -\n\t\t// default is that we're loading from an _app_ hosted within\n\t\t// indx.\n\t\tvar DEFAULT_HOST = document.location.host; // which may contain the port\n\t\tvar WS_MESSAGES_SEND = {\n\t\t\tauth: function(token) { return JSON.stringify({action:'auth', token:token}); },\n\t\t\tdiff: function(token) { return JSON.stringify({action:'diff', operation:\"start\"}); }\n\t\t};\n\t\tvar serialize_obj = function(obj) {\n\t\t\tvar uri = obj.id;\n\t\t\tvar out_obj = {};\n\t\t\t$.each(obj.attributes, function(pred, vals){\n\t\t\t\tif (pred[0] === \"_\" || pred[0] === \"@\"){\n\t\t\t\t\t// don't expand @id etc.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar obj_vals = [];\n\t\t\t\tif (!(vals instanceof Array)){\n\t\t\t\t\tvals = [vals];\n\t\t\t\t}\n\t\t\t\t$.each(vals, function(){\n\t\t\t\t\tvar val = this;\n\t\t\t\t\tif (val instanceof File) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.id, \"@type\":\"indx-file\", \"@language\":val.get('content-type')});\n\t\t\t\t\t} else if (val instanceof Obj) {\n\t\t\t\t\t\tobj_vals.push({\"@id\": val.id });\n\t\t\t\t\t} else if (typeof val === \"object\" && (val[\"@value\"] || val[\"@id\"])) {\n\t\t\t\t\t\tobj_vals.push(val); // fully expanded string, e.g. {\"@value\": \"foo\", \"@language\": \"en\" ... }\n\t\t\t\t\t} else if (typeof val === \"string\" || val instanceof String ){\n\t\t\t\t\t\tobj_vals.push({\"@value\": val});\n\t\t\t\t\t} else if (_.isDate(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toISOString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"});\n\t\t\t\t\t} else if (_.isNumber(val) && u.isInteger(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#integer\"});\n\t\t\t\t\t} else if (_.isNumber(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#float\"});\n\t\t\t\t\t} else if (_.isBoolean(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#boolean\"});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu.warn(\"Could not determine type of val \", pred, val);\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString()});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tout_obj[pred] = obj_vals;\n\t\t\t});\n\t\t\tout_obj['@id'] = uri;\n\t\t\treturn out_obj;\n\t\t};\n\n\t\tvar literal_deserializers = {\n\t\t\t'': function(o) { return o['@value']; },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#integer\": function(o) { return parseInt(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#float\": function(o) { return parseFloat(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#double\": function(o) { return parseFloat(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#boolean\": function(o) { return o['@value'].toLowerCase() === 'true'; },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#dateTime\": function(o) { return new Date(Date.parse(o['@value'])); },\n\t\t\t\"indx-file\": function(o,box) {\n\t\t\t\tvar f = box.get_or_create_file(o['@value']);\n\t\t\t\tf.set(\"content-type\", o['@language']);\n\t\t\t\treturn f;\n\t\t\t}\n\t\t};\n\t\tvar deserialize_literal = function(obj, box) {\n\t\t\treturn obj['@value'] !== undefined ? literal_deserializers[ obj['@type'] || '' ](obj, box) : obj;\n\t\t};\n\n\t\tvar deserialize_value = function(s_val, box) {\n\t\t\tvar vd = u.deferred();\n\t\t\t// it's an object, so return that\n\t\t\tif (s_val.hasOwnProperty(\"@id\")) {\n\t\t\t\t// object\n\t\t\t\tbox.get_obj(s_val[\"@id\"]).then(vd.resolve).fail(vd.reject);\n\t\t\t}\n\t\t\telse if (s_val.hasOwnProperty(\"@value\")) {\n\t\t\t\t// literal\n\t\t\t\tvd.resolve(deserialize_literal(s_val, box));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// don't know what it is!\n\t\t\t\tvd.reject('cannot unpack value ', s_val);\n\t\t\t}\n\t\t\treturn vd.promise();\n\t\t};\n\n\t\tvar File =  Backbone.Model.extend({\n\t\t\tidAttribute: \"@id\", // the URI attribute is '@id' in JSON-LD\n\t\t\tinitialize:function(attrs, options) {\n\t\t\t\tu.debug('options >> ', attrs, options );\n\t\t\t\tthis.box = options.box;\n\t\t\t},\n\t\t\tget_id:function() { return this.id;\t},\n\t\t\tget_url:function() {\n\t\t\t\tvar params = {\n\t\t\t\t\tid:this.get_id(),\n\t\t\t\t\tapp:this.box.store.get('app'),\n\t\t\t\t\ttoken:this.box.get('token'),\n\t\t\t\t\tbox:this.box.get_id()\n\t\t\t\t}, url = ['/', this.box.store.get('server_host'), this.box.id, 'files'].join('/') + '?' + $.param(params);\n\t\t\t\t// u.debug(\"IMAGE URL IS \", url, params);\n\t\t\t\treturn url;\n\t\t\t}\n\t\t});\n\n\n\t\t// MAP OF THIS MODUULE :::::::::::::: -----\n\t\t//\n\t\t// An Obj is a single instance, thing in Indx.\n\t\t//\n\t\t// A Box is a model that has an attribute called 'Objs'.\n\t\t// ...  which is a Backbone.Collection of Graph objects.\n\t\t//\n\t\t// A _Store_ represents a single Indx server, which has an\n\t\t//\t attribute called 'boxes' -\n\t\t// ... which is a collection of Box objects\n\t\tvar Obj =  Backbone.Model.extend({\n\t\t\tidAttribute: \"@id\", // the URI attribute is '@id' in JSON-LD\n\t\t\tinitialize:function(attrs, options) {\n\t\t\t\tthis.box = options.box;\n\t\t\t},\n\t\t\t_is_fetched: function() { return this._fetched || false; },\n\t\t\t_set_fetched : function() { this._fetched = true; },\n\t\t\tget_id:function() { return this.id;\t},\n\t\t\t_value_to_array:function(k,v) {\n\t\t\t\tif (k === '@id') { return v; }\n\t\t\t\tif (!_(v).isUndefined() && !_(v).isArray()) {\n\t\t\t\t\treturn [v];\n\t\t\t\t}\n\t\t\t\treturn v;\n\t\t\t},\n\t\t\t_all_values_to_arrays:function(o) {\n\t\t\t\tif (!_(o).isObject()) { utils.error(' not an object', o); return o; }\n\t\t\t\tvar this_ = this;\n\t\t\t\t// ?!?! this isn't doing anything (!!)\n\t\t\t\treturn u.dict(_(o).map(function(v,k) {\n\t\t\t\t\tvar val = this_._value_to_array(k,v);\n\t\t\t\t\tif (u.defined(val)) { return [k,val]; }\n\t\t\t\t\treturn undefined;\n\t\t\t\t}).filter(u.defined));\n\t\t\t},\n\t\t\tset:function(k,v,options) {\n\t\t\t\t// set is tricky because it can be called like\n\t\t\t\t// set('foo',123) or set({foo:123})\n\t\t\t\tif (typeof k === 'string') { v = this._value_to_array(k,v);\t}\n\t\t\t\telse {\tk = this._all_values_to_arrays(k);\t}\n\t\t\t\treturn Backbone.Model.prototype.set.apply(this,[k,v,options]);\n\t\t\t},\n\t\t\tdelete_properties:function(props, silent)  {\n\t\t\t\tvar this_ = this;\n\t\t\t\tprops.map(function(p) { this_.unset(p, silent ? {silent:true} : {}); });\n\t\t\t},\n\t\t\t_deserialise_and_set:function(s_obj, silent) {\n\t\t\t\t// returns a promise\n\t\t\t\tvar this_ = this;\n\t\t\t\tvar dfds = _(s_obj).map(function(vals, key) {\n\t\t\t\t\tvar kd = u.deferred();\n\t\t\t\t\tif (key.indexOf('@') === 0) { return; }\n\t\t\t\t\tvar val_dfds = vals.map(function(val) {\n\t\t\t\t\t\tvar vd = u.deferred();\n\t\t\t\t\t\t// it's an object, so return that\n\t\t\t\t\t\tif (val.hasOwnProperty(\"@id\")) {\n\t\t\t\t\t\t\t// object\n\t\t\t\t\t\t\tthis_.box.get_obj(val[\"@id\"]).then(vd.resolve).fail(vd.reject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (val.hasOwnProperty(\"@value\")) {\n\t\t\t\t\t\t\t// literal\n\t\t\t\t\t\t\tvd.resolve(deserialize_literal(val, this_.box));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// don't know what it is!\n\t\t\t\t\t\t\tvd.reject('cannot unpack value ', val);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn vd.promise();\n\t\t\t\t\t});\n\t\t\t\t\tu.when(val_dfds).then(function(obj_vals) {\n\t\t\t\t\t\t// only update keys that have changed\n\t\t\t\t\t\tvar prev_vals = this_.get(key);\n\t\t\t\t\t\tif ( prev_vals === undefined || obj_vals.length !== prev_vals.length ||\n\t\t\t\t\t\t\t _(obj_vals).difference(prev_vals).length > 0 ||\n\t\t\t\t\t\t\t _(prev_vals).difference(obj_vals).length > 0) {\n\t\t\t\t\t\t\tthis_.set(key, obj_vals, { silent : silent });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkd.resolve();\n\t\t\t\t\t}).fail(kd.reject);\n\t\t\t\t\treturn kd.promise();\n\t\t\t\t}).filter(u.defined);\n\t\t\t\treturn u.when(dfds);\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\tvar this_ = this, fd = u.deferred(), box = this.box.get_id();\n\t\t\t\tthis.box._ajax('GET', box, {'id':this.id}).then(function(response) {\n\t\t\t\t\tthis_._set_fetched(true);\n\t\t\t\t\tvar objdata = response.data;\n\t\t\t\t\tif (objdata['@version'] === undefined) {\n\t\t\t\t\t\t// then the server thinks we've been deleted, so let's just die.\n\t\t\t\t\t\treturn fd.reject(this_.id);\n\t\t\t\t\t\t// old code:\n\t\t\t\t\t\t// according to the server, we're dead.\n\t\t\t\t\t\t// console.log('zombie detected ', this_.id);\n\t\t\t\t\t\t// this_.cid = this_.id;\n\t\t\t\t\t\t// this_.unset({});\n\t\t\t\t\t\t// delete this_.id;\n\t\t\t\t\t\t// fd.resolve();\n\t\t\t\t\t\t// return;\n\t\t\t\t\t}\n\t\t\t\t\t// we are at current known version as far as we know\n\t\t\t\t\tvar obj_save_dfds = _(objdata).map(function(obj,uri) {\n\t\t\t\t\t\t// top level keys - corresponding to box level properties\n\t\t\t\t\t\tif (uri[0] === \"@\") { return; } // ignore \"@id\", \"@version\" etc\n\t\t\t\t\t\t// not one of those, so must be a\n\t\t\t\t\t\t// < uri > : { prop1 .. prop2 ... }\n\t\t\t\t\t\tu.assert(uri === this_.id, 'can only deserialise this object ');\n\t\t\t\t\t\treturn this_._deserialise_and_set(obj);\n\t\t\t\t\t});\n\t\t\t\t\tu.when(obj_save_dfds).then(function(){ fd.resolve(this_); }).fail(fd.reject);\n\t\t\t\t});\n\t\t\t\treturn fd.promise();\n\t\t\t},\n\t\t\tsync: function(method, model, options){\n\t\t\t\tswitch(method){\n\t\t\t\tcase \"create\": return u.assert(false, \"create is never used for Objs\");\n\t\t\t\tcase \"read\"  : return model._fetch();\n\t\t\t\tcase \"update\":\n\t\t\t\t\treturn  model.box.update([model.id])[0];\n\t\t\t\tcase \"delete\":\n\t\t\t\t\treturn this.box._delete_models([this.id])[0];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\n\t\t// Box =================================================\n\t\t// GraphCollection is the list of Objs in a Graph\n\t\tvar ObjCollection = Backbone.Collection.extend({ model: Obj }),\n\t\t\tFileCollection = Backbone.Collection.extend({ model: File });\n\n\t\t// new client: fetch is always lazy, only gets ids, and\n\t\t// lazily get objects as you go\n\t\tvar Box = Backbone.Model.extend({\n\t\t\tidAttribute:\"@id\",\n\t\t\tdefault_options: { use_websockets:true, ws_auto_reconnect:false\t},\n\t\t\tinitialize:function(attributes, options) {\n\t\t\t\tvar this_ = this;\n\t\t\t\tu.assert(options.store, \"no store provided\");\n\t\t\t\tthis.store = options.store;\n\t\t\t\tthis.set({objcache: new ObjCollection(), objlist: [], files : new FileCollection() });\n\t\t\t\tthis.options = _(this.default_options).chain().clone().extend(options || {}).value();\n\t\t\t\tthis.set_up_websocket();\n\t\t\t\tthis._update_queue = {};\n\t\t\t\tthis._delete_queue = {};\n\t\t\t\tthis._fetching_queue = {};\n\t\t\t\tthis.on('update-from-master', function() {\n\t\t\t\t\t// u.log(\"UPDATE FROM MASTER >> flushing \");\n\t\t\t\t\tthis_._flush_update_queue();\n\t\t\t\t\tthis_._flush_delete_queue();\n\t\t\t\t});\n\t\t\t},\n\t\t\t/// <string> fid file id\n\t\t\t/// Tries to get a file with given id. If it doesn't exist, a file with that name is created.\n\t\t\t/// @return <File> the file\n\t\t\tget_or_create_file:function(fid) {\n\t\t\t\tvar files = this.get('files');\n\t\t\t\tif (files.get(fid) === undefined) {\n\t\t\t\t\tfiles.add(new File({\"@id\": fid}, { box: this }));\n\t\t\t\t}\n\t\t\t\treturn files.get(fid);\n\t\t\t},\n\t\t\tset_up_websocket:function() {\n\t\t\t\tvar this_ = this, server_host = this.store.get('server_host');\n\t\t\t\tif (! this.get_use_websockets() ) { return; }\n\t\t\t\tthis.on('new-token', function(token) {\n\t\t\t\t\tvar ws = this_._ws;\n\t\t\t\t\tif (ws) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tws.close();\n\t\t\t\t\t\t\tdelete this_._ws;\n\t\t\t\t\t\t} catch(e) { u.error(); }\n\t\t\t\t\t}\n\t\t\t\t\tvar protocol = (document.location.protocol === 'https:') ? 'wss:/' : 'ws:/';\n\t\t\t\t\tvar ws_url = [protocol,server_host,'ws'].join('/');\n\t\t\t\t\tws = new WebSocket(ws_url);\n\t\t\t\t\tws.onmessage = function(evt) {\n\t\t\t\t\t\tu.debug('websocket :: incoming a message ', evt.data.toString().substring(0,190));\n\t\t\t\t\t\tvar pdata = JSON.parse(evt.data);\n\t\t\t\t\t\tif (pdata.action === 'diff') {\n\t\t\t\t\t\t\tthis_._diff_update(pdata.data)\n\t\t\t\t\t\t\t\t.then(function() {\n\t\t\t\t\t\t\t\t\tthis_.trigger('update-from-master', this_._get_version());\n\t\t\t\t\t\t\t\t}).fail(function(err) {\n\t\t\t\t\t\t\t\t\tu.error(err); /*  u.log('done diffing '); */\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tws.onopen = function() {\n\t\t\t\t\t\tvar data = WS_MESSAGES_SEND.auth(this_.get('token'));\n\t\t\t\t\t\tws.send(data);\n\t\t\t\t\t\tdata = WS_MESSAGES_SEND.diff();\n\t\t\t\t\t\tws.send(data);\n\t\t\t\t\t\tthis_._ws = ws;\n\t\t\t\t\t\tthis_.trigger('ws-connect');\n\t\t\t\t\t};\n\t\t\t\t\tws.onclose = function(evt) {\n\t\t\t\t\t\t// what do we do now?!\n\t\t\t\t\t\tu.error('websocket closed -- ');\n\t\t\t\t\t\t// TODO\n\t\t\t\t\t\tvar interval;\n\t\t\t\t\t\tinterval = setInterval(function() {\n\t\t\t\t\t\t\tthis_.store.reconnect().then(function() {\n\t\t\t\t\t\t\t\tthis_.get_token().then(function() {\n\t\t\t\t\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},1000);\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t},\n\t\t\tget_use_websockets:function() { return this.options.use_websockets; },\n\t\t\tget_cache_size:function(i) { return this._objcache().length; },\n\t\t\tget_obj_ids:function() { return this._objlist().slice(); },\n\t\t\t_objcache:function() { return this.attributes.objcache; },\n\t\t\t_objlist:function() { return this.attributes.objlist !== undefined ? this.attributes.objlist : []; },\n\t\t\t_set_objlist:function(ol) { return this.set({objlist:ol.slice()}); },\n\t\t\t_get_cached_token:function() { return this.get(\"token\"); },\n\t\t\t_set_token:function(token) { this.set(\"token\", token);\t},\n\t\t\t_set_version:function(v) { this.set(\"version\", v);\t},\n\t\t\t_get_version:function(v) { return this.get(\"version\"); },\n\t\t\tget_token:function() {\n\t\t\t\t// utils.debug('>> get_token ', ' id: ',this.id, ' cid: ',this.cid);\n\t\t\t\t// try { throw new Error(''); } catch(e) { console.error(e); }\n\t\t\t\tvar this_ = this, d = u.deferred();\n\t\t\t\tthis._ajax('POST', 'auth/get_token', { app: this.store.get('app') })\n\t\t\t\t\t.then(function(data) {\n\t\t\t\t\t\tconsole.log('setting token ', data.token);\n\t\t\t\t\t\tthis_._set_token( data.token );\n\t\t\t\t\t\tthis_.trigger('new-token', data.token);\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tget_id:function() { return this.id || this.cid;\t},\n\t\t\t_ajax:function(method, path, data) {\n\t\t\t\tdata = _(_(data||{}).clone()).extend({box: this.id || this.cid, token:this.get('token')});\n\t\t\t\treturn this.store._ajax(method, path, data);\n\t\t\t},\n\t\t\tput_file:function(id,filedata,contenttype) {\n\t\t\t\t// creates a File object and hands it back in the resolve\n\t\t\t\tcontenttype = contenttype || filedata.type;\n\t\t\t\tvar d = u.deferred(), this_ = this, newFile = this.get_or_create_file(id);\n\t\t\t\tnewFile.set({\"content-type\": contenttype});\n\t\t\t\tthis._do_put_file(id,filedata,contenttype).then(function(){\n\t\t\t\t\tu.debug('image put success ');\n\t\t\t\t\td.resolve(newFile);\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tif (err.status === 409) {\n\t\t\t\t\t\tvar cb = function() {\n\t\t\t\t\t\t\tthis_.off('update-from-master', cb, newFile);\n\t\t\t\t\t\t\tthis_._put_file(id, filedata, contenttype).then(d.resolve).fail(d.reject);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis_.on('update-from-master', cb, newFile);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu.error('error putting, dammit ', err);\n\t\t\t\t\t\td.reject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_do_put_file:function(id,file,contenttype) {\n\t\t\t\t// now uses relative url scheme '//blah:port/path';\n\t\t\t\t// all files must be PUT into boxname/files\n\t\t\t\t// here the parameters are get encoded\n\t\t\t\t// // 'http://' + this.store.get('server_host') + \"/\" +  boxid + \"/\" + 'files',\n\t\t\t\tvar boxid = this.id || this.cid,\n\t\t\t\tbase_url = ['/', this.store.get('server_host'), boxid, 'files'].join('/'),\n\t\t\t\toptions = { app: this.store.get('app'), id: id, token:this.get('token'),  box: boxid, version: this._get_version() },\n\t\t\t\toption_params = $.param(options),\n\t\t\t\turl = base_url+\"?\"+option_params,\n\t\t\t\td = u.deferred();\n\t\t\t\tconsole.log(\"PUTTING FILE \", url);\n\t\t\t\tvar ajax_args  = _(_(this.store.ajax_defaults).clone()).extend(\n\t\t\t\t\t{ url: url, method : 'PUT', crossDomain:false, data:file, contentType: contenttype, processData:false }\n\t\t\t\t);\n\t\t\t\treturn $.ajax( ajax_args );\n\t\t\t},\n\t\t\tquery: function(q){\n\t\t\t\t// @TODO ::::::::::::::::::::::::::\n\t\t\t\tu.NotImplementedYet();\n\t\t\t\t// var d = u.deferred();\n\t\t\t\t// this._ajax(this, \"/query\", \"GET\", {\"q\": JSON.stringify(q)})\n\t\t\t\t// \t.then(function(data){\n\t\t\t\t// \t\tconsole.debug(\"query results:\",data);\n\t\t\t\t// \t}).fail(function(data) {\n\t\t\t\t// \t\tconsole.debug(\"fail query\");\n\t\t\t\t// \t});\n\t\t\t\t// return d.promise();\n\t\t\t},\n\t\t\t_diff_update:function(response) {\n\t\t\t\tvar d = u.deferred(), this_ = this, latest_version = response['@to_version'],\n\t\t\t\tadded_ids  = _(response.data.added).keys(),\n\t\t\t\tchanged_ids = _(response.data.changed).keys(),\n\t\t\t\tdeleted_ids = _(response.data.deleted).keys(),\n\t\t\t\tchanged_objs = response.data.changed;\n\n\t\t\t\tu.assert(latest_version !== undefined, 'latest version not provided');\n\t\t\t\tu.assert(added_ids !== undefined, 'added_ids not provided');\n\t\t\t\tu.assert(changed_ids !== undefined, 'changed not provided');\n\t\t\t\tu.assert(deleted_ids !== undefined, 'deleted _ids not provided');\n\n\t\t\t\tif (latest_version <= this_._get_version()) {\n\t\t\t\t\tu.debug('asked to diff update, but already up to date, so just relax!', latest_version, this_._get_version());\n\t\t\t\t\treturn d.resolve();\n\t\t\t\t}\n\t\t\t\tu.debug('setting latest version >> ', latest_version, added_ids, changed_ids, deleted_ids);\n\t\t\t\tthis_._set_version(latest_version);\n\t\t\t\tthis_._update_object_list(undefined, added_ids, deleted_ids);\n\t\t\t\tvar change_dfds = _(changed_objs).map(function(obj, uri) {\n\t\t\t\t\tu.debug(' checking to see if in --- ', uri, this_._objcache().get(uri));\n\t\t\t\t\tu.debug('obj >> ', obj);\n\t\t\t\t\tvar cached_obj = this_._objcache().get(uri), cdfd = u.deferred();\n\t\t\t\t\tif (cached_obj) {\n\t\t\t\t\t\t// { prop : [ {sval1 - @type:\"\"}, {sval2 - @type} ... ]\n\t\t\t\t\t\tvar changed_properties = [];\n\t\t\t\t\t\t// console.log(\"obj deleted \", obj.deleted);\n\t\t\t\t\t\tvar deleted_propval_dfds = _(obj.deleted).map(function(vs, k) {\n\t\t\t\t\t\t\tchanged_properties = _(changed_properties).union([k]);\n\t\t\t\t\t\t\tvar dd = u.deferred();\n\t\t\t\t\t\t\tu.when(vs.map(function(v) {\treturn deserialize_value(v, this_);\t})).then(function(values) {\n\t\t\t\t\t\t\t\tvar new_vals = _(cached_obj.get(k) || []).difference(values);\n\t\t\t\t\t\t\t\t// console.log(\"DESERIALISED deleted values \", values, \" - \", \" new_vals \", new_vals);\n\t\t\t\t\t\t\t\t// window._values = values; window._newvals = new_vals;\n\t\t\t\t\t\t\t\tcached_obj.set(k,new_vals);\n\t\t\t\t\t\t\t\t// semantics - if a property has no value then we delete it\n\t\t\t\t\t\t\t\tif (new_vals.length === 0) { cached_obj.unset(k); }\n\t\t\t\t\t\t\t\tdd.resolve();\n\t\t\t\t\t\t\t}).fail(dd.reject);\n\t\t\t\t\t\t\treturn dd.promise();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tvar added_propval_dfds = _(obj.added).map(function(vs, k) {\n\t\t\t\t\t\t\tchanged_properties = _(changed_properties).union([k]);\n\t\t\t\t\t\t\tvar dd = u.deferred();\n\t\t\t\t\t\t\tu.when(vs.map(function(v) {\treturn deserialize_value(v, this_);\t})).then(function(values) {\n\t\t\t\t\t\t\t\tvar new_vals = (cached_obj.get(k) || []).concat(values);\n\t\t\t\t\t\t\t\tcached_obj.set(k,new_vals);\n\t\t\t\t\t\t\t\tdd.resolve();\n\t\t\t\t\t\t\t}).fail(dd.reject);\n\t\t\t\t\t\t\treturn dd.promise();\n\t\t\t\t\t\t});\n                        var replaced_propval_dfs = _(obj.replaced).map(function(vs, k) {\n                            console.debug(\"Processing replaced property\");\n                            changed_properties = _(changed_properties).union([k]);\n                            var dd = u.deferred();\n                            u.when(vs.map(function(v) { return deserialize_value(v, this_); })).then(function(values) {\n                                var new_vals = values; // this is the difference from added - just replace (by DS)\n                                cached_obj.set(k,new_vals);\n                                dd.resolve();\n                            }).fail(dd.reject);\n                            return dd.promise();\n                        });\n                        u.when(added_propval_dfds.concat(deleted_propval_dfds).concat(replaced_propval_dfs)).then(function() {\n\t\t\t\t\t\t\t// u.debug(\"triggering changed properties \", changed_properties);\n\t\t\t\t\t\t\tchanged_properties.map(function(k) {\n\t\t\t\t\t\t\t\tcached_obj.trigger('change:'+k, (cached_obj.get(k) || []).slice());\n\t\t\t\t\t\t\t\tu.debug(\"trigger! change:\"+k);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcdfd.resolve(cached_obj);\n\t\t\t\t\t\t}).fail(cdfd.reject);\n\t\t\t\t\t\treturn cdfd.promise();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tu.when(change_dfds).then(d.resolve).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_create_model_for_id: function(obj_id){\n\t\t\t\tvar model = new Obj({\"@id\":obj_id}, {box:this});\n\t\t\t\tthis._objcache().add(model);\n\t\t\t\treturn model;\n\t\t\t},\n\t\t\tget_obj:function(objid) {\n\t\t\t\t// get_obj always returns a promise\n\t\t\t\tu.assert(typeof objid === 'string' || typeof objid === 'number', \"objid has to be a number or string\");\n\t\t\t\tvar d = u.deferred(),\n\t\t\t\tcachemodel = this._objcache().get(objid),\n\t\t\t\tfetching_dfd = this._fetching_queue[objid],\n\t\t\t\thasmodel = cachemodel && fetching_dfd === undefined,\n\t\t\t\tthis_ = this;\n\n\t\t\t\tif (hasmodel) {\n\t\t\t\t\tconsole.log('returning cached ', objid);\n\t\t\t\t\td.resolve(cachemodel); return d.promise();\n\t\t\t\t}\n\n\t\t\t\t// check to see if already fetching, then we can tag along\n\t\t\t\tif (fetching_dfd) {\n\t\t\t\t\t// to fix a deadlock condition -\n\t\t\t\t\t// if we fetch someone who loops back to us\n\t\t\t\t\t// then we will never resolve with this code:\n\t\t\t\t\t//\n\t\t\t\t\t// fetching_dfd.then(d.resolve).fail(d.reject);\n\t\t\t\t\t// return d.promise();\n\t\t\t\t\t// --\n\t\t\t\t\t// therefore a fix:\n\t\t\t\t\td.resolve(cachemodel);\n\t\t\t\t\treturn d.promise();\n\t\t\t\t}\n\n\t\t\t\t// if not already fetching then we have to fetch\n\t\t\t\tthis._fetching_queue[objid] = d;\n\t\t\t\tvar model = this_._create_model_for_id(objid);\n\t\t\t\t// if the serve knows about it, then we fetch its definition\n\t\t\t\tconsole.log('objlist ', this._objlist());\n\n\t\t\t\t// old code ::\n\t\t\t\t// if (this._objlist().indexOf(objid) >= 0) {\n\t\t\t\t// \tconsole.log('object exists, going to fetch it ');\n\t\t\t\t// \tmodel.fetch().then(function() {\n\t\t\t\t// \t\td.resolve(model);\n\t\t\t\t// \t\tdelete this_._fetching_queue[objid];\n\t\t\t\t// \t}).fail(d.reject);\n\t\t\t\t// } else {\n\t\t\t\t// \tconsole.log('object doesnt exist, not going to fetch it ');\n\t\t\t\t// \t// otherwise it must be new!\n\t\t\t\t// \tmodel.is_new = true;\n\t\t\t\t// \td.resolve(model);\n\t\t\t\t// }\n\n\t\t\t\tconsole.log('trying to fetch ', objid);\n\t\t\t\tmodel.fetch().then(function() {\n\t\t\t\t\td.resolve(model);\n\t\t\t\t\tdelete this_._fetching_queue[objid];\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tconsole.log('failed.. declaring it new ', objid);\n\t\t\t\t\t// TODO check if 404'd\n\t\t\t\t\tconsole.log('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA err - didnt exist ? ', err);\n\t\t\t\t\tmodel.is_new = true;\n\t\t\t\t\td.resolve(model);\n\t\t\t\t\tdelete this_._fetching_queue[objid];\n\t\t\t\t});\n\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// ----------------------------------------------------\n\t\t\t_update_object_list:function(updated_obj_ids, added, deleted) {\n\t\t\t\tvar current, olds = this._objlist().slice(), this_ = this, news, died;\n\t\t\t\t// u.debug('_update_object_list +', added ? added.length : ' ', '-', deleted ? deleted.length : ' ');\n\t\t\t\t// u.debug('_update_object_list +', added || ' ', deleted || ' ');\n\t\t\t\tif (updated_obj_ids === undefined ) {\n\t\t\t\t\tcurrent = _(olds).chain().union(added).difference(deleted).value();\n\t\t\t\t\tnews = (added || []).slice(); died = (deleted || []).slice();\n\t\t\t\t} else {\n\t\t\t\t\tcurrent = updated_obj_ids.slice();\n\t\t\t\t\tnews = _(current).difference(olds);\n\t\t\t\t\tdied = _(olds).difference(current);\n\t\t\t\t}\n\t\t\t\t// u.debug('old objlist had ', olds.length, ' new has ', current.length, 'news > ', news);\n\t\t\t\tthis._set_objlist(current);\n\t\t\t\tnews.map(function(aid) {\tthis_.trigger('obj-add', aid);\t});\n\t\t\t\tdied.map(function(rid) {\n\t\t\t\t\tthis_.trigger('obj-remove', rid);\n\t\t\t\t\tthis_._objcache().remove(rid);\n\t\t\t\t});\n\t\t\t},\n\t\t\t_is_fetched: function() {\n\t\t\t\treturn this.id !== undefined;\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\t// all fetch really does is retrieve ids!\n\t\t\t\t// new client :: this now _only_ fetches object ids\n\t\t\t\t// return a list of models (each of type Object) to populate a GraphCollection\n\t\t\t\tvar d = u.deferred(), fd = u.deferred(), this_ = this;\n\t\t\t\tif (this._is_fetched()) {\n\t\t\t\t\t// Nope - don't do anything -- we just wait for websockets to update us.\n\t\t\t\t\tfd.resolve();\n\t\t\t\t} else {\n\t\t\t\t\t// otherwise we aren't fetched, so we just do it\n\t\t\t\t\tvar box = this.get_id();\n\t\t\t\t\tthis._ajax(\"GET\",[box,'get_object_ids'].join('/')).then(\n\t\t\t\t\t\tfunction(response){\n\t\t\t\t\t\t\tu.assert(response['@version'] !== undefined, 'no version provided');\n\t\t\t\t\t\t\tthis_.id = this_.get_id(); // sets so that _is_fetched later returns true\n\t\t\t\t\t\t\tthis_._set_version(response['@version']);\n\t\t\t\t\t\t\tthis_._update_object_list(response.ids);\n\t\t\t\t\t\t\tfd.resolve(this_);\n\t\t\t\t\t\t}).fail(fd.reject);\n\t\t\t\t}\n\t\t\t\tfd.then(function() {\n\t\t\t\t\tthis_.trigger('update-from-master', this_._get_version());\n\t\t\t\t\td.resolve(this_);\n\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// -----------------------------------------------\n\t\t\t_check_token_and_fetch : function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (this.get('token') === undefined) {\n\t\t\t\t\tvar d = u.deferred();\n\t\t\t\t\tthis.get_token()\n\t\t\t\t\t\t.then(function() { this_._fetch().then(d.resolve).fail(d.reject);\t})\n\t\t\t\t\t\t.fail(d.reject);\n\t\t\t\t\treturn d.promise();\n\t\t\t\t}\n\t\t\t\treturn this_._fetch();\n\t\t\t},\n\t\t\t_create_box:function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis.store._ajax('POST', 'admin/create_box', { name: this.get_id() } )\n\t\t\t\t\t.then(function() {\n\t\t\t\t\t\tthis_.fetch().then(function() { d.resolve(); }).fail(function(err) { d.reject(err); });\n\t\t\t\t\t}).fail(function(err) { d.reject(err); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tdelete_box:function(boxid) {\n\t\t\t\treturn this.store._ajax('POST','admin/delete_box', { name: boxid } );\n\t\t\t},\n\t\t\t// =============== :: UPDATE ::  ======================\n\t\t\tWHOLE_BOX: \"__UPDATE__WHOLE__BOX__\",\n\t\t\t_add_to_update_queue:function(ids_to_update) {\n\t\t\t\tvar this_ = this, uq = this._update_queue;\n\t\t\t\t// returns the deferreds\n\t\t\t\tids_to_update = ids_to_update === undefined ? [ this.WHOLE_BOX ] : ids_to_update;\n\t\t\t\treturn ids_to_update.map(function(id) {\n\t\t\t\t\tuq[id] = uq[id] || u.deferred();\n\t\t\t\t\treturn uq[id];\n\t\t\t\t});\n\t\t\t},\n\t\t\t_requeue_update:function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (!this._update_timeout) {\n\t\t\t\t\tthis._update_timeout = setTimeout(function() {\n\t\t\t\t\t\tdelete this_._update_timeout;\n\t\t\t\t\t\tthis_._flush_update_queue();\n\t\t\t\t\t}, 300);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_flush_update_queue:function() {\n\t\t\t\tvar this_ = this, uq = this._update_queue, ids_to_update = _(uq).keys();\n\t\t\t\tif (ids_to_update.length === 0) { return ; }\n\t\t\t\tif (this._updating || this._deleting) {\n\t\t\t\t\treturn this._requeue_update();\n\t\t\t\t}\n\n\t\t\t\tthis._update_queue = {};\n\t\t\t\tvar update_arguments = ids_to_update.indexOf(this.WHOLE_BOX) >= 0 ? undefined : ids_to_update;\n\t\t\t\tthis_._updating = true;\n\n\t\t\t\tthis_._do_update(update_arguments).then(function() {\n\t\t\t\t\tdelete this_._updating;\n\t\t\t\t\t// TODO: resolve all of our deferreds now and delete them\n\t\t\t\t\tids_to_update.map(function(id) { uq[id].resolve();\t\t});\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tdelete this_._updating;\n\t\t\t\t\tif (err.status === 409) {\n\t\t\t\t\t\t// add the defferds back in\n\t\t\t\t\t\t_(uq).map(function(d,id) {\n\t\t\t\t\t\t\tif (this_._update_queue[id]) {\n\t\t\t\t\t\t\t\t// someone's already added one back in! let's chain them\n\t\t\t\t\t\t\t\tu.debug('HEYYYYYYYYYYYYYYYYYYYYYY already added in - lets go');\n\t\t\t\t\t\t\t\tthis_._update_queue[id].then(uq[id].resolve).fail(uq[id].reject);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tu.debug('sneaking him back in - lets go');\n\t\t\t\t\t\t\t\tthis_._update_queue[id] = uq[id];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn this_._requeue_update();\n\t\t\t\t\t}\n\t\t\t\t\t// something bad happened, we'd better reject on those deferreds\n\t\t\t\t\tu.error('UPDATE error ', err);\n\t\t\t\t\tids_to_update.map(function(id) { uq[id].reject(err);});\n\t\t\t\t});\n\t\t\t},\n\t\t\t_do_update:function(ids) {\n\t\t\t\t// this actua\n\t\t\t\tconsole.log('box update >> ');\n\t\t\t\tvar d = u.deferred(), version = this.get('version') || 0, this_ = this,\n\t\t\t\tobjs = this._objcache().filter(function(x) { return ids === undefined || ids.indexOf(x.id) >= 0; }),\n\t\t\t\tobj_ids = objs.map(function(x) { return x.id; }),\n\t\t\t\tsobjs = objs.map(function(obj){ return serialize_obj(obj); });\n\t\t\t\tthis._ajax(\"PUT\",  this.get_id() + \"/update\", { version: escape(version), data : JSON.stringify(sobjs)  })\n\t\t\t\t\t.then(function(response) {\n\t\t\t\t\t\tthis_._set_version(response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._update_object_list(undefined, obj_ids, []); // update object list\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tupdate:function(original_ids) {\n\t\t\t\t// this is called by Backbone.save(),\n\t\t\t\tvar dfds = this._add_to_update_queue(original_ids);\n\t\t\t\tthis._flush_update_queue();\n\t\t\t\treturn dfds;\n\t\t\t},\n\t\t\t// =============== :: DELETE ::  ======================\n\t\t\t_add_to_delete_queue:function(ids) {\n\t\t\t\tvar this_ = this, dq = this._delete_queue;\n\t\t\t\treturn ids.map(function(id) {\n\t\t\t\t\tdq[id] = dq[id] || u.deferred();\n\t\t\t\t\treturn dq[id];\n\t\t\t\t});\n\t\t\t},\n\t\t\t_delete_models:function(ids) {\n\t\t\t\tvar dfds =  this._add_to_delete_queue(ids);\n\t\t\t\tthis._flush_delete_queue();\n\t\t\t\treturn dfds;\n\t\t\t},\n\t\t\t_requeue_delete:function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (!this._delete_timeout) {\n\t\t\t\t\tthis._delete_timeout = setTimeout(function() {\n\t\t\t\t\t\tdelete this_._delete_timeout;\n\t\t\t\t\t\tthis_._flush_delete_queue();\n\t\t\t\t\t}, 300);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_flush_delete_queue:function() {\n\t\t\t\tvar this_ = this, dq = this._delete_queue, delete_ids = _(dq).keys();\n\t\t\t\tif (delete_ids.length === 0) { return ; }\n\t\t\t\tif (this._deleting || this._updating) { return this._requeue_delete();  }\n\t\t\t\tthis_._deleting = true;\n\t\t\t\tthis_._do_delete(delete_ids).then(function() {\n\t\t\t\t\tdelete this_._deleting;\n\t\t\t\t\tdelete_ids.map(function(id) {\n\t\t\t\t\t\tdq[id].resolve(); delete dq[id];\n\t\t\t\t\t});\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tdelete this_._deleting;\n\t\t\t\t\tif (err.status === 409) { this_._requeue_delete();\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t_do_delete:function(m_ids) {\n\t\t\t\tvar version = this.get('version') || 0, d = u.deferred(), this_ = this;\n\t\t\t\tthis._ajax('DELETE', this.id+'/', { version:version, data: JSON.stringify(m_ids) })\n\t\t\t\t\t.then(function(response) {\n\t\t\t\t\t\tu.debug('DELETE response NEW version > ', response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._set_version(response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._update_object_list(undefined, [], m_ids); // update object list\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// =============== :: SYNC ::  ======================\n\t\t\tsync: function(method, box, options){\n\t\t\t\tswitch(method)\n\t\t\t\t{\n\t\t\t\tcase \"create\": return box._create_box();\n\t\t\t\tcase \"read\": return box._check_token_and_fetch();\n\t\t\t\tcase \"update\": return box.update()[0];  // save whole box?\n\t\t\t\tcase \"delete\": return this.delete_box(this.get_id()) // hook up to destroy\n\t\t\t\t}\n\t\t\t},\n\t\t\ttoString: function() { return 'box:' + this.get_id(); }\n\t\t});\n\n\t\tvar BoxCollection = Backbone.Collection.extend({ model: Box });\n\n\t\tvar Store =  Backbone.Model.extend({\n\t\t\tdefaults: {\n\t\t\t\tserver_host:DEFAULT_HOST,\n\t\t\t\tapp:\"--default-app-id--\"\n\t\t\t},\n\t\t\tajax_defaults : {\n\t\t\t\tjsonp: false, contentType: \"application/json\",\n\t\t\t\txhrFields: { withCredentials: true }\n\t\t\t},\n\n\t\t\t/// @opt <{}> attributes\n\t\t\t/// @opt <{}> options\n\t\t\t/// @constructor\n\t\t\tinitialize: function(attributes, options){\n\t\t\t\tthis.set({boxes : new BoxCollection([], {store: this})});\n\t\t\t},\n\n\t\t\t/// Check that the\n\t\t\tis_same_domain:function() {\n\t\t\t\treturn this.get('server_host').indexOf(document.location.host) >= 0 && (document.location.port === (this.get('server_port') || ''));\n\t\t\t},\n\t\t\tboxes:function() { return this.attributes.boxes;\t},\n\t\t\tget_box: function(boxid) {\n\t\t\t\tvar b = this.boxes().get(boxid) || this._create(boxid);\n\t\t\t\tif (!b._get_cached_token()) {\n\t\t\t\t\treturn b.get_token().pipe(function() {\n\t\t\t\t\t\treturn b.fetch();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn u.dresolve(b);\n\t\t\t},\n\n\n\t\t\t/// @arg <string|number> boxid: the id for the box\n\t\t\t///\n\t\t\t/// @then (<Box> the box)\n\t\t\t/// @fail\n\t\t\t///   (<{ code: 409 }> response) box already exists\n\t\t\t///   (<{ code: -1, error: error obj }> response) other error\n\t\t\t///\n\t\t\t/// Attempts to create a box with the given ID\n\t\t\tcreate_box: function (boxid) {\n\t\t\t\tu.debug('create box ', boxid);\n\t\t\t\tif (this.boxes().get(boxid)) {\n\t\t\t\t\treturn u.dreject({ code: 409, message: 'Box already exists: ' + boxid });\n\t\t\t\t}\n\t\t\t\tvar c = this._create(boxid), this_ = this;\n\t\t\t\tu.debug('creating ', boxid);\n\t\t\t\treturn c.save().pipe(function() { return this_.get_box(boxid); });\n\t\t\t},\n\t\t\tcheck_login:function() {\n\t\t\t\t// checks whether you can connect to the server and who is logged in.\n\t\t\t\t// returns a deferred that gets passed an argument\n\t\t\t\t// { code:200 (server is okay),  is_authenticated:true/false,  user:<username>  }\n\t\t\t\treturn this._ajax('GET', 'auth/whoami');\n\t\t\t},\n\t\t\t// todo: change to _\n\t\t\tget_info:function() { return this._ajax('GET', 'admin/info'); },\n\t\t\tlogin : function(username,password) {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tthis.set({username:username,password:password});\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis._ajax('POST', 'auth/login', { username: username, password: password })\n\t\t\t\t\t.then(function(l) { this_.trigger('login', username); d.resolve(l); })\n\t\t\t\t\t.fail(function(l) { d.reject(l); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\treconnect:function() {\n\t\t\t\treturn this.login(this.get('username'),this.get('password'));\n\t\t\t},\n\t\t\tlogout : function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis._ajax('POST', 'auth/logout')\n\t\t\t\t\t.then(function(l) { this_.trigger('logout'); d.resolve(l); })\n\t\t\t\t\t.fail(function(l) { d.reject(l); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_create:function(boxid) {\n\t\t\t\tvar b = new Box({}, {store: this});\n\t\t\t\tb.cid = boxid;\n\t\t\t\tthis.boxes().add(b);\n\t\t\t\treturn b;\n\t\t\t},\n\t\t\tget_box_list:function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tthis._ajax('GET','admin/list_boxes')\n\t\t\t\t\t.success(function(data) {d.resolve(data.list);})\n\t\t\t\t\t.fail(function(err) { d.reject(err); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\tthrow new Error('dont fetch a store - any more!');\n\t\t\t\t//\n\t\t\t\t// fetches list of boxes\n\t\t\t\t/* - do not do this\n\t\t\t\tvar this_ = this, d = u.deferred();\n\t\t\t\tthis._ajax('GET','admin/list_boxes')\n\t\t\t\t\t.success(function(data) {\n\t\t\t\t\t\tu.when(data.list.map(function(boxid) { return this_.get_box(boxid); })).then(function(boxes) {\n\t\t\t\t\t\t\t// console.log(\"boxes !! \", boxes);\n\t\t\t\t\t\t\tthis_.boxes().reset(boxes);\n\t\t\t\t\t\t\td.resolve(boxes);\n\t\t\t\t\t\t});\n\t\t\t\t\t}).error(function(e) { d.reject(e); });\n\t\t\t\treturn d.promise();\n\t\t\t\t*/\n\t\t\t},\n\t\t\t_ajax:function(method, path, data) {\n\t\t\t\t// now uses relative url scheme '//blah:port/path';\n\t\t\t\tvar url = ['/', this.get('server_host'), path].join('/');\n\t\t\t\tvar default_data = { app: this.get('app') };\n\t\t\t\tvar options = _(_(this.ajax_defaults).clone()).extend(\n\t\t\t\t\t{ url: url, method : method, crossDomain: !this.is_same_domain(), data: _(default_data).extend(data) }\n\t\t\t\t);\n\t\t\t\treturn $.ajax( options ); // returns a deferred\n\t\t\t},\n\t\t\tsync: function(method, model, options){\n\t\t\t\tswitch(method){\n\t\t\t\tcase \"create\": return u.error('store.create() : cannot create a store'); // TODO\n\t\t\t\tcase \"read\"  : return model._fetch();\n\t\t\t\tcase \"update\": return u.error('store.update() : cannot update a store'); // TODO\n\t\t\t\tcase \"delete\": return u.error('store.delete() : cannot delete a store'); // tODO\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tvar exports = {\n\t\t\tsafe_apply:utils.safe_apply,\n\t\t\tu : utils,\n\t\t\tStore:Store,\n\t\t\tObj: Obj,\n\t\t\tFile:File,\n\t\t\tBox: Box,\n\t\t\tstore: new Store(),\n\t\t\tloaded : utils.deferred()\n\t\t};\n\t\twindow.u = utils;\n\n\t\t// do not fetch boxes\n\t\texports.loaded.resolve(exports);\n\t\treturn exports;\n\n\t}).factory('backbone', function(client, utils) {\n\t\t// this manages backbone-angular mystification\n\t\tvar deregfns = [];\n\t\tvar deep_clone_obj = function(o) {\n\t\t\treturn utils.dict(_(o).map(function(v,k) { return [k, v.concat()]; }));\n\t\t};\n\t\tvar scope_bind = function($scope, name, model) {\n\t\t\tutils.assert(model instanceof Backbone.Model, \"tried to bind something that was not a model\");\n\t\t\twindow._m = model;\n\t\t\tvar clone = deep_clone_obj(_(model.attributes));\n\t\t\tutils.safe_apply($scope, function() { $scope[name] = clone;\t});\n\t\t\tvar findchanges = function(old,new_,fn) {\n\t\t\t\tvar changes = [];\n\t\t\t\t_(old).map(function(v,k) {\n\t\t\t\t\tif (v.length !== new_[k].length || _(v).filter(function(vi, i) { return vi != new_[k][i]; }).length) {\n\t\t\t\t\t\tutils.log('pushing changes ', k, new_[k]);\n\t\t\t\t\t\tchanges.push(k);\n\t\t\t\t\t\tif (fn) { fn(k,new_[k].concat()); }\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn changes;\n\t\t\t};\n\t\t\t// angular -> backbone\n\t\t\tvar dereg = $scope.$watch(name, function() {\n\t\t\t\t// do a quick diff --\n\t\t\t\t// first check to make sure that our brave model is still\n\t\t\t\tif ($scope[name] !== clone) { return true; }\n\t\t\t\tfindchanges(model.attributes, clone, function(k,v) {model.set(k,v); });\n\t\t\t}, true);\n\t\t\tderegfns.push([$scope,name,model,dereg]);\n\t\t\t// backbone -> angular\n\t\t\tmodel.on('change', function(data) {\n\t\t\t\tutils.safe_apply($scope, function() {\n\t\t\t\t\tfindchanges(clone, model.attributes, function(k,v) { clone[k] = v;\t});\n\t\t\t\t});\n\t\t\t},$scope);\n\t\t};\n\t\treturn {\n\t\t\tscope_bind: scope_bind,\n\t\t\tscope_unbind:function($scope,name) {\n\t\t\t\tderegfns.map(function(tuple) {\n\t\t\t\t\tvar scope = tuple[0],name = tuple[1],model = tuple[2],dereg = tuple[3];\n\t\t\t\t\tmodel.off('change', null, scope);\n\t\t\t\t\tdereg();\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t});\n","methods":[],"properties":[],"match":"BoxCollection = Backbone.Collection.extend(","name":"BoxCollection","start":30582,"extend":"~1","end":30648}],"data":"///\n/// @title INDX\n/// blah\n\n/*global $,_,document,window,console,escape,Backbone,exports,WebSocket */\n/*jslint vars:true, todo:true */\n/*\n\n  indx.js is the JS Client SDK for WebBox WebBox\n  which builds upon Backbone's Model architecture.\n\n  CURRENT TODOs:\n  \t- update only supports updating the entire box\n    - Box.fetch() retrieves _entire box contents_\n\t  ... which is a really bad idea.\n\n  @prerequisites:\n\tjquery 1.8.0 or higher\n\tbackbone.js 0.9.2 or higher\n\tunderscore.js 1.4.2 or higher\n\n  This file is part of INDX\n  Copyright 2012 Max Van Kleek, Daniel Alexander Smith\n  Copyright 2012 University of Southampton\n\n  WebBox is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  WebBox is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with Indx.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n\nangular\n\t.module('indx', ['ui'])\n\t.factory('client',function(utils) {\n\t\tvar u = utils; // to be filled in by dependency\n\t\t// set up our parameters for webbox -\n\t\t// default is that we're loading from an _app_ hosted within\n\t\t// indx.\n\t\tvar DEFAULT_HOST = document.location.host; // which may contain the port\n\t\tvar WS_MESSAGES_SEND = {\n\t\t\tauth: function(token) { return JSON.stringify({action:'auth', token:token}); },\n\t\t\tdiff: function(token) { return JSON.stringify({action:'diff', operation:\"start\"}); }\n\t\t};\n\t\tvar serialize_obj = function(obj) {\n\t\t\tvar uri = obj.id;\n\t\t\tvar out_obj = {};\n\t\t\t$.each(obj.attributes, function(pred, vals){\n\t\t\t\tif (pred[0] === \"_\" || pred[0] === \"@\"){\n\t\t\t\t\t// don't expand @id etc.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar obj_vals = [];\n\t\t\t\tif (!(vals instanceof Array)){\n\t\t\t\t\tvals = [vals];\n\t\t\t\t}\n\t\t\t\t$.each(vals, function(){\n\t\t\t\t\tvar val = this;\n\t\t\t\t\tif (val instanceof File) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.id, \"@type\":\"indx-file\", \"@language\":val.get('content-type')});\n\t\t\t\t\t} else if (val instanceof Obj) {\n\t\t\t\t\t\tobj_vals.push({\"@id\": val.id });\n\t\t\t\t\t} else if (typeof val === \"object\" && (val[\"@value\"] || val[\"@id\"])) {\n\t\t\t\t\t\tobj_vals.push(val); // fully expanded string, e.g. {\"@value\": \"foo\", \"@language\": \"en\" ... }\n\t\t\t\t\t} else if (typeof val === \"string\" || val instanceof String ){\n\t\t\t\t\t\tobj_vals.push({\"@value\": val});\n\t\t\t\t\t} else if (_.isDate(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toISOString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"});\n\t\t\t\t\t} else if (_.isNumber(val) && u.isInteger(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#integer\"});\n\t\t\t\t\t} else if (_.isNumber(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#float\"});\n\t\t\t\t\t} else if (_.isBoolean(val)) {\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString(), \"@type\":\"http://www.w3.org/2001/XMLSchema#boolean\"});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu.warn(\"Could not determine type of val \", pred, val);\n\t\t\t\t\t\tobj_vals.push({\"@value\": val.toString()});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tout_obj[pred] = obj_vals;\n\t\t\t});\n\t\t\tout_obj['@id'] = uri;\n\t\t\treturn out_obj;\n\t\t};\n\n\t\tvar literal_deserializers = {\n\t\t\t'': function(o) { return o['@value']; },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#integer\": function(o) { return parseInt(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#float\": function(o) { return parseFloat(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#double\": function(o) { return parseFloat(o['@value'], 10); },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#boolean\": function(o) { return o['@value'].toLowerCase() === 'true'; },\n\t\t\t\"http://www.w3.org/2001/XMLSchema#dateTime\": function(o) { return new Date(Date.parse(o['@value'])); },\n\t\t\t\"indx-file\": function(o,box) {\n\t\t\t\tvar f = box.get_or_create_file(o['@value']);\n\t\t\t\tf.set(\"content-type\", o['@language']);\n\t\t\t\treturn f;\n\t\t\t}\n\t\t};\n\t\tvar deserialize_literal = function(obj, box) {\n\t\t\treturn obj['@value'] !== undefined ? literal_deserializers[ obj['@type'] || '' ](obj, box) : obj;\n\t\t};\n\n\t\tvar deserialize_value = function(s_val, box) {\n\t\t\tvar vd = u.deferred();\n\t\t\t// it's an object, so return that\n\t\t\tif (s_val.hasOwnProperty(\"@id\")) {\n\t\t\t\t// object\n\t\t\t\tbox.get_obj(s_val[\"@id\"]).then(vd.resolve).fail(vd.reject);\n\t\t\t}\n\t\t\telse if (s_val.hasOwnProperty(\"@value\")) {\n\t\t\t\t// literal\n\t\t\t\tvd.resolve(deserialize_literal(s_val, box));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// don't know what it is!\n\t\t\t\tvd.reject('cannot unpack value ', s_val);\n\t\t\t}\n\t\t\treturn vd.promise();\n\t\t};\n\n\t\tvar File =  Backbone.Model.extend({\n\t\t\tidAttribute: \"@id\", // the URI attribute is '@id' in JSON-LD\n\t\t\tinitialize:function(attrs, options) {\n\t\t\t\tu.debug('options >> ', attrs, options );\n\t\t\t\tthis.box = options.box;\n\t\t\t},\n\t\t\tget_id:function() { return this.id;\t},\n\t\t\tget_url:function() {\n\t\t\t\tvar params = {\n\t\t\t\t\tid:this.get_id(),\n\t\t\t\t\tapp:this.box.store.get('app'),\n\t\t\t\t\ttoken:this.box.get('token'),\n\t\t\t\t\tbox:this.box.get_id()\n\t\t\t\t}, url = ['/', this.box.store.get('server_host'), this.box.id, 'files'].join('/') + '?' + $.param(params);\n\t\t\t\t// u.debug(\"IMAGE URL IS \", url, params);\n\t\t\t\treturn url;\n\t\t\t}\n\t\t});\n\n\n\t\t// MAP OF THIS MODUULE :::::::::::::: -----\n\t\t//\n\t\t// An Obj is a single instance, thing in Indx.\n\t\t//\n\t\t// A Box is a model that has an attribute called 'Objs'.\n\t\t// ...  which is a Backbone.Collection of Graph objects.\n\t\t//\n\t\t// A _Store_ represents a single Indx server, which has an\n\t\t//\t attribute called 'boxes' -\n\t\t// ... which is a collection of Box objects\n\t\tvar Obj =  Backbone.Model.extend({\n\t\t\tidAttribute: \"@id\", // the URI attribute is '@id' in JSON-LD\n\t\t\tinitialize:function(attrs, options) {\n\t\t\t\tthis.box = options.box;\n\t\t\t},\n\t\t\t_is_fetched: function() { return this._fetched || false; },\n\t\t\t_set_fetched : function() { this._fetched = true; },\n\t\t\tget_id:function() { return this.id;\t},\n\t\t\t_value_to_array:function(k,v) {\n\t\t\t\tif (k === '@id') { return v; }\n\t\t\t\tif (!_(v).isUndefined() && !_(v).isArray()) {\n\t\t\t\t\treturn [v];\n\t\t\t\t}\n\t\t\t\treturn v;\n\t\t\t},\n\t\t\t_all_values_to_arrays:function(o) {\n\t\t\t\tif (!_(o).isObject()) { utils.error(' not an object', o); return o; }\n\t\t\t\tvar this_ = this;\n\t\t\t\t// ?!?! this isn't doing anything (!!)\n\t\t\t\treturn u.dict(_(o).map(function(v,k) {\n\t\t\t\t\tvar val = this_._value_to_array(k,v);\n\t\t\t\t\tif (u.defined(val)) { return [k,val]; }\n\t\t\t\t\treturn undefined;\n\t\t\t\t}).filter(u.defined));\n\t\t\t},\n\t\t\tset:function(k,v,options) {\n\t\t\t\t// set is tricky because it can be called like\n\t\t\t\t// set('foo',123) or set({foo:123})\n\t\t\t\tif (typeof k === 'string') { v = this._value_to_array(k,v);\t}\n\t\t\t\telse {\tk = this._all_values_to_arrays(k);\t}\n\t\t\t\treturn Backbone.Model.prototype.set.apply(this,[k,v,options]);\n\t\t\t},\n\t\t\tdelete_properties:function(props, silent)  {\n\t\t\t\tvar this_ = this;\n\t\t\t\tprops.map(function(p) { this_.unset(p, silent ? {silent:true} : {}); });\n\t\t\t},\n\t\t\t_deserialise_and_set:function(s_obj, silent) {\n\t\t\t\t// returns a promise\n\t\t\t\tvar this_ = this;\n\t\t\t\tvar dfds = _(s_obj).map(function(vals, key) {\n\t\t\t\t\tvar kd = u.deferred();\n\t\t\t\t\tif (key.indexOf('@') === 0) { return; }\n\t\t\t\t\tvar val_dfds = vals.map(function(val) {\n\t\t\t\t\t\tvar vd = u.deferred();\n\t\t\t\t\t\t// it's an object, so return that\n\t\t\t\t\t\tif (val.hasOwnProperty(\"@id\")) {\n\t\t\t\t\t\t\t// object\n\t\t\t\t\t\t\tthis_.box.get_obj(val[\"@id\"]).then(vd.resolve).fail(vd.reject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (val.hasOwnProperty(\"@value\")) {\n\t\t\t\t\t\t\t// literal\n\t\t\t\t\t\t\tvd.resolve(deserialize_literal(val, this_.box));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// don't know what it is!\n\t\t\t\t\t\t\tvd.reject('cannot unpack value ', val);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn vd.promise();\n\t\t\t\t\t});\n\t\t\t\t\tu.when(val_dfds).then(function(obj_vals) {\n\t\t\t\t\t\t// only update keys that have changed\n\t\t\t\t\t\tvar prev_vals = this_.get(key);\n\t\t\t\t\t\tif ( prev_vals === undefined || obj_vals.length !== prev_vals.length ||\n\t\t\t\t\t\t\t _(obj_vals).difference(prev_vals).length > 0 ||\n\t\t\t\t\t\t\t _(prev_vals).difference(obj_vals).length > 0) {\n\t\t\t\t\t\t\tthis_.set(key, obj_vals, { silent : silent });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkd.resolve();\n\t\t\t\t\t}).fail(kd.reject);\n\t\t\t\t\treturn kd.promise();\n\t\t\t\t}).filter(u.defined);\n\t\t\t\treturn u.when(dfds);\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\tvar this_ = this, fd = u.deferred(), box = this.box.get_id();\n\t\t\t\tthis.box._ajax('GET', box, {'id':this.id}).then(function(response) {\n\t\t\t\t\tthis_._set_fetched(true);\n\t\t\t\t\tvar objdata = response.data;\n\t\t\t\t\tif (objdata['@version'] === undefined) {\n\t\t\t\t\t\t// then the server thinks we've been deleted, so let's just die.\n\t\t\t\t\t\treturn fd.reject(this_.id);\n\t\t\t\t\t\t// old code:\n\t\t\t\t\t\t// according to the server, we're dead.\n\t\t\t\t\t\t// console.log('zombie detected ', this_.id);\n\t\t\t\t\t\t// this_.cid = this_.id;\n\t\t\t\t\t\t// this_.unset({});\n\t\t\t\t\t\t// delete this_.id;\n\t\t\t\t\t\t// fd.resolve();\n\t\t\t\t\t\t// return;\n\t\t\t\t\t}\n\t\t\t\t\t// we are at current known version as far as we know\n\t\t\t\t\tvar obj_save_dfds = _(objdata).map(function(obj,uri) {\n\t\t\t\t\t\t// top level keys - corresponding to box level properties\n\t\t\t\t\t\tif (uri[0] === \"@\") { return; } // ignore \"@id\", \"@version\" etc\n\t\t\t\t\t\t// not one of those, so must be a\n\t\t\t\t\t\t// < uri > : { prop1 .. prop2 ... }\n\t\t\t\t\t\tu.assert(uri === this_.id, 'can only deserialise this object ');\n\t\t\t\t\t\treturn this_._deserialise_and_set(obj);\n\t\t\t\t\t});\n\t\t\t\t\tu.when(obj_save_dfds).then(function(){ fd.resolve(this_); }).fail(fd.reject);\n\t\t\t\t});\n\t\t\t\treturn fd.promise();\n\t\t\t},\n\t\t\tsync: function(method, model, options){\n\t\t\t\tswitch(method){\n\t\t\t\tcase \"create\": return u.assert(false, \"create is never used for Objs\");\n\t\t\t\tcase \"read\"  : return model._fetch();\n\t\t\t\tcase \"update\":\n\t\t\t\t\treturn  model.box.update([model.id])[0];\n\t\t\t\tcase \"delete\":\n\t\t\t\t\treturn this.box._delete_models([this.id])[0];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\n\t\t// Box =================================================\n\t\t// GraphCollection is the list of Objs in a Graph\n\t\tvar ObjCollection = Backbone.Collection.extend({ model: Obj }),\n\t\t\tFileCollection = Backbone.Collection.extend({ model: File });\n\n\t\t// new client: fetch is always lazy, only gets ids, and\n\t\t// lazily get objects as you go\n\t\tvar Box = Backbone.Model.extend({\n\t\t\tidAttribute:\"@id\",\n\t\t\tdefault_options: { use_websockets:true, ws_auto_reconnect:false\t},\n\t\t\tinitialize:function(attributes, options) {\n\t\t\t\tvar this_ = this;\n\t\t\t\tu.assert(options.store, \"no store provided\");\n\t\t\t\tthis.store = options.store;\n\t\t\t\tthis.set({objcache: new ObjCollection(), objlist: [], files : new FileCollection() });\n\t\t\t\tthis.options = _(this.default_options).chain().clone().extend(options || {}).value();\n\t\t\t\tthis.set_up_websocket();\n\t\t\t\tthis._update_queue = {};\n\t\t\t\tthis._delete_queue = {};\n\t\t\t\tthis._fetching_queue = {};\n\t\t\t\tthis.on('update-from-master', function() {\n\t\t\t\t\t// u.log(\"UPDATE FROM MASTER >> flushing \");\n\t\t\t\t\tthis_._flush_update_queue();\n\t\t\t\t\tthis_._flush_delete_queue();\n\t\t\t\t});\n\t\t\t},\n\t\t\t/// <string> fid file id\n\t\t\t/// Tries to get a file with given id. If it doesn't exist, a file with that name is created.\n\t\t\t/// @return <File> the file\n\t\t\tget_or_create_file:function(fid) {\n\t\t\t\tvar files = this.get('files');\n\t\t\t\tif (files.get(fid) === undefined) {\n\t\t\t\t\tfiles.add(new File({\"@id\": fid}, { box: this }));\n\t\t\t\t}\n\t\t\t\treturn files.get(fid);\n\t\t\t},\n\t\t\tset_up_websocket:function() {\n\t\t\t\tvar this_ = this, server_host = this.store.get('server_host');\n\t\t\t\tif (! this.get_use_websockets() ) { return; }\n\t\t\t\tthis.on('new-token', function(token) {\n\t\t\t\t\tvar ws = this_._ws;\n\t\t\t\t\tif (ws) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tws.close();\n\t\t\t\t\t\t\tdelete this_._ws;\n\t\t\t\t\t\t} catch(e) { u.error(); }\n\t\t\t\t\t}\n\t\t\t\t\tvar protocol = (document.location.protocol === 'https:') ? 'wss:/' : 'ws:/';\n\t\t\t\t\tvar ws_url = [protocol,server_host,'ws'].join('/');\n\t\t\t\t\tws = new WebSocket(ws_url);\n\t\t\t\t\tws.onmessage = function(evt) {\n\t\t\t\t\t\tu.debug('websocket :: incoming a message ', evt.data.toString().substring(0,190));\n\t\t\t\t\t\tvar pdata = JSON.parse(evt.data);\n\t\t\t\t\t\tif (pdata.action === 'diff') {\n\t\t\t\t\t\t\tthis_._diff_update(pdata.data)\n\t\t\t\t\t\t\t\t.then(function() {\n\t\t\t\t\t\t\t\t\tthis_.trigger('update-from-master', this_._get_version());\n\t\t\t\t\t\t\t\t}).fail(function(err) {\n\t\t\t\t\t\t\t\t\tu.error(err); /*  u.log('done diffing '); */\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tws.onopen = function() {\n\t\t\t\t\t\tvar data = WS_MESSAGES_SEND.auth(this_.get('token'));\n\t\t\t\t\t\tws.send(data);\n\t\t\t\t\t\tdata = WS_MESSAGES_SEND.diff();\n\t\t\t\t\t\tws.send(data);\n\t\t\t\t\t\tthis_._ws = ws;\n\t\t\t\t\t\tthis_.trigger('ws-connect');\n\t\t\t\t\t};\n\t\t\t\t\tws.onclose = function(evt) {\n\t\t\t\t\t\t// what do we do now?!\n\t\t\t\t\t\tu.error('websocket closed -- ');\n\t\t\t\t\t\t// TODO\n\t\t\t\t\t\tvar interval;\n\t\t\t\t\t\tinterval = setInterval(function() {\n\t\t\t\t\t\t\tthis_.store.reconnect().then(function() {\n\t\t\t\t\t\t\t\tthis_.get_token().then(function() {\n\t\t\t\t\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},1000);\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t},\n\t\t\tget_use_websockets:function() { return this.options.use_websockets; },\n\t\t\tget_cache_size:function(i) { return this._objcache().length; },\n\t\t\tget_obj_ids:function() { return this._objlist().slice(); },\n\t\t\t_objcache:function() { return this.attributes.objcache; },\n\t\t\t_objlist:function() { return this.attributes.objlist !== undefined ? this.attributes.objlist : []; },\n\t\t\t_set_objlist:function(ol) { return this.set({objlist:ol.slice()}); },\n\t\t\t_get_cached_token:function() { return this.get(\"token\"); },\n\t\t\t_set_token:function(token) { this.set(\"token\", token);\t},\n\t\t\t_set_version:function(v) { this.set(\"version\", v);\t},\n\t\t\t_get_version:function(v) { return this.get(\"version\"); },\n\t\t\tget_token:function() {\n\t\t\t\t// utils.debug('>> get_token ', ' id: ',this.id, ' cid: ',this.cid);\n\t\t\t\t// try { throw new Error(''); } catch(e) { console.error(e); }\n\t\t\t\tvar this_ = this, d = u.deferred();\n\t\t\t\tthis._ajax('POST', 'auth/get_token', { app: this.store.get('app') })\n\t\t\t\t\t.then(function(data) {\n\t\t\t\t\t\tconsole.log('setting token ', data.token);\n\t\t\t\t\t\tthis_._set_token( data.token );\n\t\t\t\t\t\tthis_.trigger('new-token', data.token);\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tget_id:function() { return this.id || this.cid;\t},\n\t\t\t_ajax:function(method, path, data) {\n\t\t\t\tdata = _(_(data||{}).clone()).extend({box: this.id || this.cid, token:this.get('token')});\n\t\t\t\treturn this.store._ajax(method, path, data);\n\t\t\t},\n\t\t\tput_file:function(id,filedata,contenttype) {\n\t\t\t\t// creates a File object and hands it back in the resolve\n\t\t\t\tcontenttype = contenttype || filedata.type;\n\t\t\t\tvar d = u.deferred(), this_ = this, newFile = this.get_or_create_file(id);\n\t\t\t\tnewFile.set({\"content-type\": contenttype});\n\t\t\t\tthis._do_put_file(id,filedata,contenttype).then(function(){\n\t\t\t\t\tu.debug('image put success ');\n\t\t\t\t\td.resolve(newFile);\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tif (err.status === 409) {\n\t\t\t\t\t\tvar cb = function() {\n\t\t\t\t\t\t\tthis_.off('update-from-master', cb, newFile);\n\t\t\t\t\t\t\tthis_._put_file(id, filedata, contenttype).then(d.resolve).fail(d.reject);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis_.on('update-from-master', cb, newFile);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu.error('error putting, dammit ', err);\n\t\t\t\t\t\td.reject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_do_put_file:function(id,file,contenttype) {\n\t\t\t\t// now uses relative url scheme '//blah:port/path';\n\t\t\t\t// all files must be PUT into boxname/files\n\t\t\t\t// here the parameters are get encoded\n\t\t\t\t// // 'http://' + this.store.get('server_host') + \"/\" +  boxid + \"/\" + 'files',\n\t\t\t\tvar boxid = this.id || this.cid,\n\t\t\t\tbase_url = ['/', this.store.get('server_host'), boxid, 'files'].join('/'),\n\t\t\t\toptions = { app: this.store.get('app'), id: id, token:this.get('token'),  box: boxid, version: this._get_version() },\n\t\t\t\toption_params = $.param(options),\n\t\t\t\turl = base_url+\"?\"+option_params,\n\t\t\t\td = u.deferred();\n\t\t\t\tconsole.log(\"PUTTING FILE \", url);\n\t\t\t\tvar ajax_args  = _(_(this.store.ajax_defaults).clone()).extend(\n\t\t\t\t\t{ url: url, method : 'PUT', crossDomain:false, data:file, contentType: contenttype, processData:false }\n\t\t\t\t);\n\t\t\t\treturn $.ajax( ajax_args );\n\t\t\t},\n\t\t\tquery: function(q){\n\t\t\t\t// @TODO ::::::::::::::::::::::::::\n\t\t\t\tu.NotImplementedYet();\n\t\t\t\t// var d = u.deferred();\n\t\t\t\t// this._ajax(this, \"/query\", \"GET\", {\"q\": JSON.stringify(q)})\n\t\t\t\t// \t.then(function(data){\n\t\t\t\t// \t\tconsole.debug(\"query results:\",data);\n\t\t\t\t// \t}).fail(function(data) {\n\t\t\t\t// \t\tconsole.debug(\"fail query\");\n\t\t\t\t// \t});\n\t\t\t\t// return d.promise();\n\t\t\t},\n\t\t\t_diff_update:function(response) {\n\t\t\t\tvar d = u.deferred(), this_ = this, latest_version = response['@to_version'],\n\t\t\t\tadded_ids  = _(response.data.added).keys(),\n\t\t\t\tchanged_ids = _(response.data.changed).keys(),\n\t\t\t\tdeleted_ids = _(response.data.deleted).keys(),\n\t\t\t\tchanged_objs = response.data.changed;\n\n\t\t\t\tu.assert(latest_version !== undefined, 'latest version not provided');\n\t\t\t\tu.assert(added_ids !== undefined, 'added_ids not provided');\n\t\t\t\tu.assert(changed_ids !== undefined, 'changed not provided');\n\t\t\t\tu.assert(deleted_ids !== undefined, 'deleted _ids not provided');\n\n\t\t\t\tif (latest_version <= this_._get_version()) {\n\t\t\t\t\tu.debug('asked to diff update, but already up to date, so just relax!', latest_version, this_._get_version());\n\t\t\t\t\treturn d.resolve();\n\t\t\t\t}\n\t\t\t\tu.debug('setting latest version >> ', latest_version, added_ids, changed_ids, deleted_ids);\n\t\t\t\tthis_._set_version(latest_version);\n\t\t\t\tthis_._update_object_list(undefined, added_ids, deleted_ids);\n\t\t\t\tvar change_dfds = _(changed_objs).map(function(obj, uri) {\n\t\t\t\t\tu.debug(' checking to see if in --- ', uri, this_._objcache().get(uri));\n\t\t\t\t\tu.debug('obj >> ', obj);\n\t\t\t\t\tvar cached_obj = this_._objcache().get(uri), cdfd = u.deferred();\n\t\t\t\t\tif (cached_obj) {\n\t\t\t\t\t\t// { prop : [ {sval1 - @type:\"\"}, {sval2 - @type} ... ]\n\t\t\t\t\t\tvar changed_properties = [];\n\t\t\t\t\t\t// console.log(\"obj deleted \", obj.deleted);\n\t\t\t\t\t\tvar deleted_propval_dfds = _(obj.deleted).map(function(vs, k) {\n\t\t\t\t\t\t\tchanged_properties = _(changed_properties).union([k]);\n\t\t\t\t\t\t\tvar dd = u.deferred();\n\t\t\t\t\t\t\tu.when(vs.map(function(v) {\treturn deserialize_value(v, this_);\t})).then(function(values) {\n\t\t\t\t\t\t\t\tvar new_vals = _(cached_obj.get(k) || []).difference(values);\n\t\t\t\t\t\t\t\t// console.log(\"DESERIALISED deleted values \", values, \" - \", \" new_vals \", new_vals);\n\t\t\t\t\t\t\t\t// window._values = values; window._newvals = new_vals;\n\t\t\t\t\t\t\t\tcached_obj.set(k,new_vals);\n\t\t\t\t\t\t\t\t// semantics - if a property has no value then we delete it\n\t\t\t\t\t\t\t\tif (new_vals.length === 0) { cached_obj.unset(k); }\n\t\t\t\t\t\t\t\tdd.resolve();\n\t\t\t\t\t\t\t}).fail(dd.reject);\n\t\t\t\t\t\t\treturn dd.promise();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tvar added_propval_dfds = _(obj.added).map(function(vs, k) {\n\t\t\t\t\t\t\tchanged_properties = _(changed_properties).union([k]);\n\t\t\t\t\t\t\tvar dd = u.deferred();\n\t\t\t\t\t\t\tu.when(vs.map(function(v) {\treturn deserialize_value(v, this_);\t})).then(function(values) {\n\t\t\t\t\t\t\t\tvar new_vals = (cached_obj.get(k) || []).concat(values);\n\t\t\t\t\t\t\t\tcached_obj.set(k,new_vals);\n\t\t\t\t\t\t\t\tdd.resolve();\n\t\t\t\t\t\t\t}).fail(dd.reject);\n\t\t\t\t\t\t\treturn dd.promise();\n\t\t\t\t\t\t});\n                        var replaced_propval_dfs = _(obj.replaced).map(function(vs, k) {\n                            console.debug(\"Processing replaced property\");\n                            changed_properties = _(changed_properties).union([k]);\n                            var dd = u.deferred();\n                            u.when(vs.map(function(v) { return deserialize_value(v, this_); })).then(function(values) {\n                                var new_vals = values; // this is the difference from added - just replace (by DS)\n                                cached_obj.set(k,new_vals);\n                                dd.resolve();\n                            }).fail(dd.reject);\n                            return dd.promise();\n                        });\n                        u.when(added_propval_dfds.concat(deleted_propval_dfds).concat(replaced_propval_dfs)).then(function() {\n\t\t\t\t\t\t\t// u.debug(\"triggering changed properties \", changed_properties);\n\t\t\t\t\t\t\tchanged_properties.map(function(k) {\n\t\t\t\t\t\t\t\tcached_obj.trigger('change:'+k, (cached_obj.get(k) || []).slice());\n\t\t\t\t\t\t\t\tu.debug(\"trigger! change:\"+k);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcdfd.resolve(cached_obj);\n\t\t\t\t\t\t}).fail(cdfd.reject);\n\t\t\t\t\t\treturn cdfd.promise();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tu.when(change_dfds).then(d.resolve).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_create_model_for_id: function(obj_id){\n\t\t\t\tvar model = new Obj({\"@id\":obj_id}, {box:this});\n\t\t\t\tthis._objcache().add(model);\n\t\t\t\treturn model;\n\t\t\t},\n\t\t\tget_obj:function(objid) {\n\t\t\t\t// get_obj always returns a promise\n\t\t\t\tu.assert(typeof objid === 'string' || typeof objid === 'number', \"objid has to be a number or string\");\n\t\t\t\tvar d = u.deferred(),\n\t\t\t\tcachemodel = this._objcache().get(objid),\n\t\t\t\tfetching_dfd = this._fetching_queue[objid],\n\t\t\t\thasmodel = cachemodel && fetching_dfd === undefined,\n\t\t\t\tthis_ = this;\n\n\t\t\t\tif (hasmodel) {\n\t\t\t\t\tconsole.log('returning cached ', objid);\n\t\t\t\t\td.resolve(cachemodel); return d.promise();\n\t\t\t\t}\n\n\t\t\t\t// check to see if already fetching, then we can tag along\n\t\t\t\tif (fetching_dfd) {\n\t\t\t\t\t// to fix a deadlock condition -\n\t\t\t\t\t// if we fetch someone who loops back to us\n\t\t\t\t\t// then we will never resolve with this code:\n\t\t\t\t\t//\n\t\t\t\t\t// fetching_dfd.then(d.resolve).fail(d.reject);\n\t\t\t\t\t// return d.promise();\n\t\t\t\t\t// --\n\t\t\t\t\t// therefore a fix:\n\t\t\t\t\td.resolve(cachemodel);\n\t\t\t\t\treturn d.promise();\n\t\t\t\t}\n\n\t\t\t\t// if not already fetching then we have to fetch\n\t\t\t\tthis._fetching_queue[objid] = d;\n\t\t\t\tvar model = this_._create_model_for_id(objid);\n\t\t\t\t// if the serve knows about it, then we fetch its definition\n\t\t\t\tconsole.log('objlist ', this._objlist());\n\n\t\t\t\t// old code ::\n\t\t\t\t// if (this._objlist().indexOf(objid) >= 0) {\n\t\t\t\t// \tconsole.log('object exists, going to fetch it ');\n\t\t\t\t// \tmodel.fetch().then(function() {\n\t\t\t\t// \t\td.resolve(model);\n\t\t\t\t// \t\tdelete this_._fetching_queue[objid];\n\t\t\t\t// \t}).fail(d.reject);\n\t\t\t\t// } else {\n\t\t\t\t// \tconsole.log('object doesnt exist, not going to fetch it ');\n\t\t\t\t// \t// otherwise it must be new!\n\t\t\t\t// \tmodel.is_new = true;\n\t\t\t\t// \td.resolve(model);\n\t\t\t\t// }\n\n\t\t\t\tconsole.log('trying to fetch ', objid);\n\t\t\t\tmodel.fetch().then(function() {\n\t\t\t\t\td.resolve(model);\n\t\t\t\t\tdelete this_._fetching_queue[objid];\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tconsole.log('failed.. declaring it new ', objid);\n\t\t\t\t\t// TODO check if 404'd\n\t\t\t\t\tconsole.log('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA err - didnt exist ? ', err);\n\t\t\t\t\tmodel.is_new = true;\n\t\t\t\t\td.resolve(model);\n\t\t\t\t\tdelete this_._fetching_queue[objid];\n\t\t\t\t});\n\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// ----------------------------------------------------\n\t\t\t_update_object_list:function(updated_obj_ids, added, deleted) {\n\t\t\t\tvar current, olds = this._objlist().slice(), this_ = this, news, died;\n\t\t\t\t// u.debug('_update_object_list +', added ? added.length : ' ', '-', deleted ? deleted.length : ' ');\n\t\t\t\t// u.debug('_update_object_list +', added || ' ', deleted || ' ');\n\t\t\t\tif (updated_obj_ids === undefined ) {\n\t\t\t\t\tcurrent = _(olds).chain().union(added).difference(deleted).value();\n\t\t\t\t\tnews = (added || []).slice(); died = (deleted || []).slice();\n\t\t\t\t} else {\n\t\t\t\t\tcurrent = updated_obj_ids.slice();\n\t\t\t\t\tnews = _(current).difference(olds);\n\t\t\t\t\tdied = _(olds).difference(current);\n\t\t\t\t}\n\t\t\t\t// u.debug('old objlist had ', olds.length, ' new has ', current.length, 'news > ', news);\n\t\t\t\tthis._set_objlist(current);\n\t\t\t\tnews.map(function(aid) {\tthis_.trigger('obj-add', aid);\t});\n\t\t\t\tdied.map(function(rid) {\n\t\t\t\t\tthis_.trigger('obj-remove', rid);\n\t\t\t\t\tthis_._objcache().remove(rid);\n\t\t\t\t});\n\t\t\t},\n\t\t\t_is_fetched: function() {\n\t\t\t\treturn this.id !== undefined;\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\t// all fetch really does is retrieve ids!\n\t\t\t\t// new client :: this now _only_ fetches object ids\n\t\t\t\t// return a list of models (each of type Object) to populate a GraphCollection\n\t\t\t\tvar d = u.deferred(), fd = u.deferred(), this_ = this;\n\t\t\t\tif (this._is_fetched()) {\n\t\t\t\t\t// Nope - don't do anything -- we just wait for websockets to update us.\n\t\t\t\t\tfd.resolve();\n\t\t\t\t} else {\n\t\t\t\t\t// otherwise we aren't fetched, so we just do it\n\t\t\t\t\tvar box = this.get_id();\n\t\t\t\t\tthis._ajax(\"GET\",[box,'get_object_ids'].join('/')).then(\n\t\t\t\t\t\tfunction(response){\n\t\t\t\t\t\t\tu.assert(response['@version'] !== undefined, 'no version provided');\n\t\t\t\t\t\t\tthis_.id = this_.get_id(); // sets so that _is_fetched later returns true\n\t\t\t\t\t\t\tthis_._set_version(response['@version']);\n\t\t\t\t\t\t\tthis_._update_object_list(response.ids);\n\t\t\t\t\t\t\tfd.resolve(this_);\n\t\t\t\t\t\t}).fail(fd.reject);\n\t\t\t\t}\n\t\t\t\tfd.then(function() {\n\t\t\t\t\tthis_.trigger('update-from-master', this_._get_version());\n\t\t\t\t\td.resolve(this_);\n\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// -----------------------------------------------\n\t\t\t_check_token_and_fetch : function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (this.get('token') === undefined) {\n\t\t\t\t\tvar d = u.deferred();\n\t\t\t\t\tthis.get_token()\n\t\t\t\t\t\t.then(function() { this_._fetch().then(d.resolve).fail(d.reject);\t})\n\t\t\t\t\t\t.fail(d.reject);\n\t\t\t\t\treturn d.promise();\n\t\t\t\t}\n\t\t\t\treturn this_._fetch();\n\t\t\t},\n\t\t\t_create_box:function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis.store._ajax('POST', 'admin/create_box', { name: this.get_id() } )\n\t\t\t\t\t.then(function() {\n\t\t\t\t\t\tthis_.fetch().then(function() { d.resolve(); }).fail(function(err) { d.reject(err); });\n\t\t\t\t\t}).fail(function(err) { d.reject(err); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tdelete_box:function(boxid) {\n\t\t\t\treturn this.store._ajax('POST','admin/delete_box', { name: boxid } );\n\t\t\t},\n\t\t\t// =============== :: UPDATE ::  ======================\n\t\t\tWHOLE_BOX: \"__UPDATE__WHOLE__BOX__\",\n\t\t\t_add_to_update_queue:function(ids_to_update) {\n\t\t\t\tvar this_ = this, uq = this._update_queue;\n\t\t\t\t// returns the deferreds\n\t\t\t\tids_to_update = ids_to_update === undefined ? [ this.WHOLE_BOX ] : ids_to_update;\n\t\t\t\treturn ids_to_update.map(function(id) {\n\t\t\t\t\tuq[id] = uq[id] || u.deferred();\n\t\t\t\t\treturn uq[id];\n\t\t\t\t});\n\t\t\t},\n\t\t\t_requeue_update:function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (!this._update_timeout) {\n\t\t\t\t\tthis._update_timeout = setTimeout(function() {\n\t\t\t\t\t\tdelete this_._update_timeout;\n\t\t\t\t\t\tthis_._flush_update_queue();\n\t\t\t\t\t}, 300);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_flush_update_queue:function() {\n\t\t\t\tvar this_ = this, uq = this._update_queue, ids_to_update = _(uq).keys();\n\t\t\t\tif (ids_to_update.length === 0) { return ; }\n\t\t\t\tif (this._updating || this._deleting) {\n\t\t\t\t\treturn this._requeue_update();\n\t\t\t\t}\n\n\t\t\t\tthis._update_queue = {};\n\t\t\t\tvar update_arguments = ids_to_update.indexOf(this.WHOLE_BOX) >= 0 ? undefined : ids_to_update;\n\t\t\t\tthis_._updating = true;\n\n\t\t\t\tthis_._do_update(update_arguments).then(function() {\n\t\t\t\t\tdelete this_._updating;\n\t\t\t\t\t// TODO: resolve all of our deferreds now and delete them\n\t\t\t\t\tids_to_update.map(function(id) { uq[id].resolve();\t\t});\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tdelete this_._updating;\n\t\t\t\t\tif (err.status === 409) {\n\t\t\t\t\t\t// add the defferds back in\n\t\t\t\t\t\t_(uq).map(function(d,id) {\n\t\t\t\t\t\t\tif (this_._update_queue[id]) {\n\t\t\t\t\t\t\t\t// someone's already added one back in! let's chain them\n\t\t\t\t\t\t\t\tu.debug('HEYYYYYYYYYYYYYYYYYYYYYY already added in - lets go');\n\t\t\t\t\t\t\t\tthis_._update_queue[id].then(uq[id].resolve).fail(uq[id].reject);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tu.debug('sneaking him back in - lets go');\n\t\t\t\t\t\t\t\tthis_._update_queue[id] = uq[id];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn this_._requeue_update();\n\t\t\t\t\t}\n\t\t\t\t\t// something bad happened, we'd better reject on those deferreds\n\t\t\t\t\tu.error('UPDATE error ', err);\n\t\t\t\t\tids_to_update.map(function(id) { uq[id].reject(err);});\n\t\t\t\t});\n\t\t\t},\n\t\t\t_do_update:function(ids) {\n\t\t\t\t// this actua\n\t\t\t\tconsole.log('box update >> ');\n\t\t\t\tvar d = u.deferred(), version = this.get('version') || 0, this_ = this,\n\t\t\t\tobjs = this._objcache().filter(function(x) { return ids === undefined || ids.indexOf(x.id) >= 0; }),\n\t\t\t\tobj_ids = objs.map(function(x) { return x.id; }),\n\t\t\t\tsobjs = objs.map(function(obj){ return serialize_obj(obj); });\n\t\t\t\tthis._ajax(\"PUT\",  this.get_id() + \"/update\", { version: escape(version), data : JSON.stringify(sobjs)  })\n\t\t\t\t\t.then(function(response) {\n\t\t\t\t\t\tthis_._set_version(response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._update_object_list(undefined, obj_ids, []); // update object list\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\tupdate:function(original_ids) {\n\t\t\t\t// this is called by Backbone.save(),\n\t\t\t\tvar dfds = this._add_to_update_queue(original_ids);\n\t\t\t\tthis._flush_update_queue();\n\t\t\t\treturn dfds;\n\t\t\t},\n\t\t\t// =============== :: DELETE ::  ======================\n\t\t\t_add_to_delete_queue:function(ids) {\n\t\t\t\tvar this_ = this, dq = this._delete_queue;\n\t\t\t\treturn ids.map(function(id) {\n\t\t\t\t\tdq[id] = dq[id] || u.deferred();\n\t\t\t\t\treturn dq[id];\n\t\t\t\t});\n\t\t\t},\n\t\t\t_delete_models:function(ids) {\n\t\t\t\tvar dfds =  this._add_to_delete_queue(ids);\n\t\t\t\tthis._flush_delete_queue();\n\t\t\t\treturn dfds;\n\t\t\t},\n\t\t\t_requeue_delete:function() {\n\t\t\t\tvar this_ = this;\n\t\t\t\tif (!this._delete_timeout) {\n\t\t\t\t\tthis._delete_timeout = setTimeout(function() {\n\t\t\t\t\t\tdelete this_._delete_timeout;\n\t\t\t\t\t\tthis_._flush_delete_queue();\n\t\t\t\t\t}, 300);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_flush_delete_queue:function() {\n\t\t\t\tvar this_ = this, dq = this._delete_queue, delete_ids = _(dq).keys();\n\t\t\t\tif (delete_ids.length === 0) { return ; }\n\t\t\t\tif (this._deleting || this._updating) { return this._requeue_delete();  }\n\t\t\t\tthis_._deleting = true;\n\t\t\t\tthis_._do_delete(delete_ids).then(function() {\n\t\t\t\t\tdelete this_._deleting;\n\t\t\t\t\tdelete_ids.map(function(id) {\n\t\t\t\t\t\tdq[id].resolve(); delete dq[id];\n\t\t\t\t\t});\n\t\t\t\t}).fail(function(err) {\n\t\t\t\t\tdelete this_._deleting;\n\t\t\t\t\tif (err.status === 409) { this_._requeue_delete();\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t_do_delete:function(m_ids) {\n\t\t\t\tvar version = this.get('version') || 0, d = u.deferred(), this_ = this;\n\t\t\t\tthis._ajax('DELETE', this.id+'/', { version:version, data: JSON.stringify(m_ids) })\n\t\t\t\t\t.then(function(response) {\n\t\t\t\t\t\tu.debug('DELETE response NEW version > ', response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._set_version(response.data[\"@version\"]);\n\t\t\t\t\t\tthis_._update_object_list(undefined, [], m_ids); // update object list\n\t\t\t\t\t\td.resolve(this_);\n\t\t\t\t\t}).fail(d.reject);\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t// =============== :: SYNC ::  ======================\n\t\t\tsync: function(method, box, options){\n\t\t\t\tswitch(method)\n\t\t\t\t{\n\t\t\t\tcase \"create\": return box._create_box();\n\t\t\t\tcase \"read\": return box._check_token_and_fetch();\n\t\t\t\tcase \"update\": return box.update()[0];  // save whole box?\n\t\t\t\tcase \"delete\": return this.delete_box(this.get_id()) // hook up to destroy\n\t\t\t\t}\n\t\t\t},\n\t\t\ttoString: function() { return 'box:' + this.get_id(); }\n\t\t});\n\n\t\tvar BoxCollection = Backbone.Collection.extend({ model: Box });\n\n\t\tvar Store =  Backbone.Model.extend({\n\t\t\tdefaults: {\n\t\t\t\tserver_host:DEFAULT_HOST,\n\t\t\t\tapp:\"--default-app-id--\"\n\t\t\t},\n\t\t\tajax_defaults : {\n\t\t\t\tjsonp: false, contentType: \"application/json\",\n\t\t\t\txhrFields: { withCredentials: true }\n\t\t\t},\n\n\t\t\t/// @opt <{}> attributes\n\t\t\t/// @opt <{}> options\n\t\t\t/// @constructor\n\t\t\tinitialize: function(attributes, options){\n\t\t\t\tthis.set({boxes : new BoxCollection([], {store: this})});\n\t\t\t},\n\n\t\t\t/// Check that the\n\t\t\tis_same_domain:function() {\n\t\t\t\treturn this.get('server_host').indexOf(document.location.host) >= 0 && (document.location.port === (this.get('server_port') || ''));\n\t\t\t},\n\t\t\tboxes:function() { return this.attributes.boxes;\t},\n\t\t\tget_box: function(boxid) {\n\t\t\t\tvar b = this.boxes().get(boxid) || this._create(boxid);\n\t\t\t\tif (!b._get_cached_token()) {\n\t\t\t\t\treturn b.get_token().pipe(function() {\n\t\t\t\t\t\treturn b.fetch();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn u.dresolve(b);\n\t\t\t},\n\n\n\t\t\t/// @arg <string|number> boxid: the id for the box\n\t\t\t///\n\t\t\t/// @then (<Box> the box)\n\t\t\t/// @fail\n\t\t\t///   (<{ code: 409 }> response) box already exists\n\t\t\t///   (<{ code: -1, error: error obj }> response) other error\n\t\t\t///\n\t\t\t/// Attempts to create a box with the given ID\n\t\t\tcreate_box: function (boxid) {\n\t\t\t\tu.debug('create box ', boxid);\n\t\t\t\tif (this.boxes().get(boxid)) {\n\t\t\t\t\treturn u.dreject({ code: 409, message: 'Box already exists: ' + boxid });\n\t\t\t\t}\n\t\t\t\tvar c = this._create(boxid), this_ = this;\n\t\t\t\tu.debug('creating ', boxid);\n\t\t\t\treturn c.save().pipe(function() { return this_.get_box(boxid); });\n\t\t\t},\n\t\t\tcheck_login:function() {\n\t\t\t\t// checks whether you can connect to the server and who is logged in.\n\t\t\t\t// returns a deferred that gets passed an argument\n\t\t\t\t// { code:200 (server is okay),  is_authenticated:true/false,  user:<username>  }\n\t\t\t\treturn this._ajax('GET', 'auth/whoami');\n\t\t\t},\n\t\t\t// todo: change to _\n\t\t\tget_info:function() { return this._ajax('GET', 'admin/info'); },\n\t\t\tlogin : function(username,password) {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tthis.set({username:username,password:password});\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis._ajax('POST', 'auth/login', { username: username, password: password })\n\t\t\t\t\t.then(function(l) { this_.trigger('login', username); d.resolve(l); })\n\t\t\t\t\t.fail(function(l) { d.reject(l); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\treconnect:function() {\n\t\t\t\treturn this.login(this.get('username'),this.get('password'));\n\t\t\t},\n\t\t\tlogout : function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tvar this_ = this;\n\t\t\t\tthis._ajax('POST', 'auth/logout')\n\t\t\t\t\t.then(function(l) { this_.trigger('logout'); d.resolve(l); })\n\t\t\t\t\t.fail(function(l) { d.reject(l); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_create:function(boxid) {\n\t\t\t\tvar b = new Box({}, {store: this});\n\t\t\t\tb.cid = boxid;\n\t\t\t\tthis.boxes().add(b);\n\t\t\t\treturn b;\n\t\t\t},\n\t\t\tget_box_list:function() {\n\t\t\t\tvar d = u.deferred();\n\t\t\t\tthis._ajax('GET','admin/list_boxes')\n\t\t\t\t\t.success(function(data) {d.resolve(data.list);})\n\t\t\t\t\t.fail(function(err) { d.reject(err); });\n\t\t\t\treturn d.promise();\n\t\t\t},\n\t\t\t_fetch:function() {\n\t\t\t\tthrow new Error('dont fetch a store - any more!');\n\t\t\t\t//\n\t\t\t\t// fetches list of boxes\n\t\t\t\t/* - do not do this\n\t\t\t\tvar this_ = this, d = u.deferred();\n\t\t\t\tthis._ajax('GET','admin/list_boxes')\n\t\t\t\t\t.success(function(data) {\n\t\t\t\t\t\tu.when(data.list.map(function(boxid) { return this_.get_box(boxid); })).then(function(boxes) {\n\t\t\t\t\t\t\t// console.log(\"boxes !! \", boxes);\n\t\t\t\t\t\t\tthis_.boxes().reset(boxes);\n\t\t\t\t\t\t\td.resolve(boxes);\n\t\t\t\t\t\t});\n\t\t\t\t\t}).error(function(e) { d.reject(e); });\n\t\t\t\treturn d.promise();\n\t\t\t\t*/\n\t\t\t},\n\t\t\t_ajax:function(method, path, data) {\n\t\t\t\t// now uses relative url scheme '//blah:port/path';\n\t\t\t\tvar url = ['/', this.get('server_host'), path].join('/');\n\t\t\t\tvar default_data = { app: this.get('app') };\n\t\t\t\tvar options = _(_(this.ajax_defaults).clone()).extend(\n\t\t\t\t\t{ url: url, method : method, crossDomain: !this.is_same_domain(), data: _(default_data).extend(data) }\n\t\t\t\t);\n\t\t\t\treturn $.ajax( options ); // returns a deferred\n\t\t\t},\n\t\t\tsync: function(method, model, options){\n\t\t\t\tswitch(method){\n\t\t\t\tcase \"create\": return u.error('store.create() : cannot create a store'); // TODO\n\t\t\t\tcase \"read\"  : return model._fetch();\n\t\t\t\tcase \"update\": return u.error('store.update() : cannot update a store'); // TODO\n\t\t\t\tcase \"delete\": return u.error('store.delete() : cannot delete a store'); // tODO\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tvar exports = {\n\t\t\tsafe_apply:utils.safe_apply,\n\t\t\tu : utils,\n\t\t\tStore:Store,\n\t\t\tObj: Obj,\n\t\t\tFile:File,\n\t\t\tBox: Box,\n\t\t\tstore: new Store(),\n\t\t\tloaded : utils.deferred()\n\t\t};\n\t\twindow.u = utils;\n\n\t\t// do not fetch boxes\n\t\texports.loaded.resolve(exports);\n\t\treturn exports;\n\n\t}).factory('backbone', function(client, utils) {\n\t\t// this manages backbone-angular mystification\n\t\tvar deregfns = [];\n\t\tvar deep_clone_obj = function(o) {\n\t\t\treturn utils.dict(_(o).map(function(v,k) { return [k, v.concat()]; }));\n\t\t};\n\t\tvar scope_bind = function($scope, name, model) {\n\t\t\tutils.assert(model instanceof Backbone.Model, \"tried to bind something that was not a model\");\n\t\t\twindow._m = model;\n\t\t\tvar clone = deep_clone_obj(_(model.attributes));\n\t\t\tutils.safe_apply($scope, function() { $scope[name] = clone;\t});\n\t\t\tvar findchanges = function(old,new_,fn) {\n\t\t\t\tvar changes = [];\n\t\t\t\t_(old).map(function(v,k) {\n\t\t\t\t\tif (v.length !== new_[k].length || _(v).filter(function(vi, i) { return vi != new_[k][i]; }).length) {\n\t\t\t\t\t\tutils.log('pushing changes ', k, new_[k]);\n\t\t\t\t\t\tchanges.push(k);\n\t\t\t\t\t\tif (fn) { fn(k,new_[k].concat()); }\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn changes;\n\t\t\t};\n\t\t\t// angular -> backbone\n\t\t\tvar dereg = $scope.$watch(name, function() {\n\t\t\t\t// do a quick diff --\n\t\t\t\t// first check to make sure that our brave model is still\n\t\t\t\tif ($scope[name] !== clone) { return true; }\n\t\t\t\tfindchanges(model.attributes, clone, function(k,v) {model.set(k,v); });\n\t\t\t}, true);\n\t\t\tderegfns.push([$scope,name,model,dereg]);\n\t\t\t// backbone -> angular\n\t\t\tmodel.on('change', function(data) {\n\t\t\t\tutils.safe_apply($scope, function() {\n\t\t\t\t\tfindchanges(clone, model.attributes, function(k,v) { clone[k] = v;\t});\n\t\t\t\t});\n\t\t\t},$scope);\n\t\t};\n\t\treturn {\n\t\t\tscope_bind: scope_bind,\n\t\t\tscope_unbind:function($scope,name) {\n\t\t\t\tderegfns.map(function(tuple) {\n\t\t\t\t\tvar scope = tuple[0],name = tuple[1],model = tuple[2],dereg = tuple[3];\n\t\t\t\t\tmodel.off('change', null, scope);\n\t\t\t\t\tdereg();\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t});\n","title":"INDX","description":"blah","parameters":""}],"classes":["~classes~0","~1","~classes~0","~1","~2","~3","~4","~5","~6"],"basePath":"../html/","filePaths":["../docs/abstracts/*","js/indx.js"],"project":{"title":"INDX","version":"0.01","description":"INDX is a personal file store being developed at the University of Southampton, for the SOCIAM project."},"superclasses":{}}
    </script>
  </head>
  <body>
    <div class="sidebar">
      
        <h3>Backbone.js</h3>
        
      
        <h3>INDX</h3>
        
          <ul class="nav nav-list">
            
              <li class="nav-header"><a href="#File">File</a></li>
              
                <li><a href="#function () { [native code] }-initialize">initialize</a></li>
              
                <li><a href="#function () { [native code] }-get_id">get_id</a></li>
              
                <li><a href="#function () { [native code] }-get_url">get_url</a></li>
              
            
              <li class="nav-header"><a href="#Obj">Obj</a></li>
              
                <li><a href="#function () { [native code] }-initialize">initialize</a></li>
              
                <li><a href="#function () { [native code] }-get_id">get_id</a></li>
              
                <li><a href="#function () { [native code] }-set">set</a></li>
              
                <li><a href="#function () { [native code] }-delete_properties">delete_properties</a></li>
              
                <li><a href="#function () { [native code] }-sync">sync</a></li>
              
            
              <li class="nav-header"><a href="#Box">Box</a></li>
              
                <li><a href="#function () { [native code] }-initialize">initialize</a></li>
              
                <li><a href="#function () { [native code] }-get_or_create_file">get_or_create_file</a></li>
              
                <li><a href="#function () { [native code] }-set_up_websocket">set_up_websocket</a></li>
              
                <li><a href="#function () { [native code] }-onmessage">onmessage</a></li>
              
                <li><a href="#function () { [native code] }-onopen">onopen</a></li>
              
                <li><a href="#function () { [native code] }-onclose">onclose</a></li>
              
                <li><a href="#function () { [native code] }-get_use_websockets">get_use_websockets</a></li>
              
                <li><a href="#function () { [native code] }-get_cache_size">get_cache_size</a></li>
              
                <li><a href="#function () { [native code] }-get_obj_ids">get_obj_ids</a></li>
              
                <li><a href="#function () { [native code] }-get_token">get_token</a></li>
              
                <li><a href="#function () { [native code] }-get_id">get_id</a></li>
              
                <li><a href="#function () { [native code] }-put_file">put_file</a></li>
              
                <li><a href="#function () { [native code] }-cb">cb</a></li>
              
                <li><a href="#function () { [native code] }-query">query</a></li>
              
                <li><a href="#function () { [native code] }-get_obj">get_obj</a></li>
              
                <li><a href="#function () { [native code] }-delete_box">delete_box</a></li>
              
                <li><a href="#function () { [native code] }-update">update</a></li>
              
                <li><a href="#function () { [native code] }-sync">sync</a></li>
              
                <li><a href="#function () { [native code] }-toString">toString</a></li>
              
            
              <li class="nav-header"><a href="#Store">Store</a></li>
              
                <li><a href="#function () { [native code] }-initialize">initialize</a></li>
              
                <li><a href="#function () { [native code] }-is_same_domain">is_same_domain</a></li>
              
                <li><a href="#function () { [native code] }-boxes">boxes</a></li>
              
                <li><a href="#function () { [native code] }-get_box">get_box</a></li>
              
                <li><a href="#function () { [native code] }-create_box">create_box</a></li>
              
                <li><a href="#function () { [native code] }-check_login">check_login</a></li>
              
                <li><a href="#function () { [native code] }-get_info">get_info</a></li>
              
                <li><a href="#function () { [native code] }-login">login</a></li>
              
                <li><a href="#function () { [native code] }-reconnect">reconnect</a></li>
              
                <li><a href="#function () { [native code] }-logout">logout</a></li>
              
                <li><a href="#function () { [native code] }-get_box_list">get_box_list</a></li>
              
                <li><a href="#function () { [native code] }-sync">sync</a></li>
              
                <li><a href="#function () { [native code] }-deep_clone_obj">deep_clone_obj</a></li>
              
                <li><a href="#function () { [native code] }-scope_bind">scope_bind</a></li>
              
                <li><a href="#function () { [native code] }-findchanges">findchanges</a></li>
              
                <li><a href="#function () { [native code] }-scope_unbind">scope_unbind</a></li>
              
            
              <li class="nav-header"><a href="#ObjCollection">ObjCollection</a></li>
              
            
              <li class="nav-header"><a href="#FileCollection">FileCollection</a></li>
              
            
              <li class="nav-header"><a href="#BoxCollection">BoxCollection</a></li>
              
            
          </ul>
        
      
    </div>
    <div class="mainbody">
      <h1>INDX 0.01</h1>

      INDX is a personal file store being developed at the University of Southampton, for the SOCIAM project.

      
        <div class="file">
          
          
            <h2>Backbone.js</h2>

	<a name="Model"></a>
<h3>Backbone.Model</h3>


  <code class="header-example">model.extend(

  [classProperties,]

  properties

)</code>


  <code class="header-example">model.initialize(

  [options,]

  [attributes]

)</code>


  <code class="header-example">model.get(

  attribute

)</code>


  <code class="header-example">model.set(

)</code>


  <code class="header-example">model.escape(

)</code>


  <code class="header-example">model.has(

)</code>


  <code class="header-example">model.unset(

)</code>


  <code class="header-example">model.clear(

)</code>


  <code class="header-example">model.toJSON(

)</code>


  <code class="header-example">model.initialize(

)</code>


  <code class="header-example">model.fetch(

)</code>


  <code class="header-example">model.save(

)</code>


  <code class="header-example">model.destroy(

)</code>


  <code class="header-example">model.isValid(

)</code>


  <code class="header-example">model.clone(

)</code>


  <code class="header-example">model.isNew(

)</code>


  <code class="header-example">model.hasChanged(

)</code>


  <code class="header-example">model.previous(

)</code>


  <code class="header-example">model.changedAttributes(

)</code>


  <code class="header-example">model.previousAttributes(

)</code>


  <code class="header-example">model.id(

)</code>


  <code class="header-example">model.attributes(

)</code>


  <code class="header-example">model.cid(

)</code>


  <code class="header-example">model.changed(

)</code>


  <code class="header-example">model.url(

)</code>




	<a name="Collection"></a>
<h3>Backbone.Collection</h3>


  <code class="header-example">collection.extend(

)</code>


  <code class="header-example">collection.initialize(

)</code>


  <code class="header-example">collection.add(

)</code>


  <code class="header-example">collection.remove(

)</code>


  <code class="header-example">collection.reset(

)</code>


  <code class="header-example">collection.get(

)</code>


  <code class="header-example">collection.set(

)</code>


  <code class="header-example">collection.at(

)</code>


  <code class="header-example">collection.push(

)</code>


  <code class="header-example">collection.pop(

)</code>


  <code class="header-example">collection.unshift(

)</code>


  <code class="header-example">collection.shift(

)</code>


  <code class="header-example">collection.slice(

)</code>


  <code class="header-example">collection.sort(

)</code>


  <code class="header-example">collection.pluck(

)</code>


  <code class="header-example">collection.where(

)</code>


  <code class="header-example">collection.findWhere(

)</code>


  <code class="header-example">collection.clone(

)</code>


  <code class="header-example">collection.fetch(

)</code>


  <code class="header-example">collection.create(

)</code>


  <code class="header-example">collection.model(

)</code>


  <code class="header-example">collection.models(

)</code>





          
        </div>
      
        <div class="file">
          
            <h2>INDX</h2>
blah

	<div class="class">
	<a name="File"></a>
	<h3>File</h3>
	
	  <div class="extends">extends <i>Backbone.Model</i></div><br>
	  <h4>Inherited methods from Backbone.Model</h4>
	  <ul>
	  	
	  		<li><code class="header-example">model.extend(

  [classProperties,]

  properties

)</code>
</li>
	  	
	  		<li><code class="header-example">model.initialize(

  [options,]

  [attributes]

)</code>
</li>
	  	
	  		<li><code class="header-example">model.get(

  attribute

)</code>
</li>
	  	
	  		<li><code class="header-example">model.set(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.escape(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.has(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.unset(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.clear(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.toJSON(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.initialize(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.fetch(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.save(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.destroy(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.isValid(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.clone(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.isNew(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.hasChanged(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.previous(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.changedAttributes(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.previousAttributes(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.id(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.attributes(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.cid(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.changed(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.url(

)</code>
</li>
	  	
	  </ul>
	
	<br>
	
	  <div class="method well">
  <a name="function () { [native code] }-initialize"></a>
  <h4>initialize</h4>

  <code class="header-example">file.initialize(
  
    attrs,
  
    options
  
  )</code>

  <div class="lineno">132</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>attrs
            
          </li>
        
          <li>options
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-get_id"></a>
  <h4>get_id</h4>

  <code class="header-example">file.get_id(
  
  )</code>

  <div class="lineno">136</div>

  <div>

    <div class="description">
      
    </div>

    

    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-get_url"></a>
  <h4>get_url</h4>

  <code class="header-example">file.get_url(
  
  )</code>

  <div class="lineno">137</div>

  <div>

    <div class="description">
      
    </div>

    

    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
</div>


	<div class="class">
	<a name="Obj"></a>
	<h3>Obj</h3>
	
	  <div class="extends">extends <i>Backbone.Model</i></div><br>
	  <h4>Inherited methods from Backbone.Model</h4>
	  <ul>
	  	
	  		<li><code class="header-example">model.extend(

  [classProperties,]

  properties

)</code>
</li>
	  	
	  		<li><code class="header-example">model.initialize(

  [options,]

  [attributes]

)</code>
</li>
	  	
	  		<li><code class="header-example">model.get(

  attribute

)</code>
</li>
	  	
	  		<li><code class="header-example">model.set(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.escape(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.has(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.unset(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.clear(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.toJSON(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.initialize(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.fetch(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.save(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.destroy(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.isValid(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.clone(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.isNew(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.hasChanged(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.previous(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.changedAttributes(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.previousAttributes(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.id(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.attributes(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.cid(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.changed(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.url(

)</code>
</li>
	  	
	  </ul>
	
	<br>
	
	  <div class="method well">
  <a name="function () { [native code] }-initialize"></a>
  <h4>initialize</h4>

  <code class="header-example">obj.initialize(
  
    attrs,
  
    options
  
  )</code>

  <div class="lineno">162</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>attrs
            
          </li>
        
          <li>options
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-get_id"></a>
  <h4>get_id</h4>

  <code class="header-example">obj.get_id(
  
  )</code>

  <div class="lineno">167</div>

  <div>

    <div class="description">
      
    </div>

    

    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-set"></a>
  <h4>set</h4>

  <code class="header-example">obj.set(
  
    k,
  
    v,
  
    options
  
  )</code>

  <div class="lineno">185</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>k
            
          </li>
        
          <li>v
            
          </li>
        
          <li>options
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-delete_properties"></a>
  <h4>delete_properties</h4>

  <code class="header-example">obj.delete_properties(
  
    props,
  
    silent
  
  )</code>

  <div class="lineno">192</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>props
            
          </li>
        
          <li>silent
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-sync"></a>
  <h4>sync</h4>

  <code class="header-example">obj.sync(
  
    method,
  
    model,
  
    options
  
  )</code>

  <div class="lineno">263</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>method
            
          </li>
        
          <li>model
            
          </li>
        
          <li>options
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
</div>


	<div class="class">
	<a name="Box"></a>
	<h3>Box</h3>
	
	  <div class="extends">extends <i>Backbone.Model</i></div><br>
	  <h4>Inherited methods from Backbone.Model</h4>
	  <ul>
	  	
	  		<li><code class="header-example">model.extend(

  [classProperties,]

  properties

)</code>
</li>
	  	
	  		<li><code class="header-example">model.initialize(

  [options,]

  [attributes]

)</code>
</li>
	  	
	  		<li><code class="header-example">model.get(

  attribute

)</code>
</li>
	  	
	  		<li><code class="header-example">model.set(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.escape(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.has(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.unset(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.clear(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.toJSON(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.initialize(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.fetch(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.save(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.destroy(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.isValid(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.clone(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.isNew(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.hasChanged(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.previous(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.changedAttributes(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.previousAttributes(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.id(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.attributes(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.cid(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.changed(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.url(

)</code>
</li>
	  	
	  </ul>
	
	<br>
	
	  <div class="method well">
  <a name="function () { [native code] }-initialize"></a>
  <h4>initialize</h4>

  <code class="header-example">box.initialize(
  
    attributes,
  
    options
  
  )</code>

  <div class="lineno">286</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>attributes
            
          </li>
        
          <li>options
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-get_or_create_file"></a>
  <h4>get_or_create_file</h4>

  <code class="header-example">box.get_or_create_file(
  
    fid
  
  )</code>

  <div class="lineno">305</div>

  <div>

    <div class="description">
      &lt;string&gt; fid file id
/// Tries to get a file with given id. If it doesn't exist, a file with that name is created.
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>fid
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-set_up_websocket"></a>
  <h4>set_up_websocket</h4>

  <code class="header-example">box.set_up_websocket(
  
  )</code>

  <div class="lineno">312</div>

  <div>

    <div class="description">
      
    </div>

    

    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-onmessage"></a>
  <h4>onmessage</h4>

  <code class="header-example">box.onmessage(
  
    evt
  
  )</code>

  <div class="lineno">327</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>evt
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-onopen"></a>
  <h4>onopen</h4>

  <code class="header-example">box.onopen(
  
  )</code>

  <div class="lineno">339</div>

  <div>

    <div class="description">
      
    </div>

    

    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-onclose"></a>
  <h4>onclose</h4>

  <code class="header-example">box.onclose(
  
    evt
  
  )</code>

  <div class="lineno">347</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>evt
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-get_use_websockets"></a>
  <h4>get_use_websockets</h4>

  <code class="header-example">box.get_use_websockets(
  
  )</code>

  <div class="lineno">361</div>

  <div>

    <div class="description">
      
    </div>

    

    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-get_cache_size"></a>
  <h4>get_cache_size</h4>

  <code class="header-example">box.get_cache_size(
  
    i
  
  )</code>

  <div class="lineno">362</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>i
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-get_obj_ids"></a>
  <h4>get_obj_ids</h4>

  <code class="header-example">box.get_obj_ids(
  
  )</code>

  <div class="lineno">363</div>

  <div>

    <div class="description">
      
    </div>

    

    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-get_token"></a>
  <h4>get_token</h4>

  <code class="header-example">box.get_token(
  
  )</code>

  <div class="lineno">371</div>

  <div>

    <div class="description">
      
    </div>

    

    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-get_id"></a>
  <h4>get_id</h4>

  <code class="header-example">box.get_id(
  
  )</code>

  <div class="lineno">384</div>

  <div>

    <div class="description">
      
    </div>

    

    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-put_file"></a>
  <h4>put_file</h4>

  <code class="header-example">box.put_file(
  
    id,
  
    filedata,
  
    contenttype
  
  )</code>

  <div class="lineno">389</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>id
            
          </li>
        
          <li>filedata
            
          </li>
        
          <li>contenttype
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-cb"></a>
  <h4>cb</h4>

  <code class="header-example">box.cb(
  
  )</code>

  <div class="lineno">400</div>

  <div>

    <div class="description">
      
    </div>

    

    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-query"></a>
  <h4>query</h4>

  <code class="header-example">box.query(
  
    q
  
  )</code>

  <div class="lineno">428</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>q
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-get_obj"></a>
  <h4>get_obj</h4>

  <code class="header-example">box.get_obj(
  
    objid
  
  )</code>

  <div class="lineno">521</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>objid
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-delete_box"></a>
  <h4>delete_box</h4>

  <code class="header-example">box.delete_box(
  
    boxid
  
  )</code>

  <div class="lineno">655</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>boxid
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-update"></a>
  <h4>update</h4>

  <code class="header-example">box.update(
  
    original_ids
  
  )</code>

  <div class="lineno">729</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>original_ids
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-sync"></a>
  <h4>sync</h4>

  <code class="header-example">box.sync(
  
    method,
  
    box,
  
    options
  
  )</code>

  <div class="lineno">784</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>method
            
          </li>
        
          <li>box
            
          </li>
        
          <li>options
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-toString"></a>
  <h4>toString</h4>

  <code class="header-example">box.toString(
  
  )</code>

  <div class="lineno">793</div>

  <div>

    <div class="description">
      
    </div>

    

    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
</div>


	<div class="class">
	<a name="Store"></a>
	<h3>Store</h3>
	
	  <div class="extends">extends <i>Backbone.Model</i></div><br>
	  <h4>Inherited methods from Backbone.Model</h4>
	  <ul>
	  	
	  		<li><code class="header-example">model.extend(

  [classProperties,]

  properties

)</code>
</li>
	  	
	  		<li><code class="header-example">model.initialize(

  [options,]

  [attributes]

)</code>
</li>
	  	
	  		<li><code class="header-example">model.get(

  attribute

)</code>
</li>
	  	
	  		<li><code class="header-example">model.set(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.escape(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.has(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.unset(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.clear(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.toJSON(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.initialize(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.fetch(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.save(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.destroy(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.isValid(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.clone(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.isNew(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.hasChanged(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.previous(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.changedAttributes(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.previousAttributes(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.id(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.attributes(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.cid(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.changed(

)</code>
</li>
	  	
	  		<li><code class="header-example">model.url(

)</code>
</li>
	  	
	  </ul>
	
	<br>
	
	  <div class="method well">
  <a name="function () { [native code] }-initialize"></a>
  <h4>initialize</h4>

  <code class="header-example">store.initialize(
  
    [options,]
  
    [attributes]
  
  )</code>

  <div class="lineno">811</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>options
             -
              
                (
                  <code>{}</code>
                  
                )
              
              
            
          </li>
        
          <li>attributes
             -
              
                (
                  <code>{}</code>
                  
                )
              
              
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-is_same_domain"></a>
  <h4>is_same_domain</h4>

  <code class="header-example">store.is_same_domain(
  
  )</code>

  <div class="lineno">816</div>

  <div>

    <div class="description">
      
    </div>

    

    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-boxes"></a>
  <h4>boxes</h4>

  <code class="header-example">store.boxes(
  
  )</code>

  <div class="lineno">819</div>

  <div>

    <div class="description">
      
    </div>

    

    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-get_box"></a>
  <h4>get_box</h4>

  <code class="header-example">store.get_box(
  
    boxid
  
  )</code>

  <div class="lineno">820</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>boxid
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-create_box"></a>
  <h4>create_box</h4>

  <code class="header-example">store.create_box(
  
    boxid
  
  )</code>

  <div class="lineno">839</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>boxid
             -
              
                (
                  <code>number</code>
                  or
                
                  <code>string</code>
                  
                )
              
              the id for the box
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
        Returns a promise. Asynchronous.
        <h6>store.create_box(...).then (
          
            &lt;[object Object]&gt; the box,
          
        )</h6>
        
        <h6>fail</h6>
        <ul>
          
          <li>
            <h6>store.create_box(...).fail (
              
                &lt;[object Object]&gt; response,
              
            )</h6>
            other error
          </li>
          
          <li>
            <h6>store.create_box(...).fail (
              
                &lt;[object Object]&gt; response,
              
            )</h6>
            box already exists
          </li>
          
        </ul>
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-check_login"></a>
  <h4>check_login</h4>

  <code class="header-example">store.check_login(
  
  )</code>

  <div class="lineno">848</div>

  <div>

    <div class="description">
      
    </div>

    

    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-get_info"></a>
  <h4>get_info</h4>

  <code class="header-example">store.get_info(
  
  )</code>

  <div class="lineno">855</div>

  <div>

    <div class="description">
      
    </div>

    

    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-login"></a>
  <h4>login</h4>

  <code class="header-example">store.login(
  
    username,
  
    password
  
  )</code>

  <div class="lineno">856</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>username
            
          </li>
        
          <li>password
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-reconnect"></a>
  <h4>reconnect</h4>

  <code class="header-example">store.reconnect(
  
  )</code>

  <div class="lineno">865</div>

  <div>

    <div class="description">
      
    </div>

    

    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-logout"></a>
  <h4>logout</h4>

  <code class="header-example">store.logout(
  
  )</code>

  <div class="lineno">868</div>

  <div>

    <div class="description">
      
    </div>

    

    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-get_box_list"></a>
  <h4>get_box_list</h4>

  <code class="header-example">store.get_box_list(
  
  )</code>

  <div class="lineno">882</div>

  <div>

    <div class="description">
      
    </div>

    

    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-sync"></a>
  <h4>sync</h4>

  <code class="header-example">store.sync(
  
    method,
  
    model,
  
    options
  
  )</code>

  <div class="lineno">915</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>method
            
          </li>
        
          <li>model
            
          </li>
        
          <li>options
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-deep_clone_obj"></a>
  <h4>deep_clone_obj</h4>

  <code class="header-example">store.deep_clone_obj(
  
    o
  
  )</code>

  <div class="lineno">944</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>o
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-scope_bind"></a>
  <h4>scope_bind</h4>

  <code class="header-example">store.scope_bind(
  
    $scope,
  
    name,
  
    model
  
  )</code>

  <div class="lineno">947</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>$scope
            
          </li>
        
          <li>name
            
          </li>
        
          <li>model
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-findchanges"></a>
  <h4>findchanges</h4>

  <code class="header-example">store.findchanges(
  
    old,
  
    new_,
  
    fn
  
  )</code>

  <div class="lineno">952</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>old
            
          </li>
        
          <li>new_
            
          </li>
        
          <li>fn
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
	  <div class="method well">
  <a name="function () { [native code] }-scope_unbind"></a>
  <h4>scope_unbind</h4>

  <code class="header-example">store.scope_unbind(
  
    $scope,
  
    name
  
  )</code>

  <div class="lineno">979</div>

  <div>

    <div class="description">
      
    </div>

    

    
      <br>
      Arguments:
      <ol class="arguments">
        
          <li>$scope
            
          </li>
        
          <li>name
            
          </li>
        
      </ol>
    

    <br>

    Returns:
    <div class="return">
      
    </div>
  </div>
</div>

	
</div>


	<div class="class">
	<a name="ObjCollection"></a>
	<h3>ObjCollection</h3>
	
	  <div class="extends">extends <i>Backbone.Collection</i></div><br>
	  <h4>Inherited methods from Backbone.Collection</h4>
	  <ul>
	  	
	  		<li><code class="header-example">collection.extend(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.initialize(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.add(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.remove(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.reset(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.get(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.set(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.at(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.push(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.pop(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.unshift(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.shift(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.slice(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.sort(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.pluck(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.where(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.findWhere(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.clone(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.fetch(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.create(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.model(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.models(

)</code>
</li>
	  	
	  </ul>
	
	<br>
	
</div>


	<div class="class">
	<a name="FileCollection"></a>
	<h3>FileCollection</h3>
	
	  <div class="extends">extends <i>Backbone.Collection</i></div><br>
	  <h4>Inherited methods from Backbone.Collection</h4>
	  <ul>
	  	
	  		<li><code class="header-example">collection.extend(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.initialize(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.add(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.remove(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.reset(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.get(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.set(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.at(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.push(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.pop(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.unshift(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.shift(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.slice(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.sort(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.pluck(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.where(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.findWhere(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.clone(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.fetch(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.create(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.model(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.models(

)</code>
</li>
	  	
	  </ul>
	
	<br>
	
</div>


	<div class="class">
	<a name="BoxCollection"></a>
	<h3>BoxCollection</h3>
	
	  <div class="extends">extends <i>Backbone.Collection</i></div><br>
	  <h4>Inherited methods from Backbone.Collection</h4>
	  <ul>
	  	
	  		<li><code class="header-example">collection.extend(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.initialize(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.add(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.remove(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.reset(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.get(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.set(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.at(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.push(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.pop(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.unshift(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.shift(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.slice(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.sort(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.pluck(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.where(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.findWhere(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.clone(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.fetch(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.create(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.model(

)</code>
</li>
	  	
	  		<li><code class="header-example">collection.models(

)</code>
</li>
	  	
	  </ul>
	
	<br>
	
</div>



          
          
        </div>
      
    </div>
  </body>
</html>
